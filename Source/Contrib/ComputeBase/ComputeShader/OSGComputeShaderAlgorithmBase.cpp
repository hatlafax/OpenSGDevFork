/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class ComputeShaderAlgorithm!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"



#include "OSGTextureImageChunk.h"       // TextureImages Class
#include "OSGChunkMaterial.h"           // ChunkMaterial Class
#include "OSGComputeShaderChunk.h"      // ComputeShader Class

#include "OSGComputeShaderAlgorithmBase.h"
#include "OSGComputeShaderAlgorithm.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::ComputeShaderAlgorithm
    This class allows the operation of a compute shader algorithm. It allows the specification of 
    shader buffers and textures to be used in the computation task and the details of the computational
    space the compute shader operats on.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var TextureImageChunk * ComputeShaderAlgorithmBase::_mfTextureImages
    Texture images to be used for reading/writing in the compute shader.
    The texture images uses the binding points starting from 0 and then 
    incrementing by 1.
*/

/*! \var ChunkMaterial * ComputeShaderAlgorithmBase::_sfChunkMaterial
    This chunk material allows the usage of texture images, uniform buffer objects
    and shader storage buffer objects in the compute shader. Only these material
    chunks are going to be respected, all other will simply omitted. A valid
    chunk in the chunk material specifies the binding point to be used in the compute
    shader.
*/

/*! \var ComputeShaderChunk * ComputeShaderAlgorithmBase::_sfComputeShader
    The compute shader abstracts the actual shader code and the variable specifications
    used in the shader.
*/

/*! \var Vec3i           ComputeShaderAlgorithmBase::_sfDispatchConfig
    The number of work groups, i.e. the work group count.
*/

/*! \var Vec3i           ComputeShaderAlgorithmBase::_sfWorkGroupSize
    The size of the work groups, i.e. the local_size_var value of the layout specifier.
    This does need the ARB_compute_variable_group_size GL extension to work.
*/

/*! \var bool            ComputeShaderAlgorithmBase::_sfUseMemoryBarrier
    This flag toggles the usage of the memory barrier call after the operation of
    the compute shader.
*/

/*! \var bool            ComputeShaderAlgorithmBase::_sfUseVariableWorkGroupSize
    This flag enables the useage of the variable work group size dispatch API that
    is specified in the ARB_compute_variable_group_size extension.
*/

/*! \var GLenum          ComputeShaderAlgorithmBase::_sfMemoryBarrier
    This bitmask determines the behavior of the memory barrier that is issued after the
    operation of the compute shader.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<ComputeShaderAlgorithm *, nsOSG>::_type(
    "ComputeShaderAlgorithmPtr", 
    "ComputeAlgorithmPtr", 
    ComputeShaderAlgorithm::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(ComputeShaderAlgorithm *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           ComputeShaderAlgorithm *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           ComputeShaderAlgorithm *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void ComputeShaderAlgorithmBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFUnrecTextureImageChunkPtr::Description(
        MFUnrecTextureImageChunkPtr::getClassType(),
        "textureImages",
        "Texture images to be used for reading/writing in the compute shader.\n"
        "The texture images uses the binding points starting from 0 and then \n"
        "incrementing by 1.\n",
        TextureImagesFieldId, TextureImagesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleTextureImages),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleTextureImages));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChunkMaterialPtr::Description(
        SFUnrecChunkMaterialPtr::getClassType(),
        "chunkMaterial",
        "This chunk material allows the usage of texture images, uniform buffer objects\n"
        "and shader storage buffer objects in the compute shader. Only these material\n"
        "chunks are going to be respected, all other will simply omitted. A valid\n"
        "chunk in the chunk material specifies the binding point to be used in the compute\n"
        "shader.\n",
        ChunkMaterialFieldId, ChunkMaterialFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleChunkMaterial),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleChunkMaterial));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecComputeShaderChunkPtr::Description(
        SFUnrecComputeShaderChunkPtr::getClassType(),
        "computeShader",
        "The compute shader abstracts the actual shader code and the variable specifications\n"
        "used in the shader.\n",
        ComputeShaderFieldId, ComputeShaderFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleComputeShader),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleComputeShader));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3i::Description(
        SFVec3i::getClassType(),
        "dispatchConfig",
        "The number of work groups, i.e. the work group count.\n",
        DispatchConfigFieldId, DispatchConfigFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleDispatchConfig),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleDispatchConfig));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3i::Description(
        SFVec3i::getClassType(),
        "workGroupSize",
        "The size of the work groups, i.e. the local_size_var value of the layout specifier.\n"
        "This does need the ARB_compute_variable_group_size GL extension to work.\n",
        WorkGroupSizeFieldId, WorkGroupSizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleWorkGroupSize),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleWorkGroupSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useMemoryBarrier",
        "This flag toggles the usage of the memory barrier call after the operation of\n"
        "the compute shader.\n",
        UseMemoryBarrierFieldId, UseMemoryBarrierFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleUseMemoryBarrier),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleUseMemoryBarrier));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useVariableWorkGroupSize",
        "This flag enables the useage of the variable work group size dispatch API that\n"
        "is specified in the ARB_compute_variable_group_size extension.\n",
        UseVariableWorkGroupSizeFieldId, UseVariableWorkGroupSizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleUseVariableWorkGroupSize),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleUseVariableWorkGroupSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "memoryBarrier",
        "This bitmask determines the behavior of the memory barrier that is issued after the\n"
        "operation of the compute shader.\n",
        MemoryBarrierFieldId, MemoryBarrierFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ComputeShaderAlgorithm::editHandleMemoryBarrier),
        static_cast<FieldGetMethodSig >(&ComputeShaderAlgorithm::getHandleMemoryBarrier));

    oType.addInitialDesc(pDesc);
}


ComputeShaderAlgorithmBase::TypeObject ComputeShaderAlgorithmBase::_type(
    ComputeShaderAlgorithmBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&ComputeShaderAlgorithmBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&ComputeShaderAlgorithm::initMethod),
    reinterpret_cast<ExitContainerF>(&ComputeShaderAlgorithm::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&ComputeShaderAlgorithm::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"ComputeShaderAlgorithm\"\n"
    "\tparent=\"ComputeAlgorithm\"\n"
    "\tlibrary=\"ContribComputeBase\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    "    isNodeCore=\"false\"\n"
    "    >\n"
    "        This class allows the operation of a compute shader algorithm. It allows the specification of \n"
    "        shader buffers and textures to be used in the computation task and the details of the computational\n"
    "        space the compute shader operats on.\n"
    "        \n"
    "  <Field\n"
    "      name=\"textureImages\"\n"
    "      type=\"TextureImageChunk\"\n"
    "      category=\"pointer\"\n"
    "      cardinality=\"multi\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      >\n"
    "        Texture images to be used for reading/writing in the compute shader.\n"
    "        The texture images uses the binding points starting from 0 and then \n"
    "        incrementing by 1.\n"
    "  </Field>\n"
    "  <Field\n"
    "      name=\"chunkMaterial\"\n"
    "      type=\"ChunkMaterial\"\n"
    "      category=\"pointer\"\n"
    "      cardinality=\"single\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      >\n"
    "        This chunk material allows the usage of texture images, uniform buffer objects\n"
    "        and shader storage buffer objects in the compute shader. Only these material\n"
    "        chunks are going to be respected, all other will simply omitted. A valid\n"
    "        chunk in the chunk material specifies the binding point to be used in the compute\n"
    "        shader.\n"
    "  </Field>\n"
    "  <Field\n"
    "      name=\"computeShader\"\n"
    "      type=\"ComputeShaderChunk\"\n"
    "      category=\"pointer\"\n"
    "      cardinality=\"single\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      >\n"
    "        The compute shader abstracts the actual shader code and the variable specifications\n"
    "        used in the shader.\n"
    "  </Field>\n"
    "  <Field\n"
    "      name=\"dispatchConfig\"\n"
    "      type=\"Vec3i\"\n"
    "      cardinality=\"single\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      defaultValue=\"1, 0, 0\"\n"
    "      >\n"
    "        The number of work groups, i.e. the work group count.\n"
    "  </Field>\n"
    "<Field\n"
    "      name=\"workGroupSize\"\n"
    "      type=\"Vec3i\"\n"
    "      cardinality=\"single\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      defaultValue=\"1, 1, 1\"\n"
    "      >\n"
    "        The size of the work groups, i.e. the local_size_var value of the layout specifier.\n"
    "        This does need the ARB_compute_variable_group_size GL extension to work.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "      name=\"useMemoryBarrier\"\n"
    "      type=\"bool\"\n"
    "      cardinality=\"single\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      defaultValue=\"false\"\n"
    "      >\n"
    "        This flag toggles the usage of the memory barrier call after the operation of\n"
    "        the compute shader.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "      name=\"useVariableWorkGroupSize\"\n"
    "      type=\"bool\"\n"
    "      cardinality=\"single\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      defaultValue=\"false\"\n"
    "      >\n"
    "        This flag enables the useage of the variable work group size dispatch API that\n"
    "        is specified in the ARB_compute_variable_group_size extension.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "      name=\"memoryBarrier\"\n"
    "      type=\"GLenum\"\n"
    "      cardinality=\"single\"\n"
    "      visibility=\"external\"\n"
    "      access=\"public\"\n"
    "      defaultValue=\"GL_SHADER_STORAGE_BARRIER_BIT\"\n"
    "      >\n"
    "        This bitmask determines the behavior of the memory barrier that is issued after the\n"
    "        operation of the compute shader.\n"
    "  </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "This class allows the operation of a compute shader algorithm. It allows the specification of \n"
    "shader buffers and textures to be used in the computation task and the details of the computational\n"
    "space the compute shader operats on.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ComputeShaderAlgorithmBase::getType(void)
{
    return _type;
}

const FieldContainerType &ComputeShaderAlgorithmBase::getType(void) const
{
    return _type;
}

UInt32 ComputeShaderAlgorithmBase::getContainerSize(void) const
{
    return sizeof(ComputeShaderAlgorithm);
}

/*------------------------- decorator get ------------------------------*/


//! Get the ComputeShaderAlgorithm::_mfTextureImages field.
const MFUnrecTextureImageChunkPtr *ComputeShaderAlgorithmBase::getMFTextureImages(void) const
{
    return &_mfTextureImages;
}

MFUnrecTextureImageChunkPtr *ComputeShaderAlgorithmBase::editMFTextureImages  (void)
{
    editMField(TextureImagesFieldMask, _mfTextureImages);

    return &_mfTextureImages;
}
TextureImageChunk * ComputeShaderAlgorithmBase::getTextureImages(const UInt32 index) const
{
    return _mfTextureImages[index];
}

//! Get the ComputeShaderAlgorithm::_sfChunkMaterial field.
const SFUnrecChunkMaterialPtr *ComputeShaderAlgorithmBase::getSFChunkMaterial(void) const
{
    return &_sfChunkMaterial;
}

SFUnrecChunkMaterialPtr *ComputeShaderAlgorithmBase::editSFChunkMaterial  (void)
{
    editSField(ChunkMaterialFieldMask);

    return &_sfChunkMaterial;
}

//! Get the value of the ComputeShaderAlgorithm::_sfChunkMaterial field.
ChunkMaterial * ComputeShaderAlgorithmBase::getChunkMaterial(void) const
{
    return _sfChunkMaterial.getValue();
}

//! Set the value of the ComputeShaderAlgorithm::_sfChunkMaterial field.
void ComputeShaderAlgorithmBase::setChunkMaterial(ChunkMaterial * const value)
{
    editSField(ChunkMaterialFieldMask);

    _sfChunkMaterial.setValue(value);
}


//! Get the ComputeShaderAlgorithm::_sfComputeShader field.
const SFUnrecComputeShaderChunkPtr *ComputeShaderAlgorithmBase::getSFComputeShader(void) const
{
    return &_sfComputeShader;
}

SFUnrecComputeShaderChunkPtr *ComputeShaderAlgorithmBase::editSFComputeShader  (void)
{
    editSField(ComputeShaderFieldMask);

    return &_sfComputeShader;
}

//! Get the value of the ComputeShaderAlgorithm::_sfComputeShader field.
ComputeShaderChunk * ComputeShaderAlgorithmBase::getComputeShader(void) const
{
    return _sfComputeShader.getValue();
}

//! Set the value of the ComputeShaderAlgorithm::_sfComputeShader field.
void ComputeShaderAlgorithmBase::setComputeShader(ComputeShaderChunk * const value)
{
    editSField(ComputeShaderFieldMask);

    _sfComputeShader.setValue(value);
}


SFVec3i *ComputeShaderAlgorithmBase::editSFDispatchConfig(void)
{
    editSField(DispatchConfigFieldMask);

    return &_sfDispatchConfig;
}

const SFVec3i *ComputeShaderAlgorithmBase::getSFDispatchConfig(void) const
{
    return &_sfDispatchConfig;
}


SFVec3i *ComputeShaderAlgorithmBase::editSFWorkGroupSize(void)
{
    editSField(WorkGroupSizeFieldMask);

    return &_sfWorkGroupSize;
}

const SFVec3i *ComputeShaderAlgorithmBase::getSFWorkGroupSize(void) const
{
    return &_sfWorkGroupSize;
}


SFBool *ComputeShaderAlgorithmBase::editSFUseMemoryBarrier(void)
{
    editSField(UseMemoryBarrierFieldMask);

    return &_sfUseMemoryBarrier;
}

const SFBool *ComputeShaderAlgorithmBase::getSFUseMemoryBarrier(void) const
{
    return &_sfUseMemoryBarrier;
}


SFBool *ComputeShaderAlgorithmBase::editSFUseVariableWorkGroupSize(void)
{
    editSField(UseVariableWorkGroupSizeFieldMask);

    return &_sfUseVariableWorkGroupSize;
}

const SFBool *ComputeShaderAlgorithmBase::getSFUseVariableWorkGroupSize(void) const
{
    return &_sfUseVariableWorkGroupSize;
}


SFGLenum *ComputeShaderAlgorithmBase::editSFMemoryBarrier(void)
{
    editSField(MemoryBarrierFieldMask);

    return &_sfMemoryBarrier;
}

const SFGLenum *ComputeShaderAlgorithmBase::getSFMemoryBarrier(void) const
{
    return &_sfMemoryBarrier;
}




void ComputeShaderAlgorithmBase::pushToTextureImages(TextureImageChunk * const value)
{
    editMField(TextureImagesFieldMask, _mfTextureImages);

    _mfTextureImages.push_back(value);
}

void ComputeShaderAlgorithmBase::assignTextureImages(const MFUnrecTextureImageChunkPtr &value)
{
    MFUnrecTextureImageChunkPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecTextureImageChunkPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<ComputeShaderAlgorithm *>(this)->clearTextureImages();

    while(elemIt != elemEnd)
    {
        this->pushToTextureImages(*elemIt);

        ++elemIt;
    }
}

void ComputeShaderAlgorithmBase::removeFromTextureImages(UInt32 uiIndex)
{
    if(uiIndex < _mfTextureImages.size())
    {
        editMField(TextureImagesFieldMask, _mfTextureImages);

        _mfTextureImages.erase(uiIndex);
    }
}

void ComputeShaderAlgorithmBase::removeObjFromTextureImages(TextureImageChunk * const value)
{
    Int32 iElemIdx = _mfTextureImages.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TextureImagesFieldMask, _mfTextureImages);

        _mfTextureImages.erase(iElemIdx);
    }
}
void ComputeShaderAlgorithmBase::clearTextureImages(void)
{
    editMField(TextureImagesFieldMask, _mfTextureImages);


    _mfTextureImages.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT ComputeShaderAlgorithmBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (TextureImagesFieldMask & whichField))
    {
        returnValue += _mfTextureImages.getBinSize();
    }
    if(FieldBits::NoField != (ChunkMaterialFieldMask & whichField))
    {
        returnValue += _sfChunkMaterial.getBinSize();
    }
    if(FieldBits::NoField != (ComputeShaderFieldMask & whichField))
    {
        returnValue += _sfComputeShader.getBinSize();
    }
    if(FieldBits::NoField != (DispatchConfigFieldMask & whichField))
    {
        returnValue += _sfDispatchConfig.getBinSize();
    }
    if(FieldBits::NoField != (WorkGroupSizeFieldMask & whichField))
    {
        returnValue += _sfWorkGroupSize.getBinSize();
    }
    if(FieldBits::NoField != (UseMemoryBarrierFieldMask & whichField))
    {
        returnValue += _sfUseMemoryBarrier.getBinSize();
    }
    if(FieldBits::NoField != (UseVariableWorkGroupSizeFieldMask & whichField))
    {
        returnValue += _sfUseVariableWorkGroupSize.getBinSize();
    }
    if(FieldBits::NoField != (MemoryBarrierFieldMask & whichField))
    {
        returnValue += _sfMemoryBarrier.getBinSize();
    }

    return returnValue;
}

void ComputeShaderAlgorithmBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (TextureImagesFieldMask & whichField))
    {
        _mfTextureImages.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ChunkMaterialFieldMask & whichField))
    {
        _sfChunkMaterial.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ComputeShaderFieldMask & whichField))
    {
        _sfComputeShader.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DispatchConfigFieldMask & whichField))
    {
        _sfDispatchConfig.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WorkGroupSizeFieldMask & whichField))
    {
        _sfWorkGroupSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseMemoryBarrierFieldMask & whichField))
    {
        _sfUseMemoryBarrier.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseVariableWorkGroupSizeFieldMask & whichField))
    {
        _sfUseVariableWorkGroupSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MemoryBarrierFieldMask & whichField))
    {
        _sfMemoryBarrier.copyToBin(pMem);
    }
}

void ComputeShaderAlgorithmBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (TextureImagesFieldMask & whichField))
    {
        editMField(TextureImagesFieldMask, _mfTextureImages);
        _mfTextureImages.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ChunkMaterialFieldMask & whichField))
    {
        editSField(ChunkMaterialFieldMask);
        _sfChunkMaterial.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ComputeShaderFieldMask & whichField))
    {
        editSField(ComputeShaderFieldMask);
        _sfComputeShader.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DispatchConfigFieldMask & whichField))
    {
        editSField(DispatchConfigFieldMask);
        _sfDispatchConfig.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WorkGroupSizeFieldMask & whichField))
    {
        editSField(WorkGroupSizeFieldMask);
        _sfWorkGroupSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseMemoryBarrierFieldMask & whichField))
    {
        editSField(UseMemoryBarrierFieldMask);
        _sfUseMemoryBarrier.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseVariableWorkGroupSizeFieldMask & whichField))
    {
        editSField(UseVariableWorkGroupSizeFieldMask);
        _sfUseVariableWorkGroupSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MemoryBarrierFieldMask & whichField))
    {
        editSField(MemoryBarrierFieldMask);
        _sfMemoryBarrier.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ComputeShaderAlgorithmTransitPtr ComputeShaderAlgorithmBase::createLocal(BitVector bFlags)
{
    ComputeShaderAlgorithmTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<ComputeShaderAlgorithm>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
ComputeShaderAlgorithmTransitPtr ComputeShaderAlgorithmBase::createDependent(BitVector bFlags)
{
    ComputeShaderAlgorithmTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<ComputeShaderAlgorithm>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ComputeShaderAlgorithmTransitPtr ComputeShaderAlgorithmBase::create(void)
{
    ComputeShaderAlgorithmTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<ComputeShaderAlgorithm>(tmpPtr);
    }

    return fc;
}

ComputeShaderAlgorithm *ComputeShaderAlgorithmBase::createEmptyLocal(BitVector bFlags)
{
    ComputeShaderAlgorithm *returnValue;

    newPtr<ComputeShaderAlgorithm>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
ComputeShaderAlgorithm *ComputeShaderAlgorithmBase::createEmpty(void)
{
    ComputeShaderAlgorithm *returnValue;

    newPtr<ComputeShaderAlgorithm>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr ComputeShaderAlgorithmBase::shallowCopyLocal(
    BitVector bFlags) const
{
    ComputeShaderAlgorithm *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const ComputeShaderAlgorithm *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ComputeShaderAlgorithmBase::shallowCopyDependent(
    BitVector bFlags) const
{
    ComputeShaderAlgorithm *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const ComputeShaderAlgorithm *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr ComputeShaderAlgorithmBase::shallowCopy(void) const
{
    ComputeShaderAlgorithm *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const ComputeShaderAlgorithm *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

ComputeShaderAlgorithmBase::ComputeShaderAlgorithmBase(void) :
    Inherited(),
    _mfTextureImages          (),
    _sfChunkMaterial          (NULL),
    _sfComputeShader          (NULL),
    _sfDispatchConfig         (Vec3i(1, 0, 0)),
    _sfWorkGroupSize          (Vec3i(1, 1, 1)),
    _sfUseMemoryBarrier       (bool(false)),
    _sfUseVariableWorkGroupSize(bool(false)),
    _sfMemoryBarrier          (GLenum(GL_SHADER_STORAGE_BARRIER_BIT))
{
}

ComputeShaderAlgorithmBase::ComputeShaderAlgorithmBase(const ComputeShaderAlgorithmBase &source) :
    Inherited(source),
    _mfTextureImages          (),
    _sfChunkMaterial          (NULL),
    _sfComputeShader          (NULL),
    _sfDispatchConfig         (source._sfDispatchConfig         ),
    _sfWorkGroupSize          (source._sfWorkGroupSize          ),
    _sfUseMemoryBarrier       (source._sfUseMemoryBarrier       ),
    _sfUseVariableWorkGroupSize(source._sfUseVariableWorkGroupSize),
    _sfMemoryBarrier          (source._sfMemoryBarrier          )
{
}


/*-------------------------- destructors ----------------------------------*/

ComputeShaderAlgorithmBase::~ComputeShaderAlgorithmBase(void)
{
}

void ComputeShaderAlgorithmBase::onCreate(const ComputeShaderAlgorithm *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        ComputeShaderAlgorithm *pThis = static_cast<ComputeShaderAlgorithm *>(this);

        MFUnrecTextureImageChunkPtr::const_iterator TextureImagesIt  =
            source->_mfTextureImages.begin();
        MFUnrecTextureImageChunkPtr::const_iterator TextureImagesEnd =
            source->_mfTextureImages.end  ();

        while(TextureImagesIt != TextureImagesEnd)
        {
            pThis->pushToTextureImages(*TextureImagesIt);

            ++TextureImagesIt;
        }

        pThis->setChunkMaterial(source->getChunkMaterial());

        pThis->setComputeShader(source->getComputeShader());
    }
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleTextureImages   (void) const
{
    MFUnrecTextureImageChunkPtr::GetHandlePtr returnValue(
        new  MFUnrecTextureImageChunkPtr::GetHandle(
             &_mfTextureImages,
             this->getType().getFieldDesc(TextureImagesFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleTextureImages  (void)
{
    MFUnrecTextureImageChunkPtr::EditHandlePtr returnValue(
        new  MFUnrecTextureImageChunkPtr::EditHandle(
             &_mfTextureImages,
             this->getType().getFieldDesc(TextureImagesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&ComputeShaderAlgorithm::pushToTextureImages,
                    static_cast<ComputeShaderAlgorithm *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveMethod(
        boost::bind(&ComputeShaderAlgorithm::removeFromTextureImages,
                    static_cast<ComputeShaderAlgorithm *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveObjMethod(
        boost::bind(&ComputeShaderAlgorithm::removeObjFromTextureImages,
                    static_cast<ComputeShaderAlgorithm *>(this), ::boost::placeholders::_1));
    returnValue->setClearMethod(
        boost::bind(&ComputeShaderAlgorithm::clearTextureImages,
                    static_cast<ComputeShaderAlgorithm *>(this)));

    editMField(TextureImagesFieldMask, _mfTextureImages);

    return returnValue;
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleChunkMaterial   (void) const
{
    SFUnrecChunkMaterialPtr::GetHandlePtr returnValue(
        new  SFUnrecChunkMaterialPtr::GetHandle(
             &_sfChunkMaterial,
             this->getType().getFieldDesc(ChunkMaterialFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleChunkMaterial  (void)
{
    SFUnrecChunkMaterialPtr::EditHandlePtr returnValue(
        new  SFUnrecChunkMaterialPtr::EditHandle(
             &_sfChunkMaterial,
             this->getType().getFieldDesc(ChunkMaterialFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&ComputeShaderAlgorithm::setChunkMaterial,
                    static_cast<ComputeShaderAlgorithm *>(this), ::boost::placeholders::_1));

    editSField(ChunkMaterialFieldMask);

    return returnValue;
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleComputeShader   (void) const
{
    SFUnrecComputeShaderChunkPtr::GetHandlePtr returnValue(
        new  SFUnrecComputeShaderChunkPtr::GetHandle(
             &_sfComputeShader,
             this->getType().getFieldDesc(ComputeShaderFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleComputeShader  (void)
{
    SFUnrecComputeShaderChunkPtr::EditHandlePtr returnValue(
        new  SFUnrecComputeShaderChunkPtr::EditHandle(
             &_sfComputeShader,
             this->getType().getFieldDesc(ComputeShaderFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&ComputeShaderAlgorithm::setComputeShader,
                    static_cast<ComputeShaderAlgorithm *>(this), ::boost::placeholders::_1));

    editSField(ComputeShaderFieldMask);

    return returnValue;
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleDispatchConfig  (void) const
{
    SFVec3i::GetHandlePtr returnValue(
        new  SFVec3i::GetHandle(
             &_sfDispatchConfig,
             this->getType().getFieldDesc(DispatchConfigFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleDispatchConfig (void)
{
    SFVec3i::EditHandlePtr returnValue(
        new  SFVec3i::EditHandle(
             &_sfDispatchConfig,
             this->getType().getFieldDesc(DispatchConfigFieldId),
             this));


    editSField(DispatchConfigFieldMask);

    return returnValue;
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleWorkGroupSize   (void) const
{
    SFVec3i::GetHandlePtr returnValue(
        new  SFVec3i::GetHandle(
             &_sfWorkGroupSize,
             this->getType().getFieldDesc(WorkGroupSizeFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleWorkGroupSize  (void)
{
    SFVec3i::EditHandlePtr returnValue(
        new  SFVec3i::EditHandle(
             &_sfWorkGroupSize,
             this->getType().getFieldDesc(WorkGroupSizeFieldId),
             this));


    editSField(WorkGroupSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleUseMemoryBarrier (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseMemoryBarrier,
             this->getType().getFieldDesc(UseMemoryBarrierFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleUseMemoryBarrier(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseMemoryBarrier,
             this->getType().getFieldDesc(UseMemoryBarrierFieldId),
             this));


    editSField(UseMemoryBarrierFieldMask);

    return returnValue;
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleUseVariableWorkGroupSize (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseVariableWorkGroupSize,
             this->getType().getFieldDesc(UseVariableWorkGroupSizeFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleUseVariableWorkGroupSize(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseVariableWorkGroupSize,
             this->getType().getFieldDesc(UseVariableWorkGroupSizeFieldId),
             this));


    editSField(UseVariableWorkGroupSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ComputeShaderAlgorithmBase::getHandleMemoryBarrier   (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfMemoryBarrier,
             this->getType().getFieldDesc(MemoryBarrierFieldId),
             const_cast<ComputeShaderAlgorithmBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ComputeShaderAlgorithmBase::editHandleMemoryBarrier  (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfMemoryBarrier,
             this->getType().getFieldDesc(MemoryBarrierFieldId),
             this));


    editSField(MemoryBarrierFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ComputeShaderAlgorithmBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    ComputeShaderAlgorithm *pThis = static_cast<ComputeShaderAlgorithm *>(this);

    pThis->execSync(static_cast<ComputeShaderAlgorithm *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *ComputeShaderAlgorithmBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    ComputeShaderAlgorithm *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const ComputeShaderAlgorithm *>(pRefAspect),
                  dynamic_cast<const ComputeShaderAlgorithm *>(this));

    return returnValue;
}
#endif

void ComputeShaderAlgorithmBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<ComputeShaderAlgorithm *>(this)->clearTextureImages();

    static_cast<ComputeShaderAlgorithm *>(this)->setChunkMaterial(NULL);

    static_cast<ComputeShaderAlgorithm *>(this)->setComputeShader(NULL);


}


OSG_END_NAMESPACE
