/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class MultiLightShadowParameterAdvanced!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"




#include "OSGMultiLightShadowParameterAdvancedBase.h"
#include "OSGMultiLightShadowParameterAdvanced.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::MultiLightShadowParameterAdvanced
    Shadow parameters that are used for the advanced shadow technique as described in the book
    'Real-Time Shadows' Elmar Eisemann et al. http://www.realtimeshadows.com/ and its supplemental 
    code.

    The MultiLightShadowStage::ADVANCED_SHADOW_MAP mode uses these parameters.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Int32           MultiLightShadowParameterAdvancedBase::_sfNumberOfSplits
    The number of split frustums. Default number 1 means no splitting at all.
    Splitting is a global z-paratitioning technique and is named parallel split shadow
    maps (PSSM).
*/

/*! \var bool            MultiLightShadowParameterAdvancedBase::_sfUseLiSP
    Use the Light Space Perspective Shadow Map technique. This is a special warping technique
    that results from the analysis of the perspective error in shadow mapping. This analysis shows
    that the required sampling densities near the viewport are higher than far from it. Warping means
    changing the shadow-map parametrization that maps from (u,v)-coordinates on the world-space
    shadow map plane to (s,t)-coordinates in the actual shadow-map texture.
*/

/*! \var bool            MultiLightShadowParameterAdvancedBase::_sfUseGeometryShader
    Use the geometry shader for shadow map rendering.
*/

/*! \var Int32           MultiLightShadowParameterAdvancedBase::_sfLiSPMode
    LiSP optimization modes: Allowed values are NOPT = 1, REPARAMETRIZED, ARBITRARY, PSEUDO_NEAR
    as defined in class LiSPSMTechnique.
*/

/*! \var bool            MultiLightShadowParameterAdvancedBase::_sfFocusing
    Focusing tries to improve the shadow-map sampling rate by fitting the shadow-map frustum to encompass the view 
    frustum. Using the LiSP or splitting, i.e. global partitioning technique, forces focusing. 
*/

/*! \var bool            MultiLightShadowParameterAdvancedBase::_sfReduceSwimming
    Reduce temporal aliasing or so called shadow swimming. Only takes place if not using LiSP and not using light space
    alignment.
*/

/*! \var bool            MultiLightShadowParameterAdvancedBase::_sfLightSpaceAlignment
    Align the shadow map up vector with the view vector, so that the view frustum
    near plane is found at the bottom of the shadow map and the far plane at the 
    top.
*/

/*! \var bool            MultiLightShadowParameterAdvancedBase::_sfUseMinDepth
    Determine the minimal near distance by pre rendering a depth map into a mipmap texture
    and taking the depth value from it.
*/

/*! \var bool            MultiLightShadowParameterAdvancedBase::_sfUseBestResSelection
    For the PSSM technique. Determine the optimal split index inside of the fragment shader.
*/

/*! \var Real32          MultiLightShadowParameterAdvancedBase::_sfWarpingParameter
    This value allows to increase or decrease the shadow intensity.
*/

/*! \var Real32          MultiLightShadowParameterAdvancedBase::_sfSplitParamterLambda
    Practial split parameter lambda that medias between logarithmic and equidistance splits positions.
    In the range [0,1].
*/

/*! \var Real32          MultiLightShadowParameterAdvancedBase::_sfZNear
    Artificial near plane distance in the range [0,1].
*/

/*! \var Real32          MultiLightShadowParameterAdvancedBase::_sfPseudoNear
    Many application tend to use a generius far plane and a very tight near plane
    to avoid near plane clipping. This creates a tension with shadow mapping since
    perspective error increases as a function of zf/zn. Use a different view frustum
    near plane distance for the computation of the optimal near plane of directional
    lights. In the range [0,1].
*/

/*! \var Real32          MultiLightShadowParameterAdvancedBase::_sfPseudoFar
    Many application tend to use a generius far plane and a very tight near plane
    to avoid near plane clipping. This creates a tension with shadow mapping since
    perspective error increases as a function of zf/zn. Use a different view frustum
    far plane distance for the computation of the optimal far plane of directional
    lights. In the range [0,1].
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<MultiLightShadowParameterAdvanced *, nsOSG>::_type(
    "MultiLightShadowParameterAdvancedPtr", 
    "MultiLightShadowParameterPtr", 
    MultiLightShadowParameterAdvanced::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(MultiLightShadowParameterAdvanced *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           MultiLightShadowParameterAdvanced *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           MultiLightShadowParameterAdvanced *,
                           nsOSG)

DataType &FieldTraits< MultiLightShadowParameterAdvanced *, nsOSG + 1 >::getType(void)
{
    return FieldTraits<MultiLightShadowParameterAdvanced *, nsOSG>::getType();
}


OSG_EXPORT_PTR_MFIELD(ChildPointerMField,
                      MultiLightShadowParameterAdvanced *,
                      UnrecordedRefCountPolicy,
                      nsOSG + 1)


/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void MultiLightShadowParameterAdvancedBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numberOfSplits",
        "The number of split frustums. Default number 1 means no splitting at all.\n"
        "Splitting is a global z-paratitioning technique and is named parallel split shadow\n"
        "maps (PSSM).\n",
        NumberOfSplitsFieldId, NumberOfSplitsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleNumberOfSplits),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleNumberOfSplits));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useLiSP",
        "Use the Light Space Perspective Shadow Map technique. This is a special warping technique\n"
        "that results from the analysis of the perspective error in shadow mapping. This analysis shows\n"
        "that the required sampling densities near the viewport are higher than far from it. Warping means\n"
        "changing the shadow-map parametrization that maps from (u,v)-coordinates on the world-space\n"
        "shadow map plane to (s,t)-coordinates in the actual shadow-map texture.\n",
        UseLiSPFieldId, UseLiSPFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleUseLiSP),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleUseLiSP));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useGeometryShader",
        "Use the geometry shader for shadow map rendering.\n",
        UseGeometryShaderFieldId, UseGeometryShaderFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleUseGeometryShader),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleUseGeometryShader));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "liSPMode",
        "LiSP optimization modes: Allowed values are NOPT = 1, REPARAMETRIZED, ARBITRARY, PSEUDO_NEAR\n"
        "as defined in class LiSPSMTechnique.\n",
        LiSPModeFieldId, LiSPModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleLiSPMode),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleLiSPMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "focusing",
        "Focusing tries to improve the shadow-map sampling rate by fitting the shadow-map frustum to encompass the view \n"
        "frustum. Using the LiSP or splitting, i.e. global partitioning technique, forces focusing. \n",
        FocusingFieldId, FocusingFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleFocusing),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleFocusing));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "reduceSwimming",
        "Reduce temporal aliasing or so called shadow swimming. Only takes place if not using LiSP and not using light space\n"
        "alignment.\n",
        ReduceSwimmingFieldId, ReduceSwimmingFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleReduceSwimming),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleReduceSwimming));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "lightSpaceAlignment",
        "Align the shadow map up vector with the view vector, so that the view frustum\n"
        "near plane is found at the bottom of the shadow map and the far plane at the \n"
        "top.\n",
        LightSpaceAlignmentFieldId, LightSpaceAlignmentFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleLightSpaceAlignment),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleLightSpaceAlignment));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useMinDepth",
        "Determine the minimal near distance by pre rendering a depth map into a mipmap texture\n"
        "and taking the depth value from it.\n",
        UseMinDepthFieldId, UseMinDepthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleUseMinDepth),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleUseMinDepth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useBestResSelection",
        "For the PSSM technique. Determine the optimal split index inside of the fragment shader.\n",
        UseBestResSelectionFieldId, UseBestResSelectionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleUseBestResSelection),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleUseBestResSelection));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "warpingParameter",
        "This value allows to increase or decrease the shadow intensity.\n",
        WarpingParameterFieldId, WarpingParameterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleWarpingParameter),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleWarpingParameter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "splitParamterLambda",
        "Practial split parameter lambda that medias between logarithmic and equidistance splits positions.\n"
        "In the range [0,1].\n",
        SplitParamterLambdaFieldId, SplitParamterLambdaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleSplitParamterLambda),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleSplitParamterLambda));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "zNear",
        "Artificial near plane distance in the range [0,1].\n",
        ZNearFieldId, ZNearFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandleZNear),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandleZNear));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "pseudoNear",
        "Many application tend to use a generius far plane and a very tight near plane\n"
        "to avoid near plane clipping. This creates a tension with shadow mapping since\n"
        "perspective error increases as a function of zf/zn. Use a different view frustum\n"
        "near plane distance for the computation of the optimal near plane of directional\n"
        "lights. In the range [0,1].\n",
        PseudoNearFieldId, PseudoNearFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandlePseudoNear),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandlePseudoNear));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "pseudoFar",
        "Many application tend to use a generius far plane and a very tight near plane\n"
        "to avoid near plane clipping. This creates a tension with shadow mapping since\n"
        "perspective error increases as a function of zf/zn. Use a different view frustum\n"
        "far plane distance for the computation of the optimal far plane of directional\n"
        "lights. In the range [0,1].\n",
        PseudoFarFieldId, PseudoFarFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameterAdvanced::editHandlePseudoFar),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameterAdvanced::getHandlePseudoFar));

    oType.addInitialDesc(pDesc);
}


MultiLightShadowParameterAdvancedBase::TypeObject MultiLightShadowParameterAdvancedBase::_type(
    MultiLightShadowParameterAdvancedBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&MultiLightShadowParameterAdvancedBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&MultiLightShadowParameterAdvanced::initMethod),
    reinterpret_cast<ExitContainerF>(&MultiLightShadowParameterAdvanced::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&MultiLightShadowParameterAdvanced::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"MultiLightShadowParameterAdvanced\"\n"
    "    parent=\"MultiLightShadowParameter\"\n"
    "    library=\"ContribTechniques\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    childFields=\"multi\"\n"
    "    >\n"
    "    Shadow parameters that are used for the advanced shadow technique as described in the book\n"
    "    'Real-Time Shadows' Elmar Eisemann et al. http://www.realtimeshadows.com/ and its supplemental \n"
    "    code.\n"
    "\n"
    "    The MultiLightShadowStage::ADVANCED_SHADOW_MAP mode uses these parameters.\n"
    "\n"
    "    <Field\n"
    "        name=\"numberOfSplits\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The number of split frustums. Default number 1 means no splitting at all.\n"
    "        Splitting is a global z-paratitioning technique and is named parallel split shadow\n"
    "        maps (PSSM).\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"useLiSP\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Use the Light Space Perspective Shadow Map technique. This is a special warping technique\n"
    "        that results from the analysis of the perspective error in shadow mapping. This analysis shows\n"
    "        that the required sampling densities near the viewport are higher than far from it. Warping means\n"
    "        changing the shadow-map parametrization that maps from (u,v)-coordinates on the world-space\n"
    "        shadow map plane to (s,t)-coordinates in the actual shadow-map texture.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"useGeometryShader\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Use the geometry shader for shadow map rendering.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"liSPMode\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"2\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        LiSP optimization modes: Allowed values are NOPT = 1, REPARAMETRIZED, ARBITRARY, PSEUDO_NEAR\n"
    "        as defined in class LiSPSMTechnique.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"focusing\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Focusing tries to improve the shadow-map sampling rate by fitting the shadow-map frustum to encompass the view \n"
    "        frustum. Using the LiSP or splitting, i.e. global partitioning technique, forces focusing. \n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"reduceSwimming\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Reduce temporal aliasing or so called shadow swimming. Only takes place if not using LiSP and not using light space\n"
    "        alignment.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lightSpaceAlignment\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Align the shadow map up vector with the view vector, so that the view frustum\n"
    "        near plane is found at the bottom of the shadow map and the far plane at the \n"
    "        top.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"useMinDepth\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Determine the minimal near distance by pre rendering a depth map into a mipmap texture\n"
    "        and taking the depth value from it.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"useBestResSelection\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        For the PSSM technique. Determine the optimal split index inside of the fragment shader.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"warpingParameter\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        This value allows to increase or decrease the shadow intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"splitParamterLambda\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.5f\"\n"
    "        >\n"
    "        Practial split parameter lambda that medias between logarithmic and equidistance splits positions.\n"
    "        In the range [0,1].\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"zNear\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        Artificial near plane distance in the range [0,1].\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"pseudoNear\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        Many application tend to use a generius far plane and a very tight near plane\n"
    "        to avoid near plane clipping. This creates a tension with shadow mapping since\n"
    "        perspective error increases as a function of zf/zn. Use a different view frustum\n"
    "        near plane distance for the computation of the optimal near plane of directional\n"
    "        lights. In the range [0,1].\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"pseudoFar\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        Many application tend to use a generius far plane and a very tight near plane\n"
    "        to avoid near plane clipping. This creates a tension with shadow mapping since\n"
    "        perspective error increases as a function of zf/zn. Use a different view frustum\n"
    "        far plane distance for the computation of the optimal far plane of directional\n"
    "        lights. In the range [0,1].\n"
    "    </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "Shadow parameters that are used for the advanced shadow technique as described in the book\n"
    "'Real-Time Shadows' Elmar Eisemann et al. http://www.realtimeshadows.com/ and its supplemental \n"
    "code.\n"
    "\n"
    "The MultiLightShadowStage::ADVANCED_SHADOW_MAP mode uses these parameters.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &MultiLightShadowParameterAdvancedBase::getType(void)
{
    return _type;
}

const FieldContainerType &MultiLightShadowParameterAdvancedBase::getType(void) const
{
    return _type;
}

UInt32 MultiLightShadowParameterAdvancedBase::getContainerSize(void) const
{
    return sizeof(MultiLightShadowParameterAdvanced);
}

/*------------------------- decorator get ------------------------------*/


SFInt32 *MultiLightShadowParameterAdvancedBase::editSFNumberOfSplits(void)
{
    editSField(NumberOfSplitsFieldMask);

    return &_sfNumberOfSplits;
}

const SFInt32 *MultiLightShadowParameterAdvancedBase::getSFNumberOfSplits(void) const
{
    return &_sfNumberOfSplits;
}


SFBool *MultiLightShadowParameterAdvancedBase::editSFUseLiSP(void)
{
    editSField(UseLiSPFieldMask);

    return &_sfUseLiSP;
}

const SFBool *MultiLightShadowParameterAdvancedBase::getSFUseLiSP(void) const
{
    return &_sfUseLiSP;
}


SFBool *MultiLightShadowParameterAdvancedBase::editSFUseGeometryShader(void)
{
    editSField(UseGeometryShaderFieldMask);

    return &_sfUseGeometryShader;
}

const SFBool *MultiLightShadowParameterAdvancedBase::getSFUseGeometryShader(void) const
{
    return &_sfUseGeometryShader;
}


SFInt32 *MultiLightShadowParameterAdvancedBase::editSFLiSPMode(void)
{
    editSField(LiSPModeFieldMask);

    return &_sfLiSPMode;
}

const SFInt32 *MultiLightShadowParameterAdvancedBase::getSFLiSPMode(void) const
{
    return &_sfLiSPMode;
}


SFBool *MultiLightShadowParameterAdvancedBase::editSFFocusing(void)
{
    editSField(FocusingFieldMask);

    return &_sfFocusing;
}

const SFBool *MultiLightShadowParameterAdvancedBase::getSFFocusing(void) const
{
    return &_sfFocusing;
}


SFBool *MultiLightShadowParameterAdvancedBase::editSFReduceSwimming(void)
{
    editSField(ReduceSwimmingFieldMask);

    return &_sfReduceSwimming;
}

const SFBool *MultiLightShadowParameterAdvancedBase::getSFReduceSwimming(void) const
{
    return &_sfReduceSwimming;
}


SFBool *MultiLightShadowParameterAdvancedBase::editSFLightSpaceAlignment(void)
{
    editSField(LightSpaceAlignmentFieldMask);

    return &_sfLightSpaceAlignment;
}

const SFBool *MultiLightShadowParameterAdvancedBase::getSFLightSpaceAlignment(void) const
{
    return &_sfLightSpaceAlignment;
}


SFBool *MultiLightShadowParameterAdvancedBase::editSFUseMinDepth(void)
{
    editSField(UseMinDepthFieldMask);

    return &_sfUseMinDepth;
}

const SFBool *MultiLightShadowParameterAdvancedBase::getSFUseMinDepth(void) const
{
    return &_sfUseMinDepth;
}


SFBool *MultiLightShadowParameterAdvancedBase::editSFUseBestResSelection(void)
{
    editSField(UseBestResSelectionFieldMask);

    return &_sfUseBestResSelection;
}

const SFBool *MultiLightShadowParameterAdvancedBase::getSFUseBestResSelection(void) const
{
    return &_sfUseBestResSelection;
}


SFReal32 *MultiLightShadowParameterAdvancedBase::editSFWarpingParameter(void)
{
    editSField(WarpingParameterFieldMask);

    return &_sfWarpingParameter;
}

const SFReal32 *MultiLightShadowParameterAdvancedBase::getSFWarpingParameter(void) const
{
    return &_sfWarpingParameter;
}


SFReal32 *MultiLightShadowParameterAdvancedBase::editSFSplitParamterLambda(void)
{
    editSField(SplitParamterLambdaFieldMask);

    return &_sfSplitParamterLambda;
}

const SFReal32 *MultiLightShadowParameterAdvancedBase::getSFSplitParamterLambda(void) const
{
    return &_sfSplitParamterLambda;
}


SFReal32 *MultiLightShadowParameterAdvancedBase::editSFZNear(void)
{
    editSField(ZNearFieldMask);

    return &_sfZNear;
}

const SFReal32 *MultiLightShadowParameterAdvancedBase::getSFZNear(void) const
{
    return &_sfZNear;
}


SFReal32 *MultiLightShadowParameterAdvancedBase::editSFPseudoNear(void)
{
    editSField(PseudoNearFieldMask);

    return &_sfPseudoNear;
}

const SFReal32 *MultiLightShadowParameterAdvancedBase::getSFPseudoNear(void) const
{
    return &_sfPseudoNear;
}


SFReal32 *MultiLightShadowParameterAdvancedBase::editSFPseudoFar(void)
{
    editSField(PseudoFarFieldMask);

    return &_sfPseudoFar;
}

const SFReal32 *MultiLightShadowParameterAdvancedBase::getSFPseudoFar(void) const
{
    return &_sfPseudoFar;
}






/*------------------------------ access -----------------------------------*/

SizeT MultiLightShadowParameterAdvancedBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (NumberOfSplitsFieldMask & whichField))
    {
        returnValue += _sfNumberOfSplits.getBinSize();
    }
    if(FieldBits::NoField != (UseLiSPFieldMask & whichField))
    {
        returnValue += _sfUseLiSP.getBinSize();
    }
    if(FieldBits::NoField != (UseGeometryShaderFieldMask & whichField))
    {
        returnValue += _sfUseGeometryShader.getBinSize();
    }
    if(FieldBits::NoField != (LiSPModeFieldMask & whichField))
    {
        returnValue += _sfLiSPMode.getBinSize();
    }
    if(FieldBits::NoField != (FocusingFieldMask & whichField))
    {
        returnValue += _sfFocusing.getBinSize();
    }
    if(FieldBits::NoField != (ReduceSwimmingFieldMask & whichField))
    {
        returnValue += _sfReduceSwimming.getBinSize();
    }
    if(FieldBits::NoField != (LightSpaceAlignmentFieldMask & whichField))
    {
        returnValue += _sfLightSpaceAlignment.getBinSize();
    }
    if(FieldBits::NoField != (UseMinDepthFieldMask & whichField))
    {
        returnValue += _sfUseMinDepth.getBinSize();
    }
    if(FieldBits::NoField != (UseBestResSelectionFieldMask & whichField))
    {
        returnValue += _sfUseBestResSelection.getBinSize();
    }
    if(FieldBits::NoField != (WarpingParameterFieldMask & whichField))
    {
        returnValue += _sfWarpingParameter.getBinSize();
    }
    if(FieldBits::NoField != (SplitParamterLambdaFieldMask & whichField))
    {
        returnValue += _sfSplitParamterLambda.getBinSize();
    }
    if(FieldBits::NoField != (ZNearFieldMask & whichField))
    {
        returnValue += _sfZNear.getBinSize();
    }
    if(FieldBits::NoField != (PseudoNearFieldMask & whichField))
    {
        returnValue += _sfPseudoNear.getBinSize();
    }
    if(FieldBits::NoField != (PseudoFarFieldMask & whichField))
    {
        returnValue += _sfPseudoFar.getBinSize();
    }

    return returnValue;
}

void MultiLightShadowParameterAdvancedBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (NumberOfSplitsFieldMask & whichField))
    {
        _sfNumberOfSplits.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseLiSPFieldMask & whichField))
    {
        _sfUseLiSP.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseGeometryShaderFieldMask & whichField))
    {
        _sfUseGeometryShader.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LiSPModeFieldMask & whichField))
    {
        _sfLiSPMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FocusingFieldMask & whichField))
    {
        _sfFocusing.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ReduceSwimmingFieldMask & whichField))
    {
        _sfReduceSwimming.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LightSpaceAlignmentFieldMask & whichField))
    {
        _sfLightSpaceAlignment.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseMinDepthFieldMask & whichField))
    {
        _sfUseMinDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseBestResSelectionFieldMask & whichField))
    {
        _sfUseBestResSelection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WarpingParameterFieldMask & whichField))
    {
        _sfWarpingParameter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SplitParamterLambdaFieldMask & whichField))
    {
        _sfSplitParamterLambda.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ZNearFieldMask & whichField))
    {
        _sfZNear.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PseudoNearFieldMask & whichField))
    {
        _sfPseudoNear.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PseudoFarFieldMask & whichField))
    {
        _sfPseudoFar.copyToBin(pMem);
    }
}

void MultiLightShadowParameterAdvancedBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (NumberOfSplitsFieldMask & whichField))
    {
        editSField(NumberOfSplitsFieldMask);
        _sfNumberOfSplits.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseLiSPFieldMask & whichField))
    {
        editSField(UseLiSPFieldMask);
        _sfUseLiSP.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseGeometryShaderFieldMask & whichField))
    {
        editSField(UseGeometryShaderFieldMask);
        _sfUseGeometryShader.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LiSPModeFieldMask & whichField))
    {
        editSField(LiSPModeFieldMask);
        _sfLiSPMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FocusingFieldMask & whichField))
    {
        editSField(FocusingFieldMask);
        _sfFocusing.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ReduceSwimmingFieldMask & whichField))
    {
        editSField(ReduceSwimmingFieldMask);
        _sfReduceSwimming.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LightSpaceAlignmentFieldMask & whichField))
    {
        editSField(LightSpaceAlignmentFieldMask);
        _sfLightSpaceAlignment.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseMinDepthFieldMask & whichField))
    {
        editSField(UseMinDepthFieldMask);
        _sfUseMinDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseBestResSelectionFieldMask & whichField))
    {
        editSField(UseBestResSelectionFieldMask);
        _sfUseBestResSelection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WarpingParameterFieldMask & whichField))
    {
        editSField(WarpingParameterFieldMask);
        _sfWarpingParameter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SplitParamterLambdaFieldMask & whichField))
    {
        editSField(SplitParamterLambdaFieldMask);
        _sfSplitParamterLambda.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ZNearFieldMask & whichField))
    {
        editSField(ZNearFieldMask);
        _sfZNear.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PseudoNearFieldMask & whichField))
    {
        editSField(PseudoNearFieldMask);
        _sfPseudoNear.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PseudoFarFieldMask & whichField))
    {
        editSField(PseudoFarFieldMask);
        _sfPseudoFar.copyFromBin(pMem);
    }
}

//! create a new instance of the class
MultiLightShadowParameterAdvancedTransitPtr MultiLightShadowParameterAdvancedBase::createLocal(BitVector bFlags)
{
    MultiLightShadowParameterAdvancedTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<MultiLightShadowParameterAdvanced>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
MultiLightShadowParameterAdvancedTransitPtr MultiLightShadowParameterAdvancedBase::createDependent(BitVector bFlags)
{
    MultiLightShadowParameterAdvancedTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<MultiLightShadowParameterAdvanced>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
MultiLightShadowParameterAdvancedTransitPtr MultiLightShadowParameterAdvancedBase::create(void)
{
    MultiLightShadowParameterAdvancedTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<MultiLightShadowParameterAdvanced>(tmpPtr);
    }

    return fc;
}

MultiLightShadowParameterAdvanced *MultiLightShadowParameterAdvancedBase::createEmptyLocal(BitVector bFlags)
{
    MultiLightShadowParameterAdvanced *returnValue;

    newPtr<MultiLightShadowParameterAdvanced>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
MultiLightShadowParameterAdvanced *MultiLightShadowParameterAdvancedBase::createEmpty(void)
{
    MultiLightShadowParameterAdvanced *returnValue;

    newPtr<MultiLightShadowParameterAdvanced>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr MultiLightShadowParameterAdvancedBase::shallowCopyLocal(
    BitVector bFlags) const
{
    MultiLightShadowParameterAdvanced *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightShadowParameterAdvanced *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightShadowParameterAdvancedBase::shallowCopyDependent(
    BitVector bFlags) const
{
    MultiLightShadowParameterAdvanced *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightShadowParameterAdvanced *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightShadowParameterAdvancedBase::shallowCopy(void) const
{
    MultiLightShadowParameterAdvanced *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const MultiLightShadowParameterAdvanced *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

MultiLightShadowParameterAdvancedBase::MultiLightShadowParameterAdvancedBase(void) :
    Inherited(),
    _sfNumberOfSplits         (Int32(1)),
    _sfUseLiSP                (bool(false)),
    _sfUseGeometryShader      (bool(false)),
    _sfLiSPMode               (Int32(2)),
    _sfFocusing               (bool(false)),
    _sfReduceSwimming         (bool(false)),
    _sfLightSpaceAlignment    (bool(false)),
    _sfUseMinDepth            (bool(false)),
    _sfUseBestResSelection    (bool(false)),
    _sfWarpingParameter       (Real32(1.f)),
    _sfSplitParamterLambda    (Real32(0.5f)),
    _sfZNear                  (Real32(0.f)),
    _sfPseudoNear             (Real32(0.f)),
    _sfPseudoFar              (Real32(1.f))
{
}

MultiLightShadowParameterAdvancedBase::MultiLightShadowParameterAdvancedBase(const MultiLightShadowParameterAdvancedBase &source) :
    Inherited(source),
    _sfNumberOfSplits         (source._sfNumberOfSplits         ),
    _sfUseLiSP                (source._sfUseLiSP                ),
    _sfUseGeometryShader      (source._sfUseGeometryShader      ),
    _sfLiSPMode               (source._sfLiSPMode               ),
    _sfFocusing               (source._sfFocusing               ),
    _sfReduceSwimming         (source._sfReduceSwimming         ),
    _sfLightSpaceAlignment    (source._sfLightSpaceAlignment    ),
    _sfUseMinDepth            (source._sfUseMinDepth            ),
    _sfUseBestResSelection    (source._sfUseBestResSelection    ),
    _sfWarpingParameter       (source._sfWarpingParameter       ),
    _sfSplitParamterLambda    (source._sfSplitParamterLambda    ),
    _sfZNear                  (source._sfZNear                  ),
    _sfPseudoNear             (source._sfPseudoNear             ),
    _sfPseudoFar              (source._sfPseudoFar              )
{
}


/*-------------------------- destructors ----------------------------------*/

MultiLightShadowParameterAdvancedBase::~MultiLightShadowParameterAdvancedBase(void)
{
}


GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleNumberOfSplits  (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfNumberOfSplits,
             this->getType().getFieldDesc(NumberOfSplitsFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleNumberOfSplits (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfNumberOfSplits,
             this->getType().getFieldDesc(NumberOfSplitsFieldId),
             this));


    editSField(NumberOfSplitsFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleUseLiSP         (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseLiSP,
             this->getType().getFieldDesc(UseLiSPFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleUseLiSP        (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseLiSP,
             this->getType().getFieldDesc(UseLiSPFieldId),
             this));


    editSField(UseLiSPFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleUseGeometryShader (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseGeometryShader,
             this->getType().getFieldDesc(UseGeometryShaderFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleUseGeometryShader(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseGeometryShader,
             this->getType().getFieldDesc(UseGeometryShaderFieldId),
             this));


    editSField(UseGeometryShaderFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleLiSPMode        (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfLiSPMode,
             this->getType().getFieldDesc(LiSPModeFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleLiSPMode       (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfLiSPMode,
             this->getType().getFieldDesc(LiSPModeFieldId),
             this));


    editSField(LiSPModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleFocusing        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfFocusing,
             this->getType().getFieldDesc(FocusingFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleFocusing       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfFocusing,
             this->getType().getFieldDesc(FocusingFieldId),
             this));


    editSField(FocusingFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleReduceSwimming  (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfReduceSwimming,
             this->getType().getFieldDesc(ReduceSwimmingFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleReduceSwimming (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfReduceSwimming,
             this->getType().getFieldDesc(ReduceSwimmingFieldId),
             this));


    editSField(ReduceSwimmingFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleLightSpaceAlignment (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfLightSpaceAlignment,
             this->getType().getFieldDesc(LightSpaceAlignmentFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleLightSpaceAlignment(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfLightSpaceAlignment,
             this->getType().getFieldDesc(LightSpaceAlignmentFieldId),
             this));


    editSField(LightSpaceAlignmentFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleUseMinDepth     (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseMinDepth,
             this->getType().getFieldDesc(UseMinDepthFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleUseMinDepth    (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseMinDepth,
             this->getType().getFieldDesc(UseMinDepthFieldId),
             this));


    editSField(UseMinDepthFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleUseBestResSelection (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseBestResSelection,
             this->getType().getFieldDesc(UseBestResSelectionFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleUseBestResSelection(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseBestResSelection,
             this->getType().getFieldDesc(UseBestResSelectionFieldId),
             this));


    editSField(UseBestResSelectionFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleWarpingParameter (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfWarpingParameter,
             this->getType().getFieldDesc(WarpingParameterFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleWarpingParameter(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfWarpingParameter,
             this->getType().getFieldDesc(WarpingParameterFieldId),
             this));


    editSField(WarpingParameterFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleSplitParamterLambda (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfSplitParamterLambda,
             this->getType().getFieldDesc(SplitParamterLambdaFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleSplitParamterLambda(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfSplitParamterLambda,
             this->getType().getFieldDesc(SplitParamterLambdaFieldId),
             this));


    editSField(SplitParamterLambdaFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandleZNear           (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfZNear,
             this->getType().getFieldDesc(ZNearFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandleZNear          (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfZNear,
             this->getType().getFieldDesc(ZNearFieldId),
             this));


    editSField(ZNearFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandlePseudoNear      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfPseudoNear,
             this->getType().getFieldDesc(PseudoNearFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandlePseudoNear     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfPseudoNear,
             this->getType().getFieldDesc(PseudoNearFieldId),
             this));


    editSField(PseudoNearFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterAdvancedBase::getHandlePseudoFar       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfPseudoFar,
             this->getType().getFieldDesc(PseudoFarFieldId),
             const_cast<MultiLightShadowParameterAdvancedBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterAdvancedBase::editHandlePseudoFar      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfPseudoFar,
             this->getType().getFieldDesc(PseudoFarFieldId),
             this));


    editSField(PseudoFarFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void MultiLightShadowParameterAdvancedBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    MultiLightShadowParameterAdvanced *pThis = static_cast<MultiLightShadowParameterAdvanced *>(this);

    pThis->execSync(static_cast<MultiLightShadowParameterAdvanced *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *MultiLightShadowParameterAdvancedBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    MultiLightShadowParameterAdvanced *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const MultiLightShadowParameterAdvanced *>(pRefAspect),
                  dynamic_cast<const MultiLightShadowParameterAdvanced *>(this));

    return returnValue;
}
#endif

void MultiLightShadowParameterAdvancedBase::resolveLinks(void)
{
    Inherited::resolveLinks();


}


OSG_END_NAMESPACE
