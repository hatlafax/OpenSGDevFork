/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class MultiLightShadowParameter!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"




#include "OSGMultiLightShadowParameterBase.h"
#include "OSGMultiLightShadowParameter.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::MultiLightShadowParameter
    Shadow parameter that are common for all multi light shadow mapping techniques.
    The MultiLightShadowStage::SIMPLE_SHADOW_MAP use these parameters.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Real32          MultiLightShadowParameterBase::_sfIntensity
    This value allows to increase or decrease the shadow intensity.
*/

/*! \var Real32          MultiLightShadowParameterBase::_sfBias
    This value allow fighting against the shadow acne problem.
*/

/*! \var Int32           MultiLightShadowParameterBase::_sfFilterMode
    The PCF kernel to use. Valid values are defined in the MultiLightShadowStage::FilterMode enumeration.
    If no kernel is to use set to MultiLightShadowStage::PCF_MODE_DISABLED (1).
*/

/*! \var Real32          MultiLightShadowParameterBase::_sfFilterRadius
    The PCF and the Percentage-Closer Soft Shadow (PCSS) technique allows to simulate area lights by generating
    soft shadows. Therefore the light area has to be specified. This is done by the this light radius parameter.
*/

/*! \var bool            MultiLightShadowParameterBase::_sfRandomRotateFilter
    Perform random rotation of the sampling for the PCF technique.
*/

/*! \var bool            MultiLightShadowParameterBase::_sfUseBlockerSearch
    Enable the pre search of blockers by a smaller kernel to allow early out of the current filter function.
*/

/*! \var bool            MultiLightShadowParameterBase::_sfUsePCSS
    Enable the Percentage-Closer Soft Shadow (PCSS) technique.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<MultiLightShadowParameter *, nsOSG>::_type(
    "MultiLightShadowParameterPtr", 
    "FieldContainerPtr", 
    MultiLightShadowParameter::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(MultiLightShadowParameter *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           MultiLightShadowParameter *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           MultiLightShadowParameter *,
                           nsOSG)

DataType &FieldTraits< MultiLightShadowParameter *, nsOSG + 1 >::getType(void)
{
    return FieldTraits<MultiLightShadowParameter *, nsOSG>::getType();
}


OSG_EXPORT_PTR_MFIELD(ChildPointerMField,
                      MultiLightShadowParameter *,
                      UnrecordedRefCountPolicy,
                      nsOSG + 1)


/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void MultiLightShadowParameterBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "intensity",
        "This value allows to increase or decrease the shadow intensity.\n",
        IntensityFieldId, IntensityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameter::editHandleIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameter::getHandleIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "bias",
        "This value allow fighting against the shadow acne problem.\n",
        BiasFieldId, BiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameter::editHandleBias),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameter::getHandleBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "filterMode",
        "The PCF kernel to use. Valid values are defined in the MultiLightShadowStage::FilterMode enumeration.\n"
        "If no kernel is to use set to MultiLightShadowStage::PCF_MODE_DISABLED (1).\n",
        FilterModeFieldId, FilterModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameter::editHandleFilterMode),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameter::getHandleFilterMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "filterRadius",
        "The PCF and the Percentage-Closer Soft Shadow (PCSS) technique allows to simulate area lights by generating\n"
        "soft shadows. Therefore the light area has to be specified. This is done by the this light radius parameter.\n",
        FilterRadiusFieldId, FilterRadiusFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameter::editHandleFilterRadius),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameter::getHandleFilterRadius));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "randomRotateFilter",
        "Perform random rotation of the sampling for the PCF technique.\n",
        RandomRotateFilterFieldId, RandomRotateFilterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameter::editHandleRandomRotateFilter),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameter::getHandleRandomRotateFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useBlockerSearch",
        "Enable the pre search of blockers by a smaller kernel to allow early out of the current filter function.\n",
        UseBlockerSearchFieldId, UseBlockerSearchFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameter::editHandleUseBlockerSearch),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameter::getHandleUseBlockerSearch));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "usePCSS",
        "Enable the Percentage-Closer Soft Shadow (PCSS) technique.\n",
        UsePCSSFieldId, UsePCSSFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowParameter::editHandleUsePCSS),
        static_cast<FieldGetMethodSig >(&MultiLightShadowParameter::getHandleUsePCSS));

    oType.addInitialDesc(pDesc);
}


MultiLightShadowParameterBase::TypeObject MultiLightShadowParameterBase::_type(
    MultiLightShadowParameterBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&MultiLightShadowParameterBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&MultiLightShadowParameter::initMethod),
    reinterpret_cast<ExitContainerF>(&MultiLightShadowParameter::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&MultiLightShadowParameter::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"MultiLightShadowParameter\"\n"
    "    parent=\"FieldContainer\"\n"
    "    library=\"ContribTechniques\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    childFields=\"multi\"\n"
    "    >\n"
    "    Shadow parameter that are common for all multi light shadow mapping techniques.\n"
    "    The MultiLightShadowStage::SIMPLE_SHADOW_MAP use these parameters.\n"
    "\n"
    "    <Field\n"
    "        name=\"intensity\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "    >\n"
    "        This value allows to increase or decrease the shadow intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"bias\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.5f\"\n"
    "    >\n"
    "        This value allow fighting against the shadow acne problem.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "\t name=\"filterMode\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tThe PCF kernel to use. Valid values are defined in the MultiLightShadowStage::FilterMode enumeration.\n"
    "                If no kernel is to use set to MultiLightShadowStage::PCF_MODE_DISABLED (1).\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "\t name=\"filterRadius\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.01f\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tThe PCF and the Percentage-Closer Soft Shadow (PCSS) technique allows to simulate area lights by generating\n"
    "                soft shadows. Therefore the light area has to be specified. This is done by the this light radius parameter.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "\t name=\"randomRotateFilter\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tPerform random rotation of the sampling for the PCF technique.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "\t name=\"useBlockerSearch\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tEnable the pre search of blockers by a smaller kernel to allow early out of the current filter function.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "\t name=\"usePCSS\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tEnable the Percentage-Closer Soft Shadow (PCSS) technique.\n"
    "    </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "Shadow parameter that are common for all multi light shadow mapping techniques.\n"
    "The MultiLightShadowStage::SIMPLE_SHADOW_MAP use these parameters.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &MultiLightShadowParameterBase::getType(void)
{
    return _type;
}

const FieldContainerType &MultiLightShadowParameterBase::getType(void) const
{
    return _type;
}

UInt32 MultiLightShadowParameterBase::getContainerSize(void) const
{
    return sizeof(MultiLightShadowParameter);
}

/*------------------------- decorator get ------------------------------*/


SFReal32 *MultiLightShadowParameterBase::editSFIntensity(void)
{
    editSField(IntensityFieldMask);

    return &_sfIntensity;
}

const SFReal32 *MultiLightShadowParameterBase::getSFIntensity(void) const
{
    return &_sfIntensity;
}


SFReal32 *MultiLightShadowParameterBase::editSFBias(void)
{
    editSField(BiasFieldMask);

    return &_sfBias;
}

const SFReal32 *MultiLightShadowParameterBase::getSFBias(void) const
{
    return &_sfBias;
}


SFInt32 *MultiLightShadowParameterBase::editSFFilterMode(void)
{
    editSField(FilterModeFieldMask);

    return &_sfFilterMode;
}

const SFInt32 *MultiLightShadowParameterBase::getSFFilterMode(void) const
{
    return &_sfFilterMode;
}


SFReal32 *MultiLightShadowParameterBase::editSFFilterRadius(void)
{
    editSField(FilterRadiusFieldMask);

    return &_sfFilterRadius;
}

const SFReal32 *MultiLightShadowParameterBase::getSFFilterRadius(void) const
{
    return &_sfFilterRadius;
}


SFBool *MultiLightShadowParameterBase::editSFRandomRotateFilter(void)
{
    editSField(RandomRotateFilterFieldMask);

    return &_sfRandomRotateFilter;
}

const SFBool *MultiLightShadowParameterBase::getSFRandomRotateFilter(void) const
{
    return &_sfRandomRotateFilter;
}


SFBool *MultiLightShadowParameterBase::editSFUseBlockerSearch(void)
{
    editSField(UseBlockerSearchFieldMask);

    return &_sfUseBlockerSearch;
}

const SFBool *MultiLightShadowParameterBase::getSFUseBlockerSearch(void) const
{
    return &_sfUseBlockerSearch;
}


SFBool *MultiLightShadowParameterBase::editSFUsePCSS(void)
{
    editSField(UsePCSSFieldMask);

    return &_sfUsePCSS;
}

const SFBool *MultiLightShadowParameterBase::getSFUsePCSS(void) const
{
    return &_sfUsePCSS;
}






/*------------------------------ access -----------------------------------*/

SizeT MultiLightShadowParameterBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        returnValue += _sfIntensity.getBinSize();
    }
    if(FieldBits::NoField != (BiasFieldMask & whichField))
    {
        returnValue += _sfBias.getBinSize();
    }
    if(FieldBits::NoField != (FilterModeFieldMask & whichField))
    {
        returnValue += _sfFilterMode.getBinSize();
    }
    if(FieldBits::NoField != (FilterRadiusFieldMask & whichField))
    {
        returnValue += _sfFilterRadius.getBinSize();
    }
    if(FieldBits::NoField != (RandomRotateFilterFieldMask & whichField))
    {
        returnValue += _sfRandomRotateFilter.getBinSize();
    }
    if(FieldBits::NoField != (UseBlockerSearchFieldMask & whichField))
    {
        returnValue += _sfUseBlockerSearch.getBinSize();
    }
    if(FieldBits::NoField != (UsePCSSFieldMask & whichField))
    {
        returnValue += _sfUsePCSS.getBinSize();
    }

    return returnValue;
}

void MultiLightShadowParameterBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        _sfIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BiasFieldMask & whichField))
    {
        _sfBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilterModeFieldMask & whichField))
    {
        _sfFilterMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilterRadiusFieldMask & whichField))
    {
        _sfFilterRadius.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RandomRotateFilterFieldMask & whichField))
    {
        _sfRandomRotateFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseBlockerSearchFieldMask & whichField))
    {
        _sfUseBlockerSearch.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UsePCSSFieldMask & whichField))
    {
        _sfUsePCSS.copyToBin(pMem);
    }
}

void MultiLightShadowParameterBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        editSField(IntensityFieldMask);
        _sfIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BiasFieldMask & whichField))
    {
        editSField(BiasFieldMask);
        _sfBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilterModeFieldMask & whichField))
    {
        editSField(FilterModeFieldMask);
        _sfFilterMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilterRadiusFieldMask & whichField))
    {
        editSField(FilterRadiusFieldMask);
        _sfFilterRadius.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RandomRotateFilterFieldMask & whichField))
    {
        editSField(RandomRotateFilterFieldMask);
        _sfRandomRotateFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseBlockerSearchFieldMask & whichField))
    {
        editSField(UseBlockerSearchFieldMask);
        _sfUseBlockerSearch.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UsePCSSFieldMask & whichField))
    {
        editSField(UsePCSSFieldMask);
        _sfUsePCSS.copyFromBin(pMem);
    }
}

//! create a new instance of the class
MultiLightShadowParameterTransitPtr MultiLightShadowParameterBase::createLocal(BitVector bFlags)
{
    MultiLightShadowParameterTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<MultiLightShadowParameter>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
MultiLightShadowParameterTransitPtr MultiLightShadowParameterBase::createDependent(BitVector bFlags)
{
    MultiLightShadowParameterTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<MultiLightShadowParameter>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
MultiLightShadowParameterTransitPtr MultiLightShadowParameterBase::create(void)
{
    MultiLightShadowParameterTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<MultiLightShadowParameter>(tmpPtr);
    }

    return fc;
}

MultiLightShadowParameter *MultiLightShadowParameterBase::createEmptyLocal(BitVector bFlags)
{
    MultiLightShadowParameter *returnValue;

    newPtr<MultiLightShadowParameter>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
MultiLightShadowParameter *MultiLightShadowParameterBase::createEmpty(void)
{
    MultiLightShadowParameter *returnValue;

    newPtr<MultiLightShadowParameter>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr MultiLightShadowParameterBase::shallowCopyLocal(
    BitVector bFlags) const
{
    MultiLightShadowParameter *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightShadowParameter *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightShadowParameterBase::shallowCopyDependent(
    BitVector bFlags) const
{
    MultiLightShadowParameter *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightShadowParameter *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightShadowParameterBase::shallowCopy(void) const
{
    MultiLightShadowParameter *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const MultiLightShadowParameter *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

MultiLightShadowParameterBase::MultiLightShadowParameterBase(void) :
    Inherited(),
    _sfIntensity              (Real32(1.f)),
    _sfBias                   (Real32(0.5f)),
    _sfFilterMode             (Int32(1)),
    _sfFilterRadius           (Real32(0.01f)),
    _sfRandomRotateFilter     (bool(false)),
    _sfUseBlockerSearch       (bool(false)),
    _sfUsePCSS                (bool(false))
{
}

MultiLightShadowParameterBase::MultiLightShadowParameterBase(const MultiLightShadowParameterBase &source) :
    Inherited(source),
    _sfIntensity              (source._sfIntensity              ),
    _sfBias                   (source._sfBias                   ),
    _sfFilterMode             (source._sfFilterMode             ),
    _sfFilterRadius           (source._sfFilterRadius           ),
    _sfRandomRotateFilter     (source._sfRandomRotateFilter     ),
    _sfUseBlockerSearch       (source._sfUseBlockerSearch       ),
    _sfUsePCSS                (source._sfUsePCSS                )
{
}


/*-------------------------- destructors ----------------------------------*/

MultiLightShadowParameterBase::~MultiLightShadowParameterBase(void)
{
}


GetFieldHandlePtr MultiLightShadowParameterBase::getHandleIntensity       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfIntensity,
             this->getType().getFieldDesc(IntensityFieldId),
             const_cast<MultiLightShadowParameterBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterBase::editHandleIntensity      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfIntensity,
             this->getType().getFieldDesc(IntensityFieldId),
             this));


    editSField(IntensityFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterBase::getHandleBias            (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBias,
             this->getType().getFieldDesc(BiasFieldId),
             const_cast<MultiLightShadowParameterBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterBase::editHandleBias           (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBias,
             this->getType().getFieldDesc(BiasFieldId),
             this));


    editSField(BiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterBase::getHandleFilterMode      (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfFilterMode,
             this->getType().getFieldDesc(FilterModeFieldId),
             const_cast<MultiLightShadowParameterBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterBase::editHandleFilterMode     (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfFilterMode,
             this->getType().getFieldDesc(FilterModeFieldId),
             this));


    editSField(FilterModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterBase::getHandleFilterRadius    (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfFilterRadius,
             this->getType().getFieldDesc(FilterRadiusFieldId),
             const_cast<MultiLightShadowParameterBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterBase::editHandleFilterRadius   (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfFilterRadius,
             this->getType().getFieldDesc(FilterRadiusFieldId),
             this));


    editSField(FilterRadiusFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterBase::getHandleRandomRotateFilter (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfRandomRotateFilter,
             this->getType().getFieldDesc(RandomRotateFilterFieldId),
             const_cast<MultiLightShadowParameterBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterBase::editHandleRandomRotateFilter(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfRandomRotateFilter,
             this->getType().getFieldDesc(RandomRotateFilterFieldId),
             this));


    editSField(RandomRotateFilterFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterBase::getHandleUseBlockerSearch (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseBlockerSearch,
             this->getType().getFieldDesc(UseBlockerSearchFieldId),
             const_cast<MultiLightShadowParameterBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterBase::editHandleUseBlockerSearch(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseBlockerSearch,
             this->getType().getFieldDesc(UseBlockerSearchFieldId),
             this));


    editSField(UseBlockerSearchFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowParameterBase::getHandleUsePCSS         (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUsePCSS,
             this->getType().getFieldDesc(UsePCSSFieldId),
             const_cast<MultiLightShadowParameterBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowParameterBase::editHandleUsePCSS        (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUsePCSS,
             this->getType().getFieldDesc(UsePCSSFieldId),
             this));


    editSField(UsePCSSFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void MultiLightShadowParameterBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    MultiLightShadowParameter *pThis = static_cast<MultiLightShadowParameter *>(this);

    pThis->execSync(static_cast<MultiLightShadowParameter *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *MultiLightShadowParameterBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    MultiLightShadowParameter *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const MultiLightShadowParameter *>(pRefAspect),
                  dynamic_cast<const MultiLightShadowParameter *>(this));

    return returnValue;
}
#endif

void MultiLightShadowParameterBase::resolveLinks(void)
{
    Inherited::resolveLinks();


}


OSG_END_NAMESPACE
