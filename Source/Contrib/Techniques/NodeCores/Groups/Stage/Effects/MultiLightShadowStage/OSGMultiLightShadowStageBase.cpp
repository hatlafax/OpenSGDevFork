/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class MultiLightShadowStage!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"



#include "OSGMultiLightShadowParameter.h" // ShadowParameter Class
#include "OSGNode.h"                    // ExcludeNodes Class
#include "OSGMultiLightChunk.h"         // MultiLightChunk Class

#include "OSGMultiLightShadowStageBase.h"
#include "OSGMultiLightShadowStage.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::MultiLightShadowStage
    This MultiLight shadow stage generates shadows for lights defined by the MultiLight core. For that it generates
    shadow maps for each enabled shadowing light. The details of the shadow map generation and evaluation are
    implemented by specialized technique classes that are derived from a common technique base class. Each technique
    class has an associated technique parameter class that is derived from a common technique parameter base class.
    The stage implementation is quite similar to the ShadowStage class. Alike to the ShadowStage class which 
    implements its details in ShadowTreeHandler derived ShadowMapHandler classes, this class implements its details
    in MultiLightShadowTechniqueBase derived MultiLightShadowTechnique classes. However, these handler classes 
    do not correspond to the ShadowMapHandler classes, because other strategies are implemented for the MultiLight
    based case. Anyone is free to implement the missing  MultiLightShadowTechniques if needed.
    The most important difference to the ShadowStage class is that this stage does not generate a shadow factor map,
    but provides shader code that must be integrated into the final lighing shader. This shader code differs for the various
    technique implementations, but, finally, the lighing shader does only have to call one top level function that does 
    encapsulate all shadow calculation details that must be executed by the shader.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var UInt32          MultiLightShadowStageBase::_sfShadowMode
    
*/

/*! \var bool            MultiLightShadowStageBase::_sfActivate
    If the stage is deactivated it does not perform any action on its own but act as a simple Group core.
*/

/*! \var bool            MultiLightShadowStageBase::_sfShadowOn
    Allow activation/deactivation of the shadow map generation.
*/

/*! \var bool            MultiLightShadowStageBase::_sfUseHWPCF
    Use of shadow sampler to automatically perform hardware percentage closed filtering.
    This is recommended and not all techniques might support this variation point.
*/

/*! \var MultiLightShadowParameter * MultiLightShadowStageBase::_mfShadowParameter
    Shadow parameter for groups of lights. These parameters are provided to the particular fragment shader
    for evaluation.
*/

/*! \var UInt32          MultiLightShadowStageBase::_sfShadowMapWidth
    A hint for the width of the shadow maps. This value might be taken by the technique class
    do determine the width of its shadow maps.
*/

/*! \var UInt32          MultiLightShadowStageBase::_sfShadowMapHeight
    A hint for the height of the shadow maps. This value might be taken by the technique class
    do determine the height of its shadow maps.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfFilterDistributionSize
    The filter (PCF, PCSS) distribution size. This value is in the range of 1 to 4, corresponding to 
    poisson disk sizes of 16, 25, 32 or 64 and box sample sizes of 4x4, 6x6, 8x8 or 10x10. Values
    that are out of range are clamped to the valid range borders.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfSearchDistributionSize
    The blocker search (PCF, PCSS) distribution size. This value is in the range of 0 to 3, corresponding to 
    poisson disk sizes of 9, 16, 25 or 32 and box sample sizes of 2x2, 4x4, 6x6 or 8x8. Values that are out
    of range are clamped to the valid range borders. Additionally, it is also forced that the search size is
    always less than the filter size.
*/

/*! \var bool            MultiLightShadowStageBase::_sfCullFrontFace
    Cull front face on shadow map rendering.
*/

/*! \var Real32          MultiLightShadowStageBase::_sfOffsetBias
    Offset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk. The Polygon-Chunk is only
    installed if the value is not zero.
*/

/*! \var Real32          MultiLightShadowStageBase::_sfOffsetFactor
    Offset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk. The Polygon-Chunk is only
    installed if the value is not zero.
*/

/*! \var Real32          MultiLightShadowStageBase::_sfEnlargeShadowVolumeZ
    Factor that is used to enlarge the shadow volume for directional lights
    in z-direction of the light space.
*/

/*! \var Node *          MultiLightShadowStageBase::_mfExcludeNodes
    Nodes that should not cast shadows at all.
*/

/*! \var bool            MultiLightShadowStageBase::_sfAutoExcludeTransparentNodes
    Usually transparent objects do not cast shadows. Setting this flag to false let the 
    transparent nodes also cast shadows.
*/

/*! \var MultiLightChunk * MultiLightShadowStageBase::_sfMultiLightChunk
    The multi light chunk. This chunk is typically managed either by a ChunkMaterial in a MaterialOverrideGroup
    or by an ClusterShadingStage. In any case, this shadow stage does not manage the multi light chunk but only
    references it. Therefore it is represented by a weak pointer.
*/

/*! \var bool            MultiLightShadowStageBase::_sfAutoSearchMultiLightChunk
    If true the stage searches for a valid MultiLightChunk upwards in its parent tree.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfSamplerCubeArrayTextureUnit
    The texture unit for the samplerCubeArray point light texture. If this value
    is -1 the greatest possible value -1 is used.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfSamplerCubeArrayShadowTextureUnit
    The texture unit for the samplerCubeArrayShadow point light texture. If this value
    is -1 the greatest possible value -1 is used.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfSampler2DArrayTextureUnit
    The texture unit for the sampler2DArray directional light texture. If this value
    is -1 the greatest possible value is used.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfSampler2DArrayShadowTextureUnit
    The texture unit for the sampler2DArrayShadow directional light texture. If this value
    is -1 the greatest possible value is used.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfShadowDataBindingPnt
    The binding point for the shader storage buffer of the shadow data.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfShadowParameterBindingPnt
    The binding point for the uniform buffer of the shadow parameter.
*/

/*! \var Int32           MultiLightShadowStageBase::_sfDistributionBindingPnt
    The binding point for the uniform buffer of the filter and search distributions for
    the PCF and PCSS techniques.
*/

/*! \var bool            MultiLightShadowStageBase::_sfDisableOverride
    
*/

/*! \var bool            MultiLightShadowStageBase::_sfArbTest
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<MultiLightShadowStage *, nsOSG>::_type(
    "MultiLightShadowStagePtr", 
    "StagePtr", 
    MultiLightShadowStage::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(MultiLightShadowStage *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           MultiLightShadowStage *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           MultiLightShadowStage *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void MultiLightShadowStageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "shadowMode",
        "",
        ShadowModeFieldId, ShadowModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleShadowMode),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleShadowMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "activate",
        "If the stage is deactivated it does not perform any action on its own but act as a simple Group core.\n",
        ActivateFieldId, ActivateFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleActivate),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleActivate));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "shadowOn",
        "Allow activation/deactivation of the shadow map generation.\n",
        ShadowOnFieldId, ShadowOnFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleShadowOn),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleShadowOn));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useHWPCF",
        "Use of shadow sampler to automatically perform hardware percentage closed filtering.\n"
        "This is recommended and not all techniques might support this variation point.\n",
        UseHWPCFFieldId, UseHWPCFFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleUseHWPCF),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleUseHWPCF));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecMultiLightShadowParameterPtr::Description(
        MFUnrecMultiLightShadowParameterPtr::getClassType(),
        "shadowParameter",
        "Shadow parameter for groups of lights. These parameters are provided to the particular fragment shader\n"
        "for evaluation.\n",
        ShadowParameterFieldId, ShadowParameterFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleShadowParameter),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleShadowParameter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "shadowMapWidth",
        "A hint for the width of the shadow maps. This value might be taken by the technique class\n"
        "do determine the width of its shadow maps.\n",
        ShadowMapWidthFieldId, ShadowMapWidthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleShadowMapWidth),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleShadowMapWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "shadowMapHeight",
        "A hint for the height of the shadow maps. This value might be taken by the technique class\n"
        "do determine the height of its shadow maps.\n",
        ShadowMapHeightFieldId, ShadowMapHeightFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleShadowMapHeight),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleShadowMapHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "filterDistributionSize",
        "The filter (PCF, PCSS) distribution size. This value is in the range of 1 to 4, corresponding to \n"
        "poisson disk sizes of 16, 25, 32 or 64 and box sample sizes of 4x4, 6x6, 8x8 or 10x10. Values\n"
        "that are out of range are clamped to the valid range borders.\n",
        FilterDistributionSizeFieldId, FilterDistributionSizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleFilterDistributionSize),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleFilterDistributionSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "searchDistributionSize",
        "The blocker search (PCF, PCSS) distribution size. This value is in the range of 0 to 3, corresponding to \n"
        "poisson disk sizes of 9, 16, 25 or 32 and box sample sizes of 2x2, 4x4, 6x6 or 8x8. Values that are out\n"
        "of range are clamped to the valid range borders. Additionally, it is also forced that the search size is\n"
        "always less than the filter size.\n",
        SearchDistributionSizeFieldId, SearchDistributionSizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleSearchDistributionSize),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleSearchDistributionSize));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "cullFrontFace",
        "Cull front face on shadow map rendering.\n",
        CullFrontFaceFieldId, CullFrontFaceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleCullFrontFace),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleCullFrontFace));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offsetBias",
        "Offset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk. The Polygon-Chunk is only\n"
        "installed if the value is not zero.\n",
        OffsetBiasFieldId, OffsetBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleOffsetBias),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleOffsetBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offsetFactor",
        "Offset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk. The Polygon-Chunk is only\n"
        "installed if the value is not zero.\n",
        OffsetFactorFieldId, OffsetFactorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleOffsetFactor),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleOffsetFactor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "enlargeShadowVolumeZ",
        "Factor that is used to enlarge the shadow volume for directional lights\n"
        "in z-direction of the light space.\n",
        EnlargeShadowVolumeZFieldId, EnlargeShadowVolumeZFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleEnlargeShadowVolumeZ),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleEnlargeShadowVolumeZ));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "excludeNodes",
        "Nodes that should not cast shadows at all.\n",
        ExcludeNodesFieldId, ExcludeNodesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleExcludeNodes),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleExcludeNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "autoExcludeTransparentNodes",
        "Usually transparent objects do not cast shadows. Setting this flag to false let the \n"
        "transparent nodes also cast shadows.\n",
        AutoExcludeTransparentNodesFieldId, AutoExcludeTransparentNodesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleAutoExcludeTransparentNodes),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleAutoExcludeTransparentNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFWeakMultiLightChunkPtr::Description(
        SFWeakMultiLightChunkPtr::getClassType(),
        "multiLightChunk",
        "The multi light chunk. This chunk is typically managed either by a ChunkMaterial in a MaterialOverrideGroup\n"
        "or by an ClusterShadingStage. In any case, this shadow stage does not manage the multi light chunk but only\n"
        "references it. Therefore it is represented by a weak pointer.\n",
        MultiLightChunkFieldId, MultiLightChunkFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleMultiLightChunk),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleMultiLightChunk));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "autoSearchMultiLightChunk",
        "If true the stage searches for a valid MultiLightChunk upwards in its parent tree.\n",
        AutoSearchMultiLightChunkFieldId, AutoSearchMultiLightChunkFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleAutoSearchMultiLightChunk),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleAutoSearchMultiLightChunk));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "samplerCubeArrayTextureUnit",
        "The texture unit for the samplerCubeArray point light texture. If this value\n"
        "is -1 the greatest possible value -1 is used.\n",
        SamplerCubeArrayTextureUnitFieldId, SamplerCubeArrayTextureUnitFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleSamplerCubeArrayTextureUnit),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleSamplerCubeArrayTextureUnit));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "samplerCubeArrayShadowTextureUnit",
        "The texture unit for the samplerCubeArrayShadow point light texture. If this value\n"
        "is -1 the greatest possible value -1 is used.\n",
        SamplerCubeArrayShadowTextureUnitFieldId, SamplerCubeArrayShadowTextureUnitFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleSamplerCubeArrayShadowTextureUnit),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleSamplerCubeArrayShadowTextureUnit));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sampler2DArrayTextureUnit",
        "The texture unit for the sampler2DArray directional light texture. If this value\n"
        "is -1 the greatest possible value is used.\n",
        Sampler2DArrayTextureUnitFieldId, Sampler2DArrayTextureUnitFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleSampler2DArrayTextureUnit),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleSampler2DArrayTextureUnit));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sampler2DArrayShadowTextureUnit",
        "The texture unit for the sampler2DArrayShadow directional light texture. If this value\n"
        "is -1 the greatest possible value is used.\n",
        Sampler2DArrayShadowTextureUnitFieldId, Sampler2DArrayShadowTextureUnitFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleSampler2DArrayShadowTextureUnit),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleSampler2DArrayShadowTextureUnit));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "shadowDataBindingPnt",
        "The binding point for the shader storage buffer of the shadow data.\n",
        ShadowDataBindingPntFieldId, ShadowDataBindingPntFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleShadowDataBindingPnt),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleShadowDataBindingPnt));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "shadowParameterBindingPnt",
        "The binding point for the uniform buffer of the shadow parameter.\n",
        ShadowParameterBindingPntFieldId, ShadowParameterBindingPntFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleShadowParameterBindingPnt),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleShadowParameterBindingPnt));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "distributionBindingPnt",
        "The binding point for the uniform buffer of the filter and search distributions for\n"
        "the PCF and PCSS techniques.\n",
        DistributionBindingPntFieldId, DistributionBindingPntFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleDistributionBindingPnt),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleDistributionBindingPnt));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "disableOverride",
        "",
        DisableOverrideFieldId, DisableOverrideFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleDisableOverride),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleDisableOverride));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "arbTest",
        "",
        ArbTestFieldId, ArbTestFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightShadowStage::editHandleArbTest),
        static_cast<FieldGetMethodSig >(&MultiLightShadowStage::getHandleArbTest));

    oType.addInitialDesc(pDesc);
}


MultiLightShadowStageBase::TypeObject MultiLightShadowStageBase::_type(
    MultiLightShadowStageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&MultiLightShadowStageBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&MultiLightShadowStage::initMethod),
    reinterpret_cast<ExitContainerF>(&MultiLightShadowStage::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&MultiLightShadowStage::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"MultiLightShadowStage\"\n"
    "   parent=\"Stage\"\n"
    "   library=\"ContribTechniques\"\n"
    "   pointerfieldtypes=\"both\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   useLocalIncludes=\"false\"\n"
    "   isNodeCore=\"true\"\n"
    "   isBundle=\"false\"\n"
    "   >\n"
    "    This MultiLight shadow stage generates shadows for lights defined by the MultiLight core. For that it generates\n"
    "    shadow maps for each enabled shadowing light. The details of the shadow map generation and evaluation are\n"
    "    implemented by specialized technique classes that are derived from a common technique base class. Each technique\n"
    "    class has an associated technique parameter class that is derived from a common technique parameter base class.\n"
    "    The stage implementation is quite similar to the ShadowStage class. Alike to the ShadowStage class which \n"
    "    implements its details in ShadowTreeHandler derived ShadowMapHandler classes, this class implements its details\n"
    "    in MultiLightShadowTechniqueBase derived MultiLightShadowTechnique classes. However, these handler classes \n"
    "    do not correspond to the ShadowMapHandler classes, because other strategies are implemented for the MultiLight\n"
    "    based case. Anyone is free to implement the missing  MultiLightShadowTechniques if needed.\n"
    "    The most important difference to the ShadowStage class is that this stage does not generate a shadow factor map,\n"
    "    but provides shader code that must be integrated into the final lighing shader. This shader code differs for the various\n"
    "    technique implementations, but, finally, the lighing shader does only have to call one top level function that does \n"
    "    encapsulate all shadow calculation details that must be executed by the shader.\n"
    "\n"
    "  <Field\n"
    "\t name=\"shadowMode\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"activate\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        If the stage is deactivated it does not perform any action on its own but act as a simple Group core.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowOn\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        Allow activation/deactivation of the shadow map generation.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"useHWPCF\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        Use of shadow sampler to automatically perform hardware percentage closed filtering.\n"
    "        This is recommended and not all techniques might support this variation point.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowParameter\"\n"
    "\t type=\"MultiLightShadowParameterPtr\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"protected\"\n"
    "\t >\n"
    "        Shadow parameter for groups of lights. These parameters are provided to the particular fragment shader\n"
    "        for evaluation.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"shadowMapWidth\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1024\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        A hint for the width of the shadow maps. This value might be taken by the technique class\n"
    "        do determine the width of its shadow maps.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowMapHeight\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"1024\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        A hint for the height of the shadow maps. This value might be taken by the technique class\n"
    "        do determine the height of its shadow maps.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"filterDistributionSize\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"3\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The filter (PCF, PCSS) distribution size. This value is in the range of 1 to 4, corresponding to \n"
    "        poisson disk sizes of 16, 25, 32 or 64 and box sample sizes of 4x4, 6x6, 8x8 or 10x10. Values\n"
    "        that are out of range are clamped to the valid range borders.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"searchDistributionSize\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"2\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The blocker search (PCF, PCSS) distribution size. This value is in the range of 0 to 3, corresponding to \n"
    "        poisson disk sizes of 9, 16, 25 or 32 and box sample sizes of 2x2, 4x4, 6x6 or 8x8. Values that are out\n"
    "        of range are clamped to the valid range borders. Additionally, it is also forced that the search size is\n"
    "        always less than the filter size.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"cullFrontFace\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        Cull front face on shadow map rendering.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"offsetBias\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.f\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tOffset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk. The Polygon-Chunk is only\n"
    "                installed if the value is not zero.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"offsetFactor\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.f\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tOffset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk. The Polygon-Chunk is only\n"
    "                installed if the value is not zero.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"enlargeShadowVolumeZ\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.01f\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tFactor that is used to enlarge the shadow volume for directional lights\n"
    "                in z-direction of the light space.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"excludeNodes\"\n"
    "\t type=\"NodePtr\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        Nodes that should not cast shadows at all.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"autoExcludeTransparentNodes\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tUsually transparent objects do not cast shadows. Setting this flag to false let the \n"
    "\ttransparent nodes also cast shadows.\n"
    "  </Field>\n"
    "  <Field\n"
    "        name=\"multiLightChunk\"\n"
    "        type=\"MultiLightChunk\"\n"
    "        category=\"weakpointer\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "     >\n"
    "        The multi light chunk. This chunk is typically managed either by a ChunkMaterial in a MaterialOverrideGroup\n"
    "        or by an ClusterShadingStage. In any case, this shadow stage does not manage the multi light chunk but only\n"
    "        references it. Therefore it is represented by a weak pointer.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"autoSearchMultiLightChunk\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        If true the stage searches for a valid MultiLightChunk upwards in its parent tree.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"samplerCubeArrayTextureUnit\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The texture unit for the samplerCubeArray point light texture. If this value\n"
    "        is -1 the greatest possible value -1 is used.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"samplerCubeArrayShadowTextureUnit\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The texture unit for the samplerCubeArrayShadow point light texture. If this value\n"
    "        is -1 the greatest possible value -1 is used.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"sampler2DArrayTextureUnit\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The texture unit for the sampler2DArray directional light texture. If this value\n"
    "        is -1 the greatest possible value is used.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"sampler2DArrayShadowTextureUnit\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The texture unit for the sampler2DArrayShadow directional light texture. If this value\n"
    "        is -1 the greatest possible value is used.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowDataBindingPnt\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The binding point for the shader storage buffer of the shadow data.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowParameterBindingPnt\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The binding point for the uniform buffer of the shadow parameter.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "\t name=\"distributionBindingPnt\"\n"
    "\t type=\"Int32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"-1\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The binding point for the uniform buffer of the filter and search distributions for\n"
    "        the PCF and PCSS techniques.\n"
    "  </Field>\n"
    "  \n"
    "  <Field\n"
    "\t name=\"disableOverride\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "\n"
    "    <Field\n"
    "\t name=\"arbTest\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "This MultiLight shadow stage generates shadows for lights defined by the MultiLight core. For that it generates\n"
    "shadow maps for each enabled shadowing light. The details of the shadow map generation and evaluation are\n"
    "implemented by specialized technique classes that are derived from a common technique base class. Each technique\n"
    "class has an associated technique parameter class that is derived from a common technique parameter base class.\n"
    "The stage implementation is quite similar to the ShadowStage class. Alike to the ShadowStage class which \n"
    "implements its details in ShadowTreeHandler derived ShadowMapHandler classes, this class implements its details\n"
    "in MultiLightShadowTechniqueBase derived MultiLightShadowTechnique classes. However, these handler classes \n"
    "do not correspond to the ShadowMapHandler classes, because other strategies are implemented for the MultiLight\n"
    "based case. Anyone is free to implement the missing  MultiLightShadowTechniques if needed.\n"
    "The most important difference to the ShadowStage class is that this stage does not generate a shadow factor map,\n"
    "but provides shader code that must be integrated into the final lighing shader. This shader code differs for the various\n"
    "technique implementations, but, finally, the lighing shader does only have to call one top level function that does \n"
    "encapsulate all shadow calculation details that must be executed by the shader.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &MultiLightShadowStageBase::getType(void)
{
    return _type;
}

const FieldContainerType &MultiLightShadowStageBase::getType(void) const
{
    return _type;
}

UInt32 MultiLightShadowStageBase::getContainerSize(void) const
{
    return sizeof(MultiLightShadowStage);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *MultiLightShadowStageBase::editSFShadowMode(void)
{
    editSField(ShadowModeFieldMask);

    return &_sfShadowMode;
}

const SFUInt32 *MultiLightShadowStageBase::getSFShadowMode(void) const
{
    return &_sfShadowMode;
}


SFBool *MultiLightShadowStageBase::editSFActivate(void)
{
    editSField(ActivateFieldMask);

    return &_sfActivate;
}

const SFBool *MultiLightShadowStageBase::getSFActivate(void) const
{
    return &_sfActivate;
}


SFBool *MultiLightShadowStageBase::editSFShadowOn(void)
{
    editSField(ShadowOnFieldMask);

    return &_sfShadowOn;
}

const SFBool *MultiLightShadowStageBase::getSFShadowOn(void) const
{
    return &_sfShadowOn;
}


SFBool *MultiLightShadowStageBase::editSFUseHWPCF(void)
{
    editSField(UseHWPCFFieldMask);

    return &_sfUseHWPCF;
}

const SFBool *MultiLightShadowStageBase::getSFUseHWPCF(void) const
{
    return &_sfUseHWPCF;
}


//! Get the MultiLightShadowStage::_mfShadowParameter field.
const MFUnrecMultiLightShadowParameterPtr *MultiLightShadowStageBase::getMFShadowParameter(void) const
{
    return &_mfShadowParameter;
}

MFUnrecMultiLightShadowParameterPtr *MultiLightShadowStageBase::editMFShadowParameter(void)
{
    editMField(ShadowParameterFieldMask, _mfShadowParameter);

    return &_mfShadowParameter;
}
MultiLightShadowParameter * MultiLightShadowStageBase::getShadowParameter(const UInt32 index) const
{
    return _mfShadowParameter[index];
}

SFUInt32 *MultiLightShadowStageBase::editSFShadowMapWidth(void)
{
    editSField(ShadowMapWidthFieldMask);

    return &_sfShadowMapWidth;
}

const SFUInt32 *MultiLightShadowStageBase::getSFShadowMapWidth(void) const
{
    return &_sfShadowMapWidth;
}


SFUInt32 *MultiLightShadowStageBase::editSFShadowMapHeight(void)
{
    editSField(ShadowMapHeightFieldMask);

    return &_sfShadowMapHeight;
}

const SFUInt32 *MultiLightShadowStageBase::getSFShadowMapHeight(void) const
{
    return &_sfShadowMapHeight;
}


SFInt32 *MultiLightShadowStageBase::editSFFilterDistributionSize(void)
{
    editSField(FilterDistributionSizeFieldMask);

    return &_sfFilterDistributionSize;
}

const SFInt32 *MultiLightShadowStageBase::getSFFilterDistributionSize(void) const
{
    return &_sfFilterDistributionSize;
}


SFInt32 *MultiLightShadowStageBase::editSFSearchDistributionSize(void)
{
    editSField(SearchDistributionSizeFieldMask);

    return &_sfSearchDistributionSize;
}

const SFInt32 *MultiLightShadowStageBase::getSFSearchDistributionSize(void) const
{
    return &_sfSearchDistributionSize;
}


SFBool *MultiLightShadowStageBase::editSFCullFrontFace(void)
{
    editSField(CullFrontFaceFieldMask);

    return &_sfCullFrontFace;
}

const SFBool *MultiLightShadowStageBase::getSFCullFrontFace(void) const
{
    return &_sfCullFrontFace;
}


SFReal32 *MultiLightShadowStageBase::editSFOffsetBias(void)
{
    editSField(OffsetBiasFieldMask);

    return &_sfOffsetBias;
}

const SFReal32 *MultiLightShadowStageBase::getSFOffsetBias(void) const
{
    return &_sfOffsetBias;
}


SFReal32 *MultiLightShadowStageBase::editSFOffsetFactor(void)
{
    editSField(OffsetFactorFieldMask);

    return &_sfOffsetFactor;
}

const SFReal32 *MultiLightShadowStageBase::getSFOffsetFactor(void) const
{
    return &_sfOffsetFactor;
}


SFReal32 *MultiLightShadowStageBase::editSFEnlargeShadowVolumeZ(void)
{
    editSField(EnlargeShadowVolumeZFieldMask);

    return &_sfEnlargeShadowVolumeZ;
}

const SFReal32 *MultiLightShadowStageBase::getSFEnlargeShadowVolumeZ(void) const
{
    return &_sfEnlargeShadowVolumeZ;
}


//! Get the MultiLightShadowStage::_mfExcludeNodes field.
const MFUnrecNodePtr *MultiLightShadowStageBase::getMFExcludeNodes(void) const
{
    return &_mfExcludeNodes;
}

MFUnrecNodePtr      *MultiLightShadowStageBase::editMFExcludeNodes   (void)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    return &_mfExcludeNodes;
}
Node * MultiLightShadowStageBase::getExcludeNodes(const UInt32 index) const
{
    return _mfExcludeNodes[index];
}

SFBool *MultiLightShadowStageBase::editSFAutoExcludeTransparentNodes(void)
{
    editSField(AutoExcludeTransparentNodesFieldMask);

    return &_sfAutoExcludeTransparentNodes;
}

const SFBool *MultiLightShadowStageBase::getSFAutoExcludeTransparentNodes(void) const
{
    return &_sfAutoExcludeTransparentNodes;
}


//! Get the MultiLightShadowStage::_sfMultiLightChunk field.
const SFWeakMultiLightChunkPtr *MultiLightShadowStageBase::getSFMultiLightChunk(void) const
{
    return &_sfMultiLightChunk;
}

SFWeakMultiLightChunkPtr *MultiLightShadowStageBase::editSFMultiLightChunk(void)
{
    editSField(MultiLightChunkFieldMask);

    return &_sfMultiLightChunk;
}

//! Get the value of the MultiLightShadowStage::_sfMultiLightChunk field.
MultiLightChunk * MultiLightShadowStageBase::getMultiLightChunk(void) const
{
    return _sfMultiLightChunk.getValue();
}

//! Set the value of the MultiLightShadowStage::_sfMultiLightChunk field.
void MultiLightShadowStageBase::setMultiLightChunk(MultiLightChunk * const value)
{
    editSField(MultiLightChunkFieldMask);

    _sfMultiLightChunk.setValue(value);
}


SFBool *MultiLightShadowStageBase::editSFAutoSearchMultiLightChunk(void)
{
    editSField(AutoSearchMultiLightChunkFieldMask);

    return &_sfAutoSearchMultiLightChunk;
}

const SFBool *MultiLightShadowStageBase::getSFAutoSearchMultiLightChunk(void) const
{
    return &_sfAutoSearchMultiLightChunk;
}


SFInt32 *MultiLightShadowStageBase::editSFSamplerCubeArrayTextureUnit(void)
{
    editSField(SamplerCubeArrayTextureUnitFieldMask);

    return &_sfSamplerCubeArrayTextureUnit;
}

const SFInt32 *MultiLightShadowStageBase::getSFSamplerCubeArrayTextureUnit(void) const
{
    return &_sfSamplerCubeArrayTextureUnit;
}


SFInt32 *MultiLightShadowStageBase::editSFSamplerCubeArrayShadowTextureUnit(void)
{
    editSField(SamplerCubeArrayShadowTextureUnitFieldMask);

    return &_sfSamplerCubeArrayShadowTextureUnit;
}

const SFInt32 *MultiLightShadowStageBase::getSFSamplerCubeArrayShadowTextureUnit(void) const
{
    return &_sfSamplerCubeArrayShadowTextureUnit;
}


SFInt32 *MultiLightShadowStageBase::editSFSampler2DArrayTextureUnit(void)
{
    editSField(Sampler2DArrayTextureUnitFieldMask);

    return &_sfSampler2DArrayTextureUnit;
}

const SFInt32 *MultiLightShadowStageBase::getSFSampler2DArrayTextureUnit(void) const
{
    return &_sfSampler2DArrayTextureUnit;
}


SFInt32 *MultiLightShadowStageBase::editSFSampler2DArrayShadowTextureUnit(void)
{
    editSField(Sampler2DArrayShadowTextureUnitFieldMask);

    return &_sfSampler2DArrayShadowTextureUnit;
}

const SFInt32 *MultiLightShadowStageBase::getSFSampler2DArrayShadowTextureUnit(void) const
{
    return &_sfSampler2DArrayShadowTextureUnit;
}


SFInt32 *MultiLightShadowStageBase::editSFShadowDataBindingPnt(void)
{
    editSField(ShadowDataBindingPntFieldMask);

    return &_sfShadowDataBindingPnt;
}

const SFInt32 *MultiLightShadowStageBase::getSFShadowDataBindingPnt(void) const
{
    return &_sfShadowDataBindingPnt;
}


SFInt32 *MultiLightShadowStageBase::editSFShadowParameterBindingPnt(void)
{
    editSField(ShadowParameterBindingPntFieldMask);

    return &_sfShadowParameterBindingPnt;
}

const SFInt32 *MultiLightShadowStageBase::getSFShadowParameterBindingPnt(void) const
{
    return &_sfShadowParameterBindingPnt;
}


SFInt32 *MultiLightShadowStageBase::editSFDistributionBindingPnt(void)
{
    editSField(DistributionBindingPntFieldMask);

    return &_sfDistributionBindingPnt;
}

const SFInt32 *MultiLightShadowStageBase::getSFDistributionBindingPnt(void) const
{
    return &_sfDistributionBindingPnt;
}


SFBool *MultiLightShadowStageBase::editSFDisableOverride(void)
{
    editSField(DisableOverrideFieldMask);

    return &_sfDisableOverride;
}

const SFBool *MultiLightShadowStageBase::getSFDisableOverride(void) const
{
    return &_sfDisableOverride;
}


SFBool *MultiLightShadowStageBase::editSFArbTest(void)
{
    editSField(ArbTestFieldMask);

    return &_sfArbTest;
}

const SFBool *MultiLightShadowStageBase::getSFArbTest(void) const
{
    return &_sfArbTest;
}




void MultiLightShadowStageBase::pushToShadowParameter(MultiLightShadowParameter * const value)
{
    editMField(ShadowParameterFieldMask, _mfShadowParameter);

    _mfShadowParameter.push_back(value);
}

void MultiLightShadowStageBase::assignShadowParameter(const MFUnrecMultiLightShadowParameterPtr &value)
{
    MFUnrecMultiLightShadowParameterPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecMultiLightShadowParameterPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<MultiLightShadowStage *>(this)->clearShadowParameter();

    while(elemIt != elemEnd)
    {
        this->pushToShadowParameter(*elemIt);

        ++elemIt;
    }
}

void MultiLightShadowStageBase::removeFromShadowParameter(UInt32 uiIndex)
{
    if(uiIndex < _mfShadowParameter.size())
    {
        editMField(ShadowParameterFieldMask, _mfShadowParameter);

        _mfShadowParameter.erase(uiIndex);
    }
}

void MultiLightShadowStageBase::removeObjFromShadowParameter(MultiLightShadowParameter * const value)
{
    Int32 iElemIdx = _mfShadowParameter.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ShadowParameterFieldMask, _mfShadowParameter);

        _mfShadowParameter.erase(iElemIdx);
    }
}
void MultiLightShadowStageBase::clearShadowParameter(void)
{
    editMField(ShadowParameterFieldMask, _mfShadowParameter);


    _mfShadowParameter.clear();
}

void MultiLightShadowStageBase::pushToExcludeNodes(Node * const value)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    _mfExcludeNodes.push_back(value);
}

void MultiLightShadowStageBase::assignExcludeNodes(const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<MultiLightShadowStage *>(this)->clearExcludeNodes();

    while(elemIt != elemEnd)
    {
        this->pushToExcludeNodes(*elemIt);

        ++elemIt;
    }
}

void MultiLightShadowStageBase::removeFromExcludeNodes(UInt32 uiIndex)
{
    if(uiIndex < _mfExcludeNodes.size())
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

        _mfExcludeNodes.erase(uiIndex);
    }
}

void MultiLightShadowStageBase::removeObjFromExcludeNodes(Node * const value)
{
    Int32 iElemIdx = _mfExcludeNodes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

        _mfExcludeNodes.erase(iElemIdx);
    }
}
void MultiLightShadowStageBase::clearExcludeNodes(void)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);


    _mfExcludeNodes.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT MultiLightShadowStageBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        returnValue += _sfShadowMode.getBinSize();
    }
    if(FieldBits::NoField != (ActivateFieldMask & whichField))
    {
        returnValue += _sfActivate.getBinSize();
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        returnValue += _sfShadowOn.getBinSize();
    }
    if(FieldBits::NoField != (UseHWPCFFieldMask & whichField))
    {
        returnValue += _sfUseHWPCF.getBinSize();
    }
    if(FieldBits::NoField != (ShadowParameterFieldMask & whichField))
    {
        returnValue += _mfShadowParameter.getBinSize();
    }
    if(FieldBits::NoField != (ShadowMapWidthFieldMask & whichField))
    {
        returnValue += _sfShadowMapWidth.getBinSize();
    }
    if(FieldBits::NoField != (ShadowMapHeightFieldMask & whichField))
    {
        returnValue += _sfShadowMapHeight.getBinSize();
    }
    if(FieldBits::NoField != (FilterDistributionSizeFieldMask & whichField))
    {
        returnValue += _sfFilterDistributionSize.getBinSize();
    }
    if(FieldBits::NoField != (SearchDistributionSizeFieldMask & whichField))
    {
        returnValue += _sfSearchDistributionSize.getBinSize();
    }
    if(FieldBits::NoField != (CullFrontFaceFieldMask & whichField))
    {
        returnValue += _sfCullFrontFace.getBinSize();
    }
    if(FieldBits::NoField != (OffsetBiasFieldMask & whichField))
    {
        returnValue += _sfOffsetBias.getBinSize();
    }
    if(FieldBits::NoField != (OffsetFactorFieldMask & whichField))
    {
        returnValue += _sfOffsetFactor.getBinSize();
    }
    if(FieldBits::NoField != (EnlargeShadowVolumeZFieldMask & whichField))
    {
        returnValue += _sfEnlargeShadowVolumeZ.getBinSize();
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        returnValue += _mfExcludeNodes.getBinSize();
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        returnValue += _sfAutoExcludeTransparentNodes.getBinSize();
    }
    if(FieldBits::NoField != (MultiLightChunkFieldMask & whichField))
    {
        returnValue += _sfMultiLightChunk.getBinSize();
    }
    if(FieldBits::NoField != (AutoSearchMultiLightChunkFieldMask & whichField))
    {
        returnValue += _sfAutoSearchMultiLightChunk.getBinSize();
    }
    if(FieldBits::NoField != (SamplerCubeArrayTextureUnitFieldMask & whichField))
    {
        returnValue += _sfSamplerCubeArrayTextureUnit.getBinSize();
    }
    if(FieldBits::NoField != (SamplerCubeArrayShadowTextureUnitFieldMask & whichField))
    {
        returnValue += _sfSamplerCubeArrayShadowTextureUnit.getBinSize();
    }
    if(FieldBits::NoField != (Sampler2DArrayTextureUnitFieldMask & whichField))
    {
        returnValue += _sfSampler2DArrayTextureUnit.getBinSize();
    }
    if(FieldBits::NoField != (Sampler2DArrayShadowTextureUnitFieldMask & whichField))
    {
        returnValue += _sfSampler2DArrayShadowTextureUnit.getBinSize();
    }
    if(FieldBits::NoField != (ShadowDataBindingPntFieldMask & whichField))
    {
        returnValue += _sfShadowDataBindingPnt.getBinSize();
    }
    if(FieldBits::NoField != (ShadowParameterBindingPntFieldMask & whichField))
    {
        returnValue += _sfShadowParameterBindingPnt.getBinSize();
    }
    if(FieldBits::NoField != (DistributionBindingPntFieldMask & whichField))
    {
        returnValue += _sfDistributionBindingPnt.getBinSize();
    }
    if(FieldBits::NoField != (DisableOverrideFieldMask & whichField))
    {
        returnValue += _sfDisableOverride.getBinSize();
    }
    if(FieldBits::NoField != (ArbTestFieldMask & whichField))
    {
        returnValue += _sfArbTest.getBinSize();
    }

    return returnValue;
}

void MultiLightShadowStageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        _sfShadowMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ActivateFieldMask & whichField))
    {
        _sfActivate.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        _sfShadowOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseHWPCFFieldMask & whichField))
    {
        _sfUseHWPCF.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowParameterFieldMask & whichField))
    {
        _mfShadowParameter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowMapWidthFieldMask & whichField))
    {
        _sfShadowMapWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowMapHeightFieldMask & whichField))
    {
        _sfShadowMapHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilterDistributionSizeFieldMask & whichField))
    {
        _sfFilterDistributionSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SearchDistributionSizeFieldMask & whichField))
    {
        _sfSearchDistributionSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CullFrontFaceFieldMask & whichField))
    {
        _sfCullFrontFace.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffsetBiasFieldMask & whichField))
    {
        _sfOffsetBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFactorFieldMask & whichField))
    {
        _sfOffsetFactor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnlargeShadowVolumeZFieldMask & whichField))
    {
        _sfEnlargeShadowVolumeZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        _mfExcludeNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        _sfAutoExcludeTransparentNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MultiLightChunkFieldMask & whichField))
    {
        _sfMultiLightChunk.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoSearchMultiLightChunkFieldMask & whichField))
    {
        _sfAutoSearchMultiLightChunk.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SamplerCubeArrayTextureUnitFieldMask & whichField))
    {
        _sfSamplerCubeArrayTextureUnit.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SamplerCubeArrayShadowTextureUnitFieldMask & whichField))
    {
        _sfSamplerCubeArrayShadowTextureUnit.copyToBin(pMem);
    }
    if(FieldBits::NoField != (Sampler2DArrayTextureUnitFieldMask & whichField))
    {
        _sfSampler2DArrayTextureUnit.copyToBin(pMem);
    }
    if(FieldBits::NoField != (Sampler2DArrayShadowTextureUnitFieldMask & whichField))
    {
        _sfSampler2DArrayShadowTextureUnit.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowDataBindingPntFieldMask & whichField))
    {
        _sfShadowDataBindingPnt.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowParameterBindingPntFieldMask & whichField))
    {
        _sfShadowParameterBindingPnt.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DistributionBindingPntFieldMask & whichField))
    {
        _sfDistributionBindingPnt.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DisableOverrideFieldMask & whichField))
    {
        _sfDisableOverride.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ArbTestFieldMask & whichField))
    {
        _sfArbTest.copyToBin(pMem);
    }
}

void MultiLightShadowStageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        editSField(ShadowModeFieldMask);
        _sfShadowMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ActivateFieldMask & whichField))
    {
        editSField(ActivateFieldMask);
        _sfActivate.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        editSField(ShadowOnFieldMask);
        _sfShadowOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseHWPCFFieldMask & whichField))
    {
        editSField(UseHWPCFFieldMask);
        _sfUseHWPCF.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowParameterFieldMask & whichField))
    {
        editMField(ShadowParameterFieldMask, _mfShadowParameter);
        _mfShadowParameter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowMapWidthFieldMask & whichField))
    {
        editSField(ShadowMapWidthFieldMask);
        _sfShadowMapWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowMapHeightFieldMask & whichField))
    {
        editSField(ShadowMapHeightFieldMask);
        _sfShadowMapHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilterDistributionSizeFieldMask & whichField))
    {
        editSField(FilterDistributionSizeFieldMask);
        _sfFilterDistributionSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SearchDistributionSizeFieldMask & whichField))
    {
        editSField(SearchDistributionSizeFieldMask);
        _sfSearchDistributionSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CullFrontFaceFieldMask & whichField))
    {
        editSField(CullFrontFaceFieldMask);
        _sfCullFrontFace.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffsetBiasFieldMask & whichField))
    {
        editSField(OffsetBiasFieldMask);
        _sfOffsetBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFactorFieldMask & whichField))
    {
        editSField(OffsetFactorFieldMask);
        _sfOffsetFactor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnlargeShadowVolumeZFieldMask & whichField))
    {
        editSField(EnlargeShadowVolumeZFieldMask);
        _sfEnlargeShadowVolumeZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);
        _mfExcludeNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        editSField(AutoExcludeTransparentNodesFieldMask);
        _sfAutoExcludeTransparentNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MultiLightChunkFieldMask & whichField))
    {
        editSField(MultiLightChunkFieldMask);
        _sfMultiLightChunk.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoSearchMultiLightChunkFieldMask & whichField))
    {
        editSField(AutoSearchMultiLightChunkFieldMask);
        _sfAutoSearchMultiLightChunk.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SamplerCubeArrayTextureUnitFieldMask & whichField))
    {
        editSField(SamplerCubeArrayTextureUnitFieldMask);
        _sfSamplerCubeArrayTextureUnit.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SamplerCubeArrayShadowTextureUnitFieldMask & whichField))
    {
        editSField(SamplerCubeArrayShadowTextureUnitFieldMask);
        _sfSamplerCubeArrayShadowTextureUnit.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (Sampler2DArrayTextureUnitFieldMask & whichField))
    {
        editSField(Sampler2DArrayTextureUnitFieldMask);
        _sfSampler2DArrayTextureUnit.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (Sampler2DArrayShadowTextureUnitFieldMask & whichField))
    {
        editSField(Sampler2DArrayShadowTextureUnitFieldMask);
        _sfSampler2DArrayShadowTextureUnit.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowDataBindingPntFieldMask & whichField))
    {
        editSField(ShadowDataBindingPntFieldMask);
        _sfShadowDataBindingPnt.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowParameterBindingPntFieldMask & whichField))
    {
        editSField(ShadowParameterBindingPntFieldMask);
        _sfShadowParameterBindingPnt.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DistributionBindingPntFieldMask & whichField))
    {
        editSField(DistributionBindingPntFieldMask);
        _sfDistributionBindingPnt.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DisableOverrideFieldMask & whichField))
    {
        editSField(DisableOverrideFieldMask);
        _sfDisableOverride.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ArbTestFieldMask & whichField))
    {
        editSField(ArbTestFieldMask);
        _sfArbTest.copyFromBin(pMem);
    }
}

//! create a new instance of the class
MultiLightShadowStageTransitPtr MultiLightShadowStageBase::createLocal(BitVector bFlags)
{
    MultiLightShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<MultiLightShadowStage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
MultiLightShadowStageTransitPtr MultiLightShadowStageBase::createDependent(BitVector bFlags)
{
    MultiLightShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<MultiLightShadowStage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
MultiLightShadowStageTransitPtr MultiLightShadowStageBase::create(void)
{
    MultiLightShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<MultiLightShadowStage>(tmpPtr);
    }

    return fc;
}

MultiLightShadowStage *MultiLightShadowStageBase::createEmptyLocal(BitVector bFlags)
{
    MultiLightShadowStage *returnValue;

    newPtr<MultiLightShadowStage>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
MultiLightShadowStage *MultiLightShadowStageBase::createEmpty(void)
{
    MultiLightShadowStage *returnValue;

    newPtr<MultiLightShadowStage>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr MultiLightShadowStageBase::shallowCopyLocal(
    BitVector bFlags) const
{
    MultiLightShadowStage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightShadowStage *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightShadowStageBase::shallowCopyDependent(
    BitVector bFlags) const
{
    MultiLightShadowStage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightShadowStage *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightShadowStageBase::shallowCopy(void) const
{
    MultiLightShadowStage *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const MultiLightShadowStage *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

MultiLightShadowStageBase::MultiLightShadowStageBase(void) :
    Inherited(),
    _sfShadowMode             (UInt32(0)),
    _sfActivate               (bool(true)),
    _sfShadowOn               (bool(true)),
    _sfUseHWPCF               (bool(true)),
    _mfShadowParameter        (),
    _sfShadowMapWidth         (UInt32(1024)),
    _sfShadowMapHeight        (UInt32(1024)),
    _sfFilterDistributionSize (Int32(3)),
    _sfSearchDistributionSize (Int32(2)),
    _sfCullFrontFace          (bool(false)),
    _sfOffsetBias             (Real32(0.f)),
    _sfOffsetFactor           (Real32(0.f)),
    _sfEnlargeShadowVolumeZ   (Real32(0.01f)),
    _mfExcludeNodes           (),
    _sfAutoExcludeTransparentNodes(bool(true)),
    _sfMultiLightChunk        (NULL),
    _sfAutoSearchMultiLightChunk(bool(true)),
    _sfSamplerCubeArrayTextureUnit(Int32(-1)),
    _sfSamplerCubeArrayShadowTextureUnit(Int32(-1)),
    _sfSampler2DArrayTextureUnit(Int32(-1)),
    _sfSampler2DArrayShadowTextureUnit(Int32(-1)),
    _sfShadowDataBindingPnt   (Int32(-1)),
    _sfShadowParameterBindingPnt(Int32(-1)),
    _sfDistributionBindingPnt (Int32(-1)),
    _sfDisableOverride        (bool(false)),
    _sfArbTest                (bool(false))
{
}

MultiLightShadowStageBase::MultiLightShadowStageBase(const MultiLightShadowStageBase &source) :
    Inherited(source),
    _sfShadowMode             (source._sfShadowMode             ),
    _sfActivate               (source._sfActivate               ),
    _sfShadowOn               (source._sfShadowOn               ),
    _sfUseHWPCF               (source._sfUseHWPCF               ),
    _mfShadowParameter        (),
    _sfShadowMapWidth         (source._sfShadowMapWidth         ),
    _sfShadowMapHeight        (source._sfShadowMapHeight        ),
    _sfFilterDistributionSize (source._sfFilterDistributionSize ),
    _sfSearchDistributionSize (source._sfSearchDistributionSize ),
    _sfCullFrontFace          (source._sfCullFrontFace          ),
    _sfOffsetBias             (source._sfOffsetBias             ),
    _sfOffsetFactor           (source._sfOffsetFactor           ),
    _sfEnlargeShadowVolumeZ   (source._sfEnlargeShadowVolumeZ   ),
    _mfExcludeNodes           (),
    _sfAutoExcludeTransparentNodes(source._sfAutoExcludeTransparentNodes),
    _sfMultiLightChunk        (NULL),
    _sfAutoSearchMultiLightChunk(source._sfAutoSearchMultiLightChunk),
    _sfSamplerCubeArrayTextureUnit(source._sfSamplerCubeArrayTextureUnit),
    _sfSamplerCubeArrayShadowTextureUnit(source._sfSamplerCubeArrayShadowTextureUnit),
    _sfSampler2DArrayTextureUnit(source._sfSampler2DArrayTextureUnit),
    _sfSampler2DArrayShadowTextureUnit(source._sfSampler2DArrayShadowTextureUnit),
    _sfShadowDataBindingPnt   (source._sfShadowDataBindingPnt   ),
    _sfShadowParameterBindingPnt(source._sfShadowParameterBindingPnt),
    _sfDistributionBindingPnt (source._sfDistributionBindingPnt ),
    _sfDisableOverride        (source._sfDisableOverride        ),
    _sfArbTest                (source._sfArbTest                )
{
}


/*-------------------------- destructors ----------------------------------*/

MultiLightShadowStageBase::~MultiLightShadowStageBase(void)
{
}

void MultiLightShadowStageBase::onCreate(const MultiLightShadowStage *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        MultiLightShadowStage *pThis = static_cast<MultiLightShadowStage *>(this);

        MFUnrecMultiLightShadowParameterPtr::const_iterator ShadowParameterIt  =
            source->_mfShadowParameter.begin();
        MFUnrecMultiLightShadowParameterPtr::const_iterator ShadowParameterEnd =
            source->_mfShadowParameter.end  ();

        while(ShadowParameterIt != ShadowParameterEnd)
        {
            pThis->pushToShadowParameter(*ShadowParameterIt);

            ++ShadowParameterIt;
        }

        MFUnrecNodePtr::const_iterator ExcludeNodesIt  =
            source->_mfExcludeNodes.begin();
        MFUnrecNodePtr::const_iterator ExcludeNodesEnd =
            source->_mfExcludeNodes.end  ();

        while(ExcludeNodesIt != ExcludeNodesEnd)
        {
            pThis->pushToExcludeNodes(*ExcludeNodesIt);

            ++ExcludeNodesIt;
        }

        pThis->setMultiLightChunk(source->getMultiLightChunk());
    }
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleShadowMode      (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfShadowMode,
             this->getType().getFieldDesc(ShadowModeFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleShadowMode     (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfShadowMode,
             this->getType().getFieldDesc(ShadowModeFieldId),
             this));


    editSField(ShadowModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleActivate        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfActivate,
             this->getType().getFieldDesc(ActivateFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleActivate       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfActivate,
             this->getType().getFieldDesc(ActivateFieldId),
             this));


    editSField(ActivateFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleShadowOn        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfShadowOn,
             this->getType().getFieldDesc(ShadowOnFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleShadowOn       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfShadowOn,
             this->getType().getFieldDesc(ShadowOnFieldId),
             this));


    editSField(ShadowOnFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleUseHWPCF        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseHWPCF,
             this->getType().getFieldDesc(UseHWPCFFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleUseHWPCF       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseHWPCF,
             this->getType().getFieldDesc(UseHWPCFFieldId),
             this));


    editSField(UseHWPCFFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleShadowParameter (void) const
{
    MFUnrecMultiLightShadowParameterPtr::GetHandlePtr returnValue(
        new  MFUnrecMultiLightShadowParameterPtr::GetHandle(
             &_mfShadowParameter,
             this->getType().getFieldDesc(ShadowParameterFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleShadowParameter(void)
{
    MFUnrecMultiLightShadowParameterPtr::EditHandlePtr returnValue(
        new  MFUnrecMultiLightShadowParameterPtr::EditHandle(
             &_mfShadowParameter,
             this->getType().getFieldDesc(ShadowParameterFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&MultiLightShadowStage::pushToShadowParameter,
                    static_cast<MultiLightShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveMethod(
        boost::bind(&MultiLightShadowStage::removeFromShadowParameter,
                    static_cast<MultiLightShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveObjMethod(
        boost::bind(&MultiLightShadowStage::removeObjFromShadowParameter,
                    static_cast<MultiLightShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setClearMethod(
        boost::bind(&MultiLightShadowStage::clearShadowParameter,
                    static_cast<MultiLightShadowStage *>(this)));

    editMField(ShadowParameterFieldMask, _mfShadowParameter);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleShadowMapWidth  (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfShadowMapWidth,
             this->getType().getFieldDesc(ShadowMapWidthFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleShadowMapWidth (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfShadowMapWidth,
             this->getType().getFieldDesc(ShadowMapWidthFieldId),
             this));


    editSField(ShadowMapWidthFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleShadowMapHeight (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfShadowMapHeight,
             this->getType().getFieldDesc(ShadowMapHeightFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleShadowMapHeight(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfShadowMapHeight,
             this->getType().getFieldDesc(ShadowMapHeightFieldId),
             this));


    editSField(ShadowMapHeightFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleFilterDistributionSize (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfFilterDistributionSize,
             this->getType().getFieldDesc(FilterDistributionSizeFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleFilterDistributionSize(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfFilterDistributionSize,
             this->getType().getFieldDesc(FilterDistributionSizeFieldId),
             this));


    editSField(FilterDistributionSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleSearchDistributionSize (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSearchDistributionSize,
             this->getType().getFieldDesc(SearchDistributionSizeFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleSearchDistributionSize(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSearchDistributionSize,
             this->getType().getFieldDesc(SearchDistributionSizeFieldId),
             this));


    editSField(SearchDistributionSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleCullFrontFace   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfCullFrontFace,
             this->getType().getFieldDesc(CullFrontFaceFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleCullFrontFace  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfCullFrontFace,
             this->getType().getFieldDesc(CullFrontFaceFieldId),
             this));


    editSField(CullFrontFaceFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleOffsetBias      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffsetBias,
             this->getType().getFieldDesc(OffsetBiasFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleOffsetBias     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffsetBias,
             this->getType().getFieldDesc(OffsetBiasFieldId),
             this));


    editSField(OffsetBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleOffsetFactor    (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffsetFactor,
             this->getType().getFieldDesc(OffsetFactorFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleOffsetFactor   (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffsetFactor,
             this->getType().getFieldDesc(OffsetFactorFieldId),
             this));


    editSField(OffsetFactorFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleEnlargeShadowVolumeZ (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfEnlargeShadowVolumeZ,
             this->getType().getFieldDesc(EnlargeShadowVolumeZFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleEnlargeShadowVolumeZ(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfEnlargeShadowVolumeZ,
             this->getType().getFieldDesc(EnlargeShadowVolumeZFieldId),
             this));


    editSField(EnlargeShadowVolumeZFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleExcludeNodes    (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfExcludeNodes,
             this->getType().getFieldDesc(ExcludeNodesFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleExcludeNodes   (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfExcludeNodes,
             this->getType().getFieldDesc(ExcludeNodesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&MultiLightShadowStage::pushToExcludeNodes,
                    static_cast<MultiLightShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveMethod(
        boost::bind(&MultiLightShadowStage::removeFromExcludeNodes,
                    static_cast<MultiLightShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveObjMethod(
        boost::bind(&MultiLightShadowStage::removeObjFromExcludeNodes,
                    static_cast<MultiLightShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setClearMethod(
        boost::bind(&MultiLightShadowStage::clearExcludeNodes,
                    static_cast<MultiLightShadowStage *>(this)));

    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleAutoExcludeTransparentNodes (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAutoExcludeTransparentNodes,
             this->getType().getFieldDesc(AutoExcludeTransparentNodesFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleAutoExcludeTransparentNodes(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAutoExcludeTransparentNodes,
             this->getType().getFieldDesc(AutoExcludeTransparentNodesFieldId),
             this));


    editSField(AutoExcludeTransparentNodesFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleMultiLightChunk (void) const
{
    SFWeakMultiLightChunkPtr::GetHandlePtr returnValue(
        new  SFWeakMultiLightChunkPtr::GetHandle(
             &_sfMultiLightChunk,
             this->getType().getFieldDesc(MultiLightChunkFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleMultiLightChunk(void)
{
    SFWeakMultiLightChunkPtr::EditHandlePtr returnValue(
        new  SFWeakMultiLightChunkPtr::EditHandle(
             &_sfMultiLightChunk,
             this->getType().getFieldDesc(MultiLightChunkFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&MultiLightShadowStage::setMultiLightChunk,
                    static_cast<MultiLightShadowStage *>(this), ::boost::placeholders::_1));

    editSField(MultiLightChunkFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleAutoSearchMultiLightChunk (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAutoSearchMultiLightChunk,
             this->getType().getFieldDesc(AutoSearchMultiLightChunkFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleAutoSearchMultiLightChunk(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAutoSearchMultiLightChunk,
             this->getType().getFieldDesc(AutoSearchMultiLightChunkFieldId),
             this));


    editSField(AutoSearchMultiLightChunkFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleSamplerCubeArrayTextureUnit (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSamplerCubeArrayTextureUnit,
             this->getType().getFieldDesc(SamplerCubeArrayTextureUnitFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleSamplerCubeArrayTextureUnit(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSamplerCubeArrayTextureUnit,
             this->getType().getFieldDesc(SamplerCubeArrayTextureUnitFieldId),
             this));


    editSField(SamplerCubeArrayTextureUnitFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleSamplerCubeArrayShadowTextureUnit (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSamplerCubeArrayShadowTextureUnit,
             this->getType().getFieldDesc(SamplerCubeArrayShadowTextureUnitFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleSamplerCubeArrayShadowTextureUnit(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSamplerCubeArrayShadowTextureUnit,
             this->getType().getFieldDesc(SamplerCubeArrayShadowTextureUnitFieldId),
             this));


    editSField(SamplerCubeArrayShadowTextureUnitFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleSampler2DArrayTextureUnit (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSampler2DArrayTextureUnit,
             this->getType().getFieldDesc(Sampler2DArrayTextureUnitFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleSampler2DArrayTextureUnit(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSampler2DArrayTextureUnit,
             this->getType().getFieldDesc(Sampler2DArrayTextureUnitFieldId),
             this));


    editSField(Sampler2DArrayTextureUnitFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleSampler2DArrayShadowTextureUnit (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSampler2DArrayShadowTextureUnit,
             this->getType().getFieldDesc(Sampler2DArrayShadowTextureUnitFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleSampler2DArrayShadowTextureUnit(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSampler2DArrayShadowTextureUnit,
             this->getType().getFieldDesc(Sampler2DArrayShadowTextureUnitFieldId),
             this));


    editSField(Sampler2DArrayShadowTextureUnitFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleShadowDataBindingPnt (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfShadowDataBindingPnt,
             this->getType().getFieldDesc(ShadowDataBindingPntFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleShadowDataBindingPnt(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfShadowDataBindingPnt,
             this->getType().getFieldDesc(ShadowDataBindingPntFieldId),
             this));


    editSField(ShadowDataBindingPntFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleShadowParameterBindingPnt (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfShadowParameterBindingPnt,
             this->getType().getFieldDesc(ShadowParameterBindingPntFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleShadowParameterBindingPnt(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfShadowParameterBindingPnt,
             this->getType().getFieldDesc(ShadowParameterBindingPntFieldId),
             this));


    editSField(ShadowParameterBindingPntFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleDistributionBindingPnt (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDistributionBindingPnt,
             this->getType().getFieldDesc(DistributionBindingPntFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleDistributionBindingPnt(void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDistributionBindingPnt,
             this->getType().getFieldDesc(DistributionBindingPntFieldId),
             this));


    editSField(DistributionBindingPntFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleDisableOverride (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDisableOverride,
             this->getType().getFieldDesc(DisableOverrideFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleDisableOverride(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDisableOverride,
             this->getType().getFieldDesc(DisableOverrideFieldId),
             this));


    editSField(DisableOverrideFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightShadowStageBase::getHandleArbTest         (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfArbTest,
             this->getType().getFieldDesc(ArbTestFieldId),
             const_cast<MultiLightShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightShadowStageBase::editHandleArbTest        (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfArbTest,
             this->getType().getFieldDesc(ArbTestFieldId),
             this));


    editSField(ArbTestFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void MultiLightShadowStageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    MultiLightShadowStage *pThis = static_cast<MultiLightShadowStage *>(this);

    pThis->execSync(static_cast<MultiLightShadowStage *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *MultiLightShadowStageBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    MultiLightShadowStage *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const MultiLightShadowStage *>(pRefAspect),
                  dynamic_cast<const MultiLightShadowStage *>(this));

    return returnValue;
}
#endif

void MultiLightShadowStageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<MultiLightShadowStage *>(this)->clearShadowParameter();

    static_cast<MultiLightShadowStage *>(this)->clearExcludeNodes();

    static_cast<MultiLightShadowStage *>(this)->setMultiLightChunk(NULL);


}


OSG_END_NAMESPACE
