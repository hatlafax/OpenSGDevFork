/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class EnvironmentDesc!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"




#include "OSGEnvironmentDescBase.h"
#include "OSGEnvironmentDesc.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::EnvironmentDesc
    This class provides additional information about the
    render environment. Tonmapping, additional light info
    etc. are described here.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var UInt32          EnvironmentDescBase::_sfFeature
    Each environment category does have a unique feature
    value. Only if a feature is set it is evaluated by
    the machinery.
    The following feature categories are supported: 
    FEATURE_TONEMAPPING, FEATURE_CLASSIC_LIGHT_EXTENSIONS, 
    FEATURE_FOG
*/

/*! \var Vec4f           EnvironmentDescBase::_mfClipPlanes
    Set of active clip planes.
*/

/*! \var bool            EnvironmentDescBase::_sfApplyGamma
    If set gamma correction is performed just before writing to the final
    draw buffer at the end of the pipeline.
*/

/*! \var bool            EnvironmentDescBase::_sfAccurateGamma
    If set correct gamma calculation is performed, i.e. respect linear near black.
    This parameter is only in use if parameter applyGamma is set to true.
    See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html 
    https://en.wikipedia.org/wiki/Gamma_correction
    http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/
    for reference.
*/

/*! \var UInt32          EnvironmentDescBase::_sfToneMappingMode
    Tonemapping technique to use. Valid values are 
    NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, 
    REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTED2_TONE_MAPPING,
    FILMIC_ACES_TONE_MAPPING, FILMIC_HEJ2015_TONE_MAPPING

    For details about the different tone mapping techniques lookup the following references:
    Adaptive Logarithmic Mapping for Displaying High Contrast Scenes
    F. Drago, K. Myszkowski, T. Annen, and N. Chiba
    In Eurographics 2003 
    http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf

    Photographic Tone Reproduction for Digital Images
    Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda
    http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf

    http://filmicgames.com/archives/75
    http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff
*/

/*! \var UInt32          EnvironmentDescBase::_sfAutoExposureMode
    Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC, SATURATION_BASED and
    STANDARD_OUTPUT_BASED
*/

/*! \var bool            EnvironmentDescBase::_sfUse_ITU_R_BT_709
    Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance
    according to the American NTSC coding system.
    See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.
*/

/*! \var bool            EnvironmentDescBase::_sfUseLinChromCorrection
    Use a linear chromatic correction function. This works with parameter 'saturation'.
    See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.
*/

/*! \var Real32          EnvironmentDescBase::_sfExposure
    Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying 
    how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.
    Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.
    Reasonable values are in the interval [-10.f, 10.f]. 
*/

/*! \var Real32          EnvironmentDescBase::_sfKeyValue
    This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the 
    scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used
    for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.
    Reasonable values are in the interval [0.f, 1.f]. 
    See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.
*/

/*! \var Real32          EnvironmentDescBase::_sfApertureFNumber
    The f-number of an optical system such as a camera lens is the ratio of the system's focal length to 
    the diameter of the entrance pupil. N = f/D, with focal length of the lens f and diameter of the pupil
    (effective aperture) D. This value is used only for the autoExposureMode modes SATURATION_BASED and
    STANDARD_OUTPUT_BASED.
*/

/*! \var Real32          EnvironmentDescBase::_sfShutterSpeed
    A measure of the film exposure time given in reciprocal seconds.
    This value is used only for the autoExposureMode modes SATURATION_BASED and
    STANDARD_OUTPUT_BASED.
*/

/*! \var Real32          EnvironmentDescBase::_sfISO
    Film speed is the measure of a photographic film's sensitivity to light.
    This value is used only for the autoExposureMode modes SATURATION_BASED and
    STANDARD_OUTPUT_BASED.
*/

/*! \var Real32          EnvironmentDescBase::_sfWhiteLevel
    This parameter is the smallest luminance that will be mapped to pure white. It is used in the
    following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.
    Reasonable values are in the interval [0.f, 25.f]. 
    See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.
*/

/*! \var Real32          EnvironmentDescBase::_sfDragoBias
    The bias function is a power function defined over the unit interval, 
    an intuitive parameter dragoBias remaps an input value to a higher or lower value.
    This parameter is only used by the drago_logarithmic tone mapping technique.
    Reasonable values are in the interval [0.f, 1.f]. 
    See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.
*/

/*! \var Real32          EnvironmentDescBase::_sfSaturation
    This parameter allows to control the satuarion of the tone mapped scene. It allows color
    correction applied after tone mapping.
    Reasonable values are in the interval [0.f, 4.f]. 
    See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.
*/

/*! \var Real32          EnvironmentDescBase::_sfContrast
    The standard contrast operation simply pushes colors away from grey. The operation is
    performed before tone mapping in sRGB space.
    See http://filmicworlds.com/blog/minimal-color-grading-tools/
*/

/*! \var Real32          EnvironmentDescBase::_sfGamma
    The gamma value used for the GAMMA correction calculation.
*/

/*! \var Color3f         EnvironmentDescBase::_sfFilterColor
    The filter color is multiplied to the scene after exposure correction but before to the
    tone mapping operation.
    See http://filmicworlds.com/blog/minimal-color-grading-tools/
*/

/*! \var Vec3f           EnvironmentDescBase::_sfGlobalAmbientIntensity
    The global ambient light intensity, that is to be added to the single light ambient intensities.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<EnvironmentDesc *, nsOSG>::_type(
    "EnvironmentDescPtr", 
    "FieldContainerPtr", 
    EnvironmentDesc::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(EnvironmentDesc *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           EnvironmentDesc *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           EnvironmentDesc *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void EnvironmentDescBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "Feature",
        "Each environment category does have a unique feature\n"
        "value. Only if a feature is set it is evaluated by\n"
        "the machinery.\n"
        "The following feature categories are supported: \n"
        "FEATURE_TONEMAPPING, FEATURE_CLASSIC_LIGHT_EXTENSIONS, \n"
        "FEATURE_FOG\n",
        FeatureFieldId, FeatureFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleFeature),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleFeature));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec4f::Description(
        MFVec4f::getClassType(),
        "clipPlanes",
        "Set of active clip planes.\n",
        ClipPlanesFieldId, ClipPlanesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleClipPlanes),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleClipPlanes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "applyGamma",
        "If set gamma correction is performed just before writing to the final\n"
        "draw buffer at the end of the pipeline.\n",
        ApplyGammaFieldId, ApplyGammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleApplyGamma),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleApplyGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "accurateGamma",
        "If set correct gamma calculation is performed, i.e. respect linear near black.\n"
        "This parameter is only in use if parameter applyGamma is set to true.\n"
        "See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html \n"
        "https://en.wikipedia.org/wiki/Gamma_correction\n"
        "http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/\n"
        "for reference.\n",
        AccurateGammaFieldId, AccurateGammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleAccurateGamma),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleAccurateGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "toneMappingMode",
        "Tonemapping technique to use. Valid values are \n"
        "NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, \n"
        "REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTED2_TONE_MAPPING,\n"
        "FILMIC_ACES_TONE_MAPPING, FILMIC_HEJ2015_TONE_MAPPING\n"
        "\n"
        "For details about the different tone mapping techniques lookup the following references:\n"
        "Adaptive Logarithmic Mapping for Displaying High Contrast Scenes\n"
        "F. Drago, K. Myszkowski, T. Annen, and N. Chiba\n"
        "In Eurographics 2003 \n"
        "http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\n"
        "\n"
        "Photographic Tone Reproduction for Digital Images\n"
        "Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda\n"
        "http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\n"
        "\n"
        "http://filmicgames.com/archives/75\n"
        "http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
        "\n"
        "High Dynamic Range Imaging\n"
        "Aquisition, Display, and Image-Based Lighing\n"
        "Erik Reinhard et al.\n"
        "Second Edition 2010\n"
        "ISBN 978-0-12-374914-7\n",
        ToneMappingModeFieldId, ToneMappingModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleToneMappingMode),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleToneMappingMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "autoExposureMode",
        "Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC, SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED\n"
        "\n"
        "If set to manual mode the Exposure parameter is used directly. If key value mode is set the KeyValue is\n"
        "used for calculation of the used exposure value. If mode is set to automatic, then the KeyValue is also\n"
        "automatically calculated from the average luminance of the scene. The key value is a scalar that controls \n"
        "how brightly or darkly the algorithm will expose your scene. The remaining modes are based on\n"
        "the article \n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
        "and calculate the exposure value from ApertureFNumber, ShutterSpeedValue and ISO film value.\n",
        AutoExposureModeFieldId, AutoExposureModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleAutoExposureMode),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleAutoExposureMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "use_ITU_R_BT_709",
        "Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance\n"
        "according to the American NTSC coding system.\n"
        "See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.\n",
        Use_ITU_R_BT_709FieldId, Use_ITU_R_BT_709FieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleUse_ITU_R_BT_709),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleUse_ITU_R_BT_709));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useLinChromCorrection",
        "Use a linear chromatic correction function. This works with parameter 'saturation'.\n"
        "See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n",
        UseLinChromCorrectionFieldId, UseLinChromCorrectionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleUseLinChromCorrection),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleUseLinChromCorrection));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "exposure",
        "Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying \n"
        "how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.\n"
        "Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.\n"
        "Reasonable values are in the interval [-10.f, 10.f]. \n",
        ExposureFieldId, ExposureFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleExposure),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleExposure));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "keyValue",
        "This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the \n"
        "scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used\n"
        "for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.\n"
        "Reasonable values are in the interval [0.f, 1.f]. \n"
        "See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n",
        KeyValueFieldId, KeyValueFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleKeyValue),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleKeyValue));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "apertureFNumber",
        "The f-number of an optical system such as a camera lens is the ratio of the system's focal length to \n"
        "the diameter of the entrance pupil. N = f/D, with focal length of the lens f and diameter of the pupil\n"
        "(effective aperture) D. This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED.\n"
        "\n"
        "See also: https://en.wikipedia.org/wiki/F-number\n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n",
        ApertureFNumberFieldId, ApertureFNumberFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleApertureFNumber),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleApertureFNumber));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shutterSpeed",
        "A measure of the film exposure time given in reciprocal seconds.\n"
        "This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED.\n"
        "\n"
        "See also: https://en.wikipedia.org/wiki/F-number\n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n",
        ShutterSpeedFieldId, ShutterSpeedFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleShutterSpeed),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleShutterSpeed));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "ISO",
        "Film speed is the measure of a photographic film's sensitivity to light.\n"
        "This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED.\n"
        "\n"
        "See also: https://en.wikipedia.org/wiki/Film_speed\n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n",
        ISOFieldId, ISOFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleISO),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleISO));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "whiteLevel",
        "This parameter is the smallest luminance that will be mapped to pure white. It is used in the\n"
        "following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.\n"
        "Reasonable values are in the interval [0.f, 25.f]. \n"
        "See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n",
        WhiteLevelFieldId, WhiteLevelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleWhiteLevel),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleWhiteLevel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "dragoBias",
        "The bias function is a power function defined over the unit interval, \n"
        "an intuitive parameter dragoBias remaps an input value to a higher or lower value.\n"
        "This parameter is only used by the drago_logarithmic tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 1.f]. \n"
        "See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.\n",
        DragoBiasFieldId, DragoBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleDragoBias),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleDragoBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "saturation",
        "This parameter allows to control the satuarion of the tone mapped scene. It allows color\n"
        "correction applied after tone mapping.\n"
        "Reasonable values are in the interval [0.f, 4.f]. \n"
        "See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n",
        SaturationFieldId, SaturationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleSaturation),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleSaturation));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "contrast",
        "The standard contrast operation simply pushes colors away from grey. The operation is\n"
        "performed before tone mapping in sRGB space.\n"
        "See http://filmicworlds.com/blog/minimal-color-grading-tools/\n",
        ContrastFieldId, ContrastFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleContrast),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleContrast));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "gamma",
        "The gamma value used for the GAMMA correction calculation.\n",
        GammaFieldId, GammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleGamma),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "filterColor",
        "The filter color is multiplied to the scene after exposure correction but before to the\n"
        "tone mapping operation.\n"
        "See http://filmicworlds.com/blog/minimal-color-grading-tools/\n",
        FilterColorFieldId, FilterColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleFilterColor),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleFilterColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(),
        "globalAmbientIntensity",
        "The global ambient light intensity, that is to be added to the single light ambient intensities.\n",
        GlobalAmbientIntensityFieldId, GlobalAmbientIntensityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&EnvironmentDesc::editHandleGlobalAmbientIntensity),
        static_cast<FieldGetMethodSig >(&EnvironmentDesc::getHandleGlobalAmbientIntensity));

    oType.addInitialDesc(pDesc);
}


EnvironmentDescBase::TypeObject EnvironmentDescBase::_type(
    EnvironmentDescBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&EnvironmentDescBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&EnvironmentDesc::initMethod),
    reinterpret_cast<ExitContainerF>(&EnvironmentDesc::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&EnvironmentDesc::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"EnvironmentDesc\"\n"
    "    parent=\"FieldContainer\"\n"
    "    library=\"ContribTechniques\"\n"
    "    structure=\"concrete\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    >\n"
    "    This class provides additional information about the\n"
    "    render environment. Tonmapping, additional light info\n"
    "    etc. are described here.\n"
    "\n"
    "    <Field\n"
    "        name=\"Feature\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Each environment category does have a unique feature\n"
    "        value. Only if a feature is set it is evaluated by\n"
    "        the machinery.\n"
    "        The following feature categories are supported: \n"
    "        FEATURE_TONEMAPPING, FEATURE_CLASSIC_LIGHT_EXTENSIONS, \n"
    "        FEATURE_FOG\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"clipPlanes\"\n"
    "        type=\"Vec4f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Set of active clip planes.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"applyGamma\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If set gamma correction is performed just before writing to the final\n"
    "        draw buffer at the end of the pipeline.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"accurateGamma\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If set correct gamma calculation is performed, i.e. respect linear near black.\n"
    "        This parameter is only in use if parameter applyGamma is set to true.\n"
    "        See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html \n"
    "        https://en.wikipedia.org/wiki/Gamma_correction\n"
    "        http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/\n"
    "        for reference.\n"
    "    </Field>\n"
    "    \n"
    "    <Field\n"
    "        name=\"toneMappingMode\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"4\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Tonemapping technique to use. Valid values are \n"
    "        NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, \n"
    "        REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTED2_TONE_MAPPING,\n"
    "        FILMIC_ACES_TONE_MAPPING, FILMIC_HEJ2015_TONE_MAPPING\n"
    "\n"
    "        For details about the different tone mapping techniques lookup the following references:\n"
    "        Adaptive Logarithmic Mapping for Displaying High Contrast Scenes\n"
    "        F. Drago, K. Myszkowski, T. Annen, and N. Chiba\n"
    "        In Eurographics 2003 \n"
    "        http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\n"
    "\n"
    "        Photographic Tone Reproduction for Digital Images\n"
    "        Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda\n"
    "        http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\n"
    "\n"
    "        http://filmicgames.com/archives/75\n"
    "        http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
    "\n"
    "        High Dynamic Range Imaging\n"
    "        Aquisition, Display, and Image-Based Lighing\n"
    "        Erik Reinhard et al.\n"
    "        Second Edition 2010\n"
    "        ISBN 978-0-12-374914-7\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"autoExposureMode\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"2\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC, SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED\n"
    "\n"
    "        If set to manual mode the Exposure parameter is used directly. If key value mode is set the KeyValue is\n"
    "        used for calculation of the used exposure value. If mode is set to automatic, then the KeyValue is also\n"
    "        automatically calculated from the average luminance of the scene. The key value is a scalar that controls \n"
    "        how brightly or darkly the algorithm will expose your scene. The remaining modes are based on\n"
    "        the article \n"
    "        https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "        and calculate the exposure value from ApertureFNumber, ShutterSpeedValue and ISO film value.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"use_ITU_R_BT_709\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance\n"
    "        according to the American NTSC coding system.\n"
    "        See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"useLinChromCorrection\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Use a linear chromatic correction function. This works with parameter 'saturation'.\n"
    "        See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"exposure\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying \n"
    "        how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.\n"
    "        Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.\n"
    "        Reasonable values are in the interval [-10.f, 10.f]. \n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"keyValue\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.18f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the \n"
    "        scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used\n"
    "        for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.\n"
    "        Reasonable values are in the interval [0.f, 1.f]. \n"
    "        See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"apertureFNumber\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"16.0f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The f-number of an optical system such as a camera lens is the ratio of the system's focal length to \n"
    "        the diameter of the entrance pupil. N = f/D, with focal length of the lens f and diameter of the pupil\n"
    "        (effective aperture) D. This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED.\n"
    "\n"
    "        See also: https://en.wikipedia.org/wiki/F-number\n"
    "                  https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"shutterSpeed\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.01f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        A measure of the film exposure time given in reciprocal seconds.\n"
    "        This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED.\n"
    "\n"
    "        See also: https://en.wikipedia.org/wiki/F-number\n"
    "                  https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"ISO\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"100.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Film speed is the measure of a photographic film's sensitivity to light.\n"
    "        This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED.\n"
    "\n"
    "        See also: https://en.wikipedia.org/wiki/Film_speed\n"
    "                  https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"whiteLevel\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"5.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This parameter is the smallest luminance that will be mapped to pure white. It is used in the\n"
    "        following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.\n"
    "        Reasonable values are in the interval [0.f, 25.f]. \n"
    "        See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"dragoBias\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.85f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The bias function is a power function defined over the unit interval, \n"
    "        an intuitive parameter dragoBias remaps an input value to a higher or lower value.\n"
    "        This parameter is only used by the drago_logarithmic tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 1.f]. \n"
    "        See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"saturation\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This parameter allows to control the satuarion of the tone mapped scene. It allows color\n"
    "        correction applied after tone mapping.\n"
    "        Reasonable values are in the interval [0.f, 4.f]. \n"
    "        See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"contrast\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The standard contrast operation simply pushes colors away from grey. The operation is\n"
    "        performed before tone mapping in sRGB space.\n"
    "        See http://filmicworlds.com/blog/minimal-color-grading-tools/\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"gamma\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"2.2f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The gamma value used for the GAMMA correction calculation.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"filterColor\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"Color3f(1.f,1.f,1.f)\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The filter color is multiplied to the scene after exposure correction but before to the\n"
    "        tone mapping operation.\n"
    "        See http://filmicworlds.com/blog/minimal-color-grading-tools/\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"globalAmbientIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"Vec3f(0,0,0)\"\n"
    "    >\n"
    "    The global ambient light intensity, that is to be added to the single light ambient intensities.\n"
    "    </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "This class provides additional information about the\n"
    "render environment. Tonmapping, additional light info\n"
    "etc. are described here.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &EnvironmentDescBase::getType(void)
{
    return _type;
}

const FieldContainerType &EnvironmentDescBase::getType(void) const
{
    return _type;
}

UInt32 EnvironmentDescBase::getContainerSize(void) const
{
    return sizeof(EnvironmentDesc);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *EnvironmentDescBase::editSFFeature(void)
{
    editSField(FeatureFieldMask);

    return &_sfFeature;
}

const SFUInt32 *EnvironmentDescBase::getSFFeature(void) const
{
    return &_sfFeature;
}


MFVec4f *EnvironmentDescBase::editMFClipPlanes(void)
{
    editMField(ClipPlanesFieldMask, _mfClipPlanes);

    return &_mfClipPlanes;
}

const MFVec4f *EnvironmentDescBase::getMFClipPlanes(void) const
{
    return &_mfClipPlanes;
}


SFBool *EnvironmentDescBase::editSFApplyGamma(void)
{
    editSField(ApplyGammaFieldMask);

    return &_sfApplyGamma;
}

const SFBool *EnvironmentDescBase::getSFApplyGamma(void) const
{
    return &_sfApplyGamma;
}


SFBool *EnvironmentDescBase::editSFAccurateGamma(void)
{
    editSField(AccurateGammaFieldMask);

    return &_sfAccurateGamma;
}

const SFBool *EnvironmentDescBase::getSFAccurateGamma(void) const
{
    return &_sfAccurateGamma;
}


SFUInt32 *EnvironmentDescBase::editSFToneMappingMode(void)
{
    editSField(ToneMappingModeFieldMask);

    return &_sfToneMappingMode;
}

const SFUInt32 *EnvironmentDescBase::getSFToneMappingMode(void) const
{
    return &_sfToneMappingMode;
}


SFUInt32 *EnvironmentDescBase::editSFAutoExposureMode(void)
{
    editSField(AutoExposureModeFieldMask);

    return &_sfAutoExposureMode;
}

const SFUInt32 *EnvironmentDescBase::getSFAutoExposureMode(void) const
{
    return &_sfAutoExposureMode;
}


SFBool *EnvironmentDescBase::editSFUse_ITU_R_BT_709(void)
{
    editSField(Use_ITU_R_BT_709FieldMask);

    return &_sfUse_ITU_R_BT_709;
}

const SFBool *EnvironmentDescBase::getSFUse_ITU_R_BT_709(void) const
{
    return &_sfUse_ITU_R_BT_709;
}


SFBool *EnvironmentDescBase::editSFUseLinChromCorrection(void)
{
    editSField(UseLinChromCorrectionFieldMask);

    return &_sfUseLinChromCorrection;
}

const SFBool *EnvironmentDescBase::getSFUseLinChromCorrection(void) const
{
    return &_sfUseLinChromCorrection;
}


SFReal32 *EnvironmentDescBase::editSFExposure(void)
{
    editSField(ExposureFieldMask);

    return &_sfExposure;
}

const SFReal32 *EnvironmentDescBase::getSFExposure(void) const
{
    return &_sfExposure;
}


SFReal32 *EnvironmentDescBase::editSFKeyValue(void)
{
    editSField(KeyValueFieldMask);

    return &_sfKeyValue;
}

const SFReal32 *EnvironmentDescBase::getSFKeyValue(void) const
{
    return &_sfKeyValue;
}


SFReal32 *EnvironmentDescBase::editSFApertureFNumber(void)
{
    editSField(ApertureFNumberFieldMask);

    return &_sfApertureFNumber;
}

const SFReal32 *EnvironmentDescBase::getSFApertureFNumber(void) const
{
    return &_sfApertureFNumber;
}


SFReal32 *EnvironmentDescBase::editSFShutterSpeed(void)
{
    editSField(ShutterSpeedFieldMask);

    return &_sfShutterSpeed;
}

const SFReal32 *EnvironmentDescBase::getSFShutterSpeed(void) const
{
    return &_sfShutterSpeed;
}


SFReal32 *EnvironmentDescBase::editSFISO(void)
{
    editSField(ISOFieldMask);

    return &_sfISO;
}

const SFReal32 *EnvironmentDescBase::getSFISO(void) const
{
    return &_sfISO;
}


SFReal32 *EnvironmentDescBase::editSFWhiteLevel(void)
{
    editSField(WhiteLevelFieldMask);

    return &_sfWhiteLevel;
}

const SFReal32 *EnvironmentDescBase::getSFWhiteLevel(void) const
{
    return &_sfWhiteLevel;
}


SFReal32 *EnvironmentDescBase::editSFDragoBias(void)
{
    editSField(DragoBiasFieldMask);

    return &_sfDragoBias;
}

const SFReal32 *EnvironmentDescBase::getSFDragoBias(void) const
{
    return &_sfDragoBias;
}


SFReal32 *EnvironmentDescBase::editSFSaturation(void)
{
    editSField(SaturationFieldMask);

    return &_sfSaturation;
}

const SFReal32 *EnvironmentDescBase::getSFSaturation(void) const
{
    return &_sfSaturation;
}


SFReal32 *EnvironmentDescBase::editSFContrast(void)
{
    editSField(ContrastFieldMask);

    return &_sfContrast;
}

const SFReal32 *EnvironmentDescBase::getSFContrast(void) const
{
    return &_sfContrast;
}


SFReal32 *EnvironmentDescBase::editSFGamma(void)
{
    editSField(GammaFieldMask);

    return &_sfGamma;
}

const SFReal32 *EnvironmentDescBase::getSFGamma(void) const
{
    return &_sfGamma;
}


SFColor3f *EnvironmentDescBase::editSFFilterColor(void)
{
    editSField(FilterColorFieldMask);

    return &_sfFilterColor;
}

const SFColor3f *EnvironmentDescBase::getSFFilterColor(void) const
{
    return &_sfFilterColor;
}


SFVec3f *EnvironmentDescBase::editSFGlobalAmbientIntensity(void)
{
    editSField(GlobalAmbientIntensityFieldMask);

    return &_sfGlobalAmbientIntensity;
}

const SFVec3f *EnvironmentDescBase::getSFGlobalAmbientIntensity(void) const
{
    return &_sfGlobalAmbientIntensity;
}






/*------------------------------ access -----------------------------------*/

SizeT EnvironmentDescBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (FeatureFieldMask & whichField))
    {
        returnValue += _sfFeature.getBinSize();
    }
    if(FieldBits::NoField != (ClipPlanesFieldMask & whichField))
    {
        returnValue += _mfClipPlanes.getBinSize();
    }
    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        returnValue += _sfApplyGamma.getBinSize();
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        returnValue += _sfAccurateGamma.getBinSize();
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        returnValue += _sfToneMappingMode.getBinSize();
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        returnValue += _sfAutoExposureMode.getBinSize();
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        returnValue += _sfUse_ITU_R_BT_709.getBinSize();
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        returnValue += _sfUseLinChromCorrection.getBinSize();
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        returnValue += _sfExposure.getBinSize();
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        returnValue += _sfKeyValue.getBinSize();
    }
    if(FieldBits::NoField != (ApertureFNumberFieldMask & whichField))
    {
        returnValue += _sfApertureFNumber.getBinSize();
    }
    if(FieldBits::NoField != (ShutterSpeedFieldMask & whichField))
    {
        returnValue += _sfShutterSpeed.getBinSize();
    }
    if(FieldBits::NoField != (ISOFieldMask & whichField))
    {
        returnValue += _sfISO.getBinSize();
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        returnValue += _sfWhiteLevel.getBinSize();
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        returnValue += _sfDragoBias.getBinSize();
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        returnValue += _sfSaturation.getBinSize();
    }
    if(FieldBits::NoField != (ContrastFieldMask & whichField))
    {
        returnValue += _sfContrast.getBinSize();
    }
    if(FieldBits::NoField != (GammaFieldMask & whichField))
    {
        returnValue += _sfGamma.getBinSize();
    }
    if(FieldBits::NoField != (FilterColorFieldMask & whichField))
    {
        returnValue += _sfFilterColor.getBinSize();
    }
    if(FieldBits::NoField != (GlobalAmbientIntensityFieldMask & whichField))
    {
        returnValue += _sfGlobalAmbientIntensity.getBinSize();
    }

    return returnValue;
}

void EnvironmentDescBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (FeatureFieldMask & whichField))
    {
        _sfFeature.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ClipPlanesFieldMask & whichField))
    {
        _mfClipPlanes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        _sfApplyGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        _sfAccurateGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        _sfToneMappingMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        _sfAutoExposureMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        _sfUse_ITU_R_BT_709.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        _sfUseLinChromCorrection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        _sfExposure.copyToBin(pMem);
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        _sfKeyValue.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ApertureFNumberFieldMask & whichField))
    {
        _sfApertureFNumber.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShutterSpeedFieldMask & whichField))
    {
        _sfShutterSpeed.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ISOFieldMask & whichField))
    {
        _sfISO.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        _sfWhiteLevel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        _sfDragoBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        _sfSaturation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ContrastFieldMask & whichField))
    {
        _sfContrast.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GammaFieldMask & whichField))
    {
        _sfGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilterColorFieldMask & whichField))
    {
        _sfFilterColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GlobalAmbientIntensityFieldMask & whichField))
    {
        _sfGlobalAmbientIntensity.copyToBin(pMem);
    }
}

void EnvironmentDescBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (FeatureFieldMask & whichField))
    {
        editSField(FeatureFieldMask);
        _sfFeature.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ClipPlanesFieldMask & whichField))
    {
        editMField(ClipPlanesFieldMask, _mfClipPlanes);
        _mfClipPlanes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        editSField(ApplyGammaFieldMask);
        _sfApplyGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        editSField(AccurateGammaFieldMask);
        _sfAccurateGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        editSField(ToneMappingModeFieldMask);
        _sfToneMappingMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        editSField(AutoExposureModeFieldMask);
        _sfAutoExposureMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        editSField(Use_ITU_R_BT_709FieldMask);
        _sfUse_ITU_R_BT_709.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        editSField(UseLinChromCorrectionFieldMask);
        _sfUseLinChromCorrection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        editSField(ExposureFieldMask);
        _sfExposure.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        editSField(KeyValueFieldMask);
        _sfKeyValue.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ApertureFNumberFieldMask & whichField))
    {
        editSField(ApertureFNumberFieldMask);
        _sfApertureFNumber.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShutterSpeedFieldMask & whichField))
    {
        editSField(ShutterSpeedFieldMask);
        _sfShutterSpeed.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ISOFieldMask & whichField))
    {
        editSField(ISOFieldMask);
        _sfISO.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        editSField(WhiteLevelFieldMask);
        _sfWhiteLevel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        editSField(DragoBiasFieldMask);
        _sfDragoBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        editSField(SaturationFieldMask);
        _sfSaturation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ContrastFieldMask & whichField))
    {
        editSField(ContrastFieldMask);
        _sfContrast.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GammaFieldMask & whichField))
    {
        editSField(GammaFieldMask);
        _sfGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilterColorFieldMask & whichField))
    {
        editSField(FilterColorFieldMask);
        _sfFilterColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GlobalAmbientIntensityFieldMask & whichField))
    {
        editSField(GlobalAmbientIntensityFieldMask);
        _sfGlobalAmbientIntensity.copyFromBin(pMem);
    }
}

//! create a new instance of the class
EnvironmentDescTransitPtr EnvironmentDescBase::createLocal(BitVector bFlags)
{
    EnvironmentDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<EnvironmentDesc>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
EnvironmentDescTransitPtr EnvironmentDescBase::createDependent(BitVector bFlags)
{
    EnvironmentDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<EnvironmentDesc>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
EnvironmentDescTransitPtr EnvironmentDescBase::create(void)
{
    EnvironmentDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<EnvironmentDesc>(tmpPtr);
    }

    return fc;
}

EnvironmentDesc *EnvironmentDescBase::createEmptyLocal(BitVector bFlags)
{
    EnvironmentDesc *returnValue;

    newPtr<EnvironmentDesc>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
EnvironmentDesc *EnvironmentDescBase::createEmpty(void)
{
    EnvironmentDesc *returnValue;

    newPtr<EnvironmentDesc>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr EnvironmentDescBase::shallowCopyLocal(
    BitVector bFlags) const
{
    EnvironmentDesc *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const EnvironmentDesc *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr EnvironmentDescBase::shallowCopyDependent(
    BitVector bFlags) const
{
    EnvironmentDesc *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const EnvironmentDesc *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr EnvironmentDescBase::shallowCopy(void) const
{
    EnvironmentDesc *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const EnvironmentDesc *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

EnvironmentDescBase::EnvironmentDescBase(void) :
    Inherited(),
    _sfFeature                (UInt32(0)),
    _mfClipPlanes             (),
    _sfApplyGamma             (bool(true)),
    _sfAccurateGamma          (bool(true)),
    _sfToneMappingMode        (UInt32(4)),
    _sfAutoExposureMode       (UInt32(2)),
    _sfUse_ITU_R_BT_709       (bool(true)),
    _sfUseLinChromCorrection  (bool(true)),
    _sfExposure               (Real32(0.f)),
    _sfKeyValue               (Real32(0.18f)),
    _sfApertureFNumber        (Real32(16.0f)),
    _sfShutterSpeed           (Real32(0.01f)),
    _sfISO                    (Real32(100.f)),
    _sfWhiteLevel             (Real32(5.f)),
    _sfDragoBias              (Real32(0.85f)),
    _sfSaturation             (Real32(1.f)),
    _sfContrast               (Real32(1.f)),
    _sfGamma                  (Real32(2.2f)),
    _sfFilterColor            (Color3f(Color3f(1.f,1.f,1.f))),
    _sfGlobalAmbientIntensity (Vec3f(Vec3f(0,0,0)))
{
}

EnvironmentDescBase::EnvironmentDescBase(const EnvironmentDescBase &source) :
    Inherited(source),
    _sfFeature                (source._sfFeature                ),
    _mfClipPlanes             (source._mfClipPlanes             ),
    _sfApplyGamma             (source._sfApplyGamma             ),
    _sfAccurateGamma          (source._sfAccurateGamma          ),
    _sfToneMappingMode        (source._sfToneMappingMode        ),
    _sfAutoExposureMode       (source._sfAutoExposureMode       ),
    _sfUse_ITU_R_BT_709       (source._sfUse_ITU_R_BT_709       ),
    _sfUseLinChromCorrection  (source._sfUseLinChromCorrection  ),
    _sfExposure               (source._sfExposure               ),
    _sfKeyValue               (source._sfKeyValue               ),
    _sfApertureFNumber        (source._sfApertureFNumber        ),
    _sfShutterSpeed           (source._sfShutterSpeed           ),
    _sfISO                    (source._sfISO                    ),
    _sfWhiteLevel             (source._sfWhiteLevel             ),
    _sfDragoBias              (source._sfDragoBias              ),
    _sfSaturation             (source._sfSaturation             ),
    _sfContrast               (source._sfContrast               ),
    _sfGamma                  (source._sfGamma                  ),
    _sfFilterColor            (source._sfFilterColor            ),
    _sfGlobalAmbientIntensity (source._sfGlobalAmbientIntensity )
{
}


/*-------------------------- destructors ----------------------------------*/

EnvironmentDescBase::~EnvironmentDescBase(void)
{
}


GetFieldHandlePtr EnvironmentDescBase::getHandleFeature         (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfFeature,
             this->getType().getFieldDesc(FeatureFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleFeature        (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfFeature,
             this->getType().getFieldDesc(FeatureFieldId),
             this));


    editSField(FeatureFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleClipPlanes      (void) const
{
    MFVec4f::GetHandlePtr returnValue(
        new  MFVec4f::GetHandle(
             &_mfClipPlanes,
             this->getType().getFieldDesc(ClipPlanesFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleClipPlanes     (void)
{
    MFVec4f::EditHandlePtr returnValue(
        new  MFVec4f::EditHandle(
             &_mfClipPlanes,
             this->getType().getFieldDesc(ClipPlanesFieldId),
             this));


    editMField(ClipPlanesFieldMask, _mfClipPlanes);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleApplyGamma      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfApplyGamma,
             this->getType().getFieldDesc(ApplyGammaFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleApplyGamma     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfApplyGamma,
             this->getType().getFieldDesc(ApplyGammaFieldId),
             this));


    editSField(ApplyGammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleAccurateGamma   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAccurateGamma,
             this->getType().getFieldDesc(AccurateGammaFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleAccurateGamma  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAccurateGamma,
             this->getType().getFieldDesc(AccurateGammaFieldId),
             this));


    editSField(AccurateGammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleToneMappingMode (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfToneMappingMode,
             this->getType().getFieldDesc(ToneMappingModeFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleToneMappingMode(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfToneMappingMode,
             this->getType().getFieldDesc(ToneMappingModeFieldId),
             this));


    editSField(ToneMappingModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleAutoExposureMode (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfAutoExposureMode,
             this->getType().getFieldDesc(AutoExposureModeFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleAutoExposureMode(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfAutoExposureMode,
             this->getType().getFieldDesc(AutoExposureModeFieldId),
             this));


    editSField(AutoExposureModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleUse_ITU_R_BT_709 (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUse_ITU_R_BT_709,
             this->getType().getFieldDesc(Use_ITU_R_BT_709FieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleUse_ITU_R_BT_709(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUse_ITU_R_BT_709,
             this->getType().getFieldDesc(Use_ITU_R_BT_709FieldId),
             this));


    editSField(Use_ITU_R_BT_709FieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleUseLinChromCorrection (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseLinChromCorrection,
             this->getType().getFieldDesc(UseLinChromCorrectionFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleUseLinChromCorrection(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseLinChromCorrection,
             this->getType().getFieldDesc(UseLinChromCorrectionFieldId),
             this));


    editSField(UseLinChromCorrectionFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleExposure        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfExposure,
             this->getType().getFieldDesc(ExposureFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleExposure       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfExposure,
             this->getType().getFieldDesc(ExposureFieldId),
             this));


    editSField(ExposureFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleKeyValue        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfKeyValue,
             this->getType().getFieldDesc(KeyValueFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleKeyValue       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfKeyValue,
             this->getType().getFieldDesc(KeyValueFieldId),
             this));


    editSField(KeyValueFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleApertureFNumber (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfApertureFNumber,
             this->getType().getFieldDesc(ApertureFNumberFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleApertureFNumber(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfApertureFNumber,
             this->getType().getFieldDesc(ApertureFNumberFieldId),
             this));


    editSField(ApertureFNumberFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleShutterSpeed    (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfShutterSpeed,
             this->getType().getFieldDesc(ShutterSpeedFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleShutterSpeed   (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfShutterSpeed,
             this->getType().getFieldDesc(ShutterSpeedFieldId),
             this));


    editSField(ShutterSpeedFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleISO             (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfISO,
             this->getType().getFieldDesc(ISOFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleISO            (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfISO,
             this->getType().getFieldDesc(ISOFieldId),
             this));


    editSField(ISOFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleWhiteLevel      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfWhiteLevel,
             this->getType().getFieldDesc(WhiteLevelFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleWhiteLevel     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfWhiteLevel,
             this->getType().getFieldDesc(WhiteLevelFieldId),
             this));


    editSField(WhiteLevelFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleDragoBias       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfDragoBias,
             this->getType().getFieldDesc(DragoBiasFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleDragoBias      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfDragoBias,
             this->getType().getFieldDesc(DragoBiasFieldId),
             this));


    editSField(DragoBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleSaturation      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfSaturation,
             this->getType().getFieldDesc(SaturationFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleSaturation     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfSaturation,
             this->getType().getFieldDesc(SaturationFieldId),
             this));


    editSField(SaturationFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleContrast        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfContrast,
             this->getType().getFieldDesc(ContrastFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleContrast       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfContrast,
             this->getType().getFieldDesc(ContrastFieldId),
             this));


    editSField(ContrastFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleGamma           (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfGamma,
             this->getType().getFieldDesc(GammaFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleGamma          (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfGamma,
             this->getType().getFieldDesc(GammaFieldId),
             this));


    editSField(GammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleFilterColor     (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfFilterColor,
             this->getType().getFieldDesc(FilterColorFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleFilterColor    (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfFilterColor,
             this->getType().getFieldDesc(FilterColorFieldId),
             this));


    editSField(FilterColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr EnvironmentDescBase::getHandleGlobalAmbientIntensity (void) const
{
    SFVec3f::GetHandlePtr returnValue(
        new  SFVec3f::GetHandle(
             &_sfGlobalAmbientIntensity,
             this->getType().getFieldDesc(GlobalAmbientIntensityFieldId),
             const_cast<EnvironmentDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr EnvironmentDescBase::editHandleGlobalAmbientIntensity(void)
{
    SFVec3f::EditHandlePtr returnValue(
        new  SFVec3f::EditHandle(
             &_sfGlobalAmbientIntensity,
             this->getType().getFieldDesc(GlobalAmbientIntensityFieldId),
             this));


    editSField(GlobalAmbientIntensityFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void EnvironmentDescBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    EnvironmentDesc *pThis = static_cast<EnvironmentDesc *>(this);

    pThis->execSync(static_cast<EnvironmentDesc *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *EnvironmentDescBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    EnvironmentDesc *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const EnvironmentDesc *>(pRefAspect),
                  dynamic_cast<const EnvironmentDesc *>(this));

    return returnValue;
}
#endif

void EnvironmentDescBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfClipPlanes.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
