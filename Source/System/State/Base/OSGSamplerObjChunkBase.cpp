/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class SamplerObjChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"


#include "OSGGL.h"                        // MinFilter default header
#include "OSGGL.h"                        // MagFilter default header
#include "OSGGL.h"                        // WrapS default header
#include "OSGGL.h"                        // WrapT default header
#include "OSGGL.h"                        // WrapR default header
#include "OSGGL.h"                        // CompareMode default header
#include "OSGGL.h"                        // CompareFunc default header


#include "OSGSamplerObjChunkBase.h"
#include "OSGSamplerObjChunk.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::SamplerObjChunk
    See \ref PageSystemSamplerObjChunk for a description.

    A Sampler Object is an OpenGL Object that stores the sampling 
    parameters for a Texture access inside of a shader.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var GLenum          SamplerObjChunkBase::_sfGLId
    The OpenGL object id for this sampler object.
*/

/*! \var UInt32          SamplerObjChunkBase::_mfTextureUnits
    The texture units to which to bind the sampler.
*/

/*! \var Color4f         SamplerObjChunkBase::_sfBorderColor
    Texture border color
*/

/*! \var GLenum          SamplerObjChunkBase::_sfMinFilter
    The texture minifying function is used whenever the pixel being textured maps
    to an area greater than one texture element. Defaults to GL_LINEAR_MIPMAP_LINEAR.
*/

/*! \var GLenum          SamplerObjChunkBase::_sfMagFilter
    he texture magnification function is used when the pixel being textured maps
    to an area less than or equal to one texture element. Defaults to GL_LINEAR.
*/

/*! \var GLenum          SamplerObjChunkBase::_sfWrapS
    Texture coordinate S wrapping, default GL_REPEAT.
*/

/*! \var GLenum          SamplerObjChunkBase::_sfWrapT
    Texture coordinate T wrapping, default GL_REPEAT.
*/

/*! \var GLenum          SamplerObjChunkBase::_sfWrapR
    Texture coordinate R wrapping, default GL_REPEAT.
*/

/*! \var Real32          SamplerObjChunkBase::_sfMinLOD
    Sets the minimum level-of-detail parameter. This floating-point value limits the selection
    of highest resolution mipmap (lowest mipmap level). The initial value is -1000.
*/

/*! \var Real32          SamplerObjChunkBase::_sfMaxLOD
    Sets the maximum level-of-detail parameter.  This floating-point value limits the selection 
    of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.
*/

/*! \var Real32          SamplerObjChunkBase::_sfLODBias
    OpenGL computes a texture level-of-detail parameter, called lambda in the GL specification,
    that determines which mipmap levels and their relative mipmap weights for use in mipmapped
    texture filtering.
    This extension provides a means to bias the lambda computation by a constant (signed) value.
    This bias can provide a way to blur or pseudo-sharpen OpenGL's standard texture filtering.
*/

/*! \var GLenum          SamplerObjChunkBase::_sfCompareMode
    Specifies the texture comparison mode for currently bound depth textures.
    That is, a texture whose internal format is GL_DEPTH_COMPONENT_*.
    GL_COMPARE_R_TO_TEXTURE : Specifies that the interpolated and clamped r
    texture coordinate should be compared to the value in the currently 
    bound depth texture.
    GL_NONE : Specifies that the luminance, intensity, or alpha (as specified 
    by GL_DEPTH_TEXTURE_MODE) should be assigned the appropriate value 
    from the currently bound depth texture.
*/

/*! \var GLenum          SamplerObjChunkBase::_sfCompareFunc
    Specifies the comparison operator used when GL_TEXTURE_COMPARE_MODE is
    set to GL_COMPARE_R_TO_TEXTURE.
*/

/*! \var Real32          SamplerObjChunkBase::_sfMaxAnisotropy
    Texture mapping using OpenGL's existing mipmap texture filtering modes assumes that the 
    projection of the pixel filter footprint into texture space is a square (ie, isotropic).
    In practice however, the footprint may be long and narrow (ie, anisotropic). Consequently,
    mipmap filtering severely blurs images on surfaces angled obliquely away from the viewer.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<SamplerObjChunk *, nsOSG>::_type(
    "SamplerObjChunkPtr", 
    "StateChunkPtr", 
    SamplerObjChunk::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(SamplerObjChunk *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           SamplerObjChunk *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           SamplerObjChunk *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void SamplerObjChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "GLId",
        "The OpenGL object id for this sampler object.\n",
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleGLId),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt32::Description(
        MFUInt32::getClassType(),
        "textureUnits",
        "The texture units to which to bind the sampler.\n",
        TextureUnitsFieldId, TextureUnitsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleTextureUnits),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleTextureUnits));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(),
        "borderColor",
        "Texture border color\n",
        BorderColorFieldId, BorderColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleBorderColor),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleBorderColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "minFilter",
        "The texture minifying function is used whenever the pixel being textured maps\n"
        "to an area greater than one texture element. Defaults to GL_LINEAR_MIPMAP_LINEAR.\n",
        MinFilterFieldId, MinFilterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleMinFilter),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleMinFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "magFilter",
        "he texture magnification function is used when the pixel being textured maps\n"
        "to an area less than or equal to one texture element. Defaults to GL_LINEAR.\n",
        MagFilterFieldId, MagFilterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleMagFilter),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleMagFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapS",
        "Texture coordinate S wrapping, default GL_REPEAT.\n",
        WrapSFieldId, WrapSFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleWrapS),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleWrapS));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapT",
        "Texture coordinate T wrapping, default GL_REPEAT.\n",
        WrapTFieldId, WrapTFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleWrapT),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleWrapT));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapR",
        "Texture coordinate R wrapping, default GL_REPEAT.\n",
        WrapRFieldId, WrapRFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleWrapR),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleWrapR));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "minLOD",
        "Sets the minimum level-of-detail parameter. This floating-point value limits the selection\n"
        "of highest resolution mipmap (lowest mipmap level). The initial value is -1000.\n",
        MinLODFieldId, MinLODFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleMinLOD),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleMinLOD));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "maxLOD",
        "Sets the maximum level-of-detail parameter.  This floating-point value limits the selection \n"
        "of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.\n",
        MaxLODFieldId, MaxLODFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleMaxLOD),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleMaxLOD));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "LODBias",
        "OpenGL computes a texture level-of-detail parameter, called lambda in the GL specification,\n"
        "that determines which mipmap levels and their relative mipmap weights for use in mipmapped\n"
        "texture filtering.\n"
        "This extension provides a means to bias the lambda computation by a constant (signed) value.\n"
        "This bias can provide a way to blur or pseudo-sharpen OpenGL's standard texture filtering.\n",
        LODBiasFieldId, LODBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleLODBias),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleLODBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "compareMode",
        "Specifies the texture comparison mode for currently bound depth textures.\n"
        "That is, a texture whose internal format is GL_DEPTH_COMPONENT_*.\n"
        "GL_COMPARE_R_TO_TEXTURE : Specifies that the interpolated and clamped r\n"
        "texture coordinate should be compared to the value in the currently \n"
        "bound depth texture.\n"
        "GL_NONE : Specifies that the luminance, intensity, or alpha (as specified \n"
        "by GL_DEPTH_TEXTURE_MODE) should be assigned the appropriate value \n"
        "from the currently bound depth texture.\n",
        CompareModeFieldId, CompareModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleCompareMode),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleCompareMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "compareFunc",
        "Specifies the comparison operator used when GL_TEXTURE_COMPARE_MODE is\n"
        "set to GL_COMPARE_R_TO_TEXTURE.\n",
        CompareFuncFieldId, CompareFuncFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleCompareFunc),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleCompareFunc));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "maxAnisotropy",
        "Texture mapping using OpenGL's existing mipmap texture filtering modes assumes that the \n"
        "projection of the pixel filter footprint into texture space is a square (ie, isotropic).\n"
        "In practice however, the footprint may be long and narrow (ie, anisotropic). Consequently,\n"
        "mipmap filtering severely blurs images on surfaces angled obliquely away from the viewer.\n"
        "\n"
        "The extension permits the OpenGL application to specify on a per-texture object basis the\n"
        "maximum degree of anisotropy to account for in texture filtering.\n",
        MaxAnisotropyFieldId, MaxAnisotropyFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SamplerObjChunk::editHandleMaxAnisotropy),
        static_cast<FieldGetMethodSig >(&SamplerObjChunk::getHandleMaxAnisotropy));

    oType.addInitialDesc(pDesc);
}


SamplerObjChunkBase::TypeObject SamplerObjChunkBase::_type(
    SamplerObjChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&SamplerObjChunkBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&SamplerObjChunk::initMethod),
    reinterpret_cast<ExitContainerF>(&SamplerObjChunk::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&SamplerObjChunk::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"SamplerObjChunk\"\n"
    "   parent=\"StateChunk\"\n"
    "   library=\"System\"\n"
    "   pointerfieldtypes=\"both\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   useLocalIncludes=\"false\"\n"
    "   docGroupBase=\"GrpSystemState\"\n"
    "   >\n"
    "  See \\ref PageSystemSamplerObjChunk for a description.\n"
    "\n"
    "  A Sampler Object is an OpenGL Object that stores the sampling \n"
    "  parameters for a Texture access inside of a shader.\n"
    "\n"
    "    <Field\n"
    "        name=\"GLId\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "        >\n"
    "        The OpenGL object id for this sampler object.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "\t name=\"textureUnits\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "        The texture units to which to bind the sampler.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"borderColor\"\n"
    "        type=\"Color4f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0,0,0,0\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "\tTexture border color\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"minFilter\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_LINEAR_MIPMAP_LINEAR\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "        potential_values=\"GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_LINEAR\"\n"
    "\t>\n"
    "        The texture minifying function is used whenever the pixel being textured maps\n"
    "        to an area greater than one texture element. Defaults to GL_LINEAR_MIPMAP_LINEAR.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"magFilter\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_LINEAR\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "        potential_values=\"GL_NEAREST, GL_LINEAR\"\n"
    "\t>\n"
    "        he texture magnification function is used when the pixel being textured maps\n"
    "        to an area less than or equal to one texture element. Defaults to GL_LINEAR.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"wrapS\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_REPEAT\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "        potential_values=\"GL_CLAMP, GL_CLAMP_TO_EDGE, GL_REPEAT, GL_CLAMP_TO_BORDER, GL_MIRRORED_REPEAT\"\n"
    "\t>\n"
    "        Texture coordinate S wrapping, default GL_REPEAT.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"wrapT\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_REPEAT\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "        potential_values=\"GL_CLAMP, GL_CLAMP_TO_EDGE, GL_REPEAT, GL_CLAMP_TO_BORDER, GL_MIRRORED_REPEAT\"                \n"
    "\t>\n"
    "        Texture coordinate T wrapping, default GL_REPEAT.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"wrapR\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_REPEAT\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "        potential_values=\"GL_CLAMP, GL_CLAMP_TO_EDGE, GL_REPEAT, GL_CLAMP_TO_BORDER, GL_MIRRORED_REPEAT\"                \n"
    "\t>\n"
    "        Texture coordinate R wrapping, default GL_REPEAT.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"minLOD\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1000.0\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "\tSets the minimum level-of-detail parameter. This floating-point value limits the selection\n"
    "        of highest resolution mipmap (lowest mipmap level). The initial value is -1000.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"maxLOD\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1000.0\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "\tSets the maximum level-of-detail parameter.  This floating-point value limits the selection \n"
    "        of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"LODBias\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.0\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "\tOpenGL computes a texture level-of-detail parameter, called lambda in the GL specification,\n"
    "        that determines which mipmap levels and their relative mipmap weights for use in mipmapped\n"
    "        texture filtering.\n"
    "        This extension provides a means to bias the lambda computation by a constant (signed) value.\n"
    "        This bias can provide a way to blur or pseudo-sharpen OpenGL's standard texture filtering.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"compareMode\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_NONE\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "        potential_values=\"GL_NONE, GL_COMPARE_R_TO_TEXTURE\"\n"
    "\t>\n"
    "    Specifies the texture comparison mode for currently bound depth textures.\n"
    "    That is, a texture whose internal format is GL_DEPTH_COMPONENT_*.\n"
    "    GL_COMPARE_R_TO_TEXTURE : Specifies that the interpolated and clamped r\n"
    "        texture coordinate should be compared to the value in the currently \n"
    "        bound depth texture.\n"
    "    GL_NONE : Specifies that the luminance, intensity, or alpha (as specified \n"
    "        by GL_DEPTH_TEXTURE_MODE) should be assigned the appropriate value \n"
    "        from the currently bound depth texture.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"compareFunc\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_LEQUAL\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "        potential_values=\"GL_LEQUAL, GL_GEQUAL, GL_LESS, GL_GREATER, GL_EQUAL, GL_NOTEQUAL, GL_ALWAYS, GL_NEVER\"\n"
    "\t>\n"
    "    Specifies the comparison operator used when GL_TEXTURE_COMPARE_MODE is\n"
    "    set to GL_COMPARE_R_TO_TEXTURE.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"maxAnisotropy\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.0\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "    Texture mapping using OpenGL's existing mipmap texture filtering modes assumes that the \n"
    "    projection of the pixel filter footprint into texture space is a square (ie, isotropic).\n"
    "    In practice however, the footprint may be long and narrow (ie, anisotropic). Consequently,\n"
    "    mipmap filtering severely blurs images on surfaces angled obliquely away from the viewer.\n"
    "    \n"
    "    The extension permits the OpenGL application to specify on a per-texture object basis the\n"
    "    maximum degree of anisotropy to account for in texture filtering.\n"
    "    </Field>    \n"
    "   \n"
    "</FieldContainer>\n",
    "See \\ref PageSystemSamplerObjChunk for a description.\n"
    "\n"
    "A Sampler Object is an OpenGL Object that stores the sampling \n"
    "parameters for a Texture access inside of a shader.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &SamplerObjChunkBase::getType(void)
{
    return _type;
}

const FieldContainerType &SamplerObjChunkBase::getType(void) const
{
    return _type;
}

UInt32 SamplerObjChunkBase::getContainerSize(void) const
{
    return sizeof(SamplerObjChunk);
}

/*------------------------- decorator get ------------------------------*/


SFGLenum *SamplerObjChunkBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *SamplerObjChunkBase::getSFGLId(void) const
{
    return &_sfGLId;
}


MFUInt32 *SamplerObjChunkBase::editMFTextureUnits(void)
{
    editMField(TextureUnitsFieldMask, _mfTextureUnits);

    return &_mfTextureUnits;
}

const MFUInt32 *SamplerObjChunkBase::getMFTextureUnits(void) const
{
    return &_mfTextureUnits;
}


SFColor4f *SamplerObjChunkBase::editSFBorderColor(void)
{
    editSField(BorderColorFieldMask);

    return &_sfBorderColor;
}

const SFColor4f *SamplerObjChunkBase::getSFBorderColor(void) const
{
    return &_sfBorderColor;
}


SFGLenum *SamplerObjChunkBase::editSFMinFilter(void)
{
    editSField(MinFilterFieldMask);

    return &_sfMinFilter;
}

const SFGLenum *SamplerObjChunkBase::getSFMinFilter(void) const
{
    return &_sfMinFilter;
}


SFGLenum *SamplerObjChunkBase::editSFMagFilter(void)
{
    editSField(MagFilterFieldMask);

    return &_sfMagFilter;
}

const SFGLenum *SamplerObjChunkBase::getSFMagFilter(void) const
{
    return &_sfMagFilter;
}


SFGLenum *SamplerObjChunkBase::editSFWrapS(void)
{
    editSField(WrapSFieldMask);

    return &_sfWrapS;
}

const SFGLenum *SamplerObjChunkBase::getSFWrapS(void) const
{
    return &_sfWrapS;
}


SFGLenum *SamplerObjChunkBase::editSFWrapT(void)
{
    editSField(WrapTFieldMask);

    return &_sfWrapT;
}

const SFGLenum *SamplerObjChunkBase::getSFWrapT(void) const
{
    return &_sfWrapT;
}


SFGLenum *SamplerObjChunkBase::editSFWrapR(void)
{
    editSField(WrapRFieldMask);

    return &_sfWrapR;
}

const SFGLenum *SamplerObjChunkBase::getSFWrapR(void) const
{
    return &_sfWrapR;
}


SFReal32 *SamplerObjChunkBase::editSFMinLOD(void)
{
    editSField(MinLODFieldMask);

    return &_sfMinLOD;
}

const SFReal32 *SamplerObjChunkBase::getSFMinLOD(void) const
{
    return &_sfMinLOD;
}


SFReal32 *SamplerObjChunkBase::editSFMaxLOD(void)
{
    editSField(MaxLODFieldMask);

    return &_sfMaxLOD;
}

const SFReal32 *SamplerObjChunkBase::getSFMaxLOD(void) const
{
    return &_sfMaxLOD;
}


SFReal32 *SamplerObjChunkBase::editSFLODBias(void)
{
    editSField(LODBiasFieldMask);

    return &_sfLODBias;
}

const SFReal32 *SamplerObjChunkBase::getSFLODBias(void) const
{
    return &_sfLODBias;
}


SFGLenum *SamplerObjChunkBase::editSFCompareMode(void)
{
    editSField(CompareModeFieldMask);

    return &_sfCompareMode;
}

const SFGLenum *SamplerObjChunkBase::getSFCompareMode(void) const
{
    return &_sfCompareMode;
}


SFGLenum *SamplerObjChunkBase::editSFCompareFunc(void)
{
    editSField(CompareFuncFieldMask);

    return &_sfCompareFunc;
}

const SFGLenum *SamplerObjChunkBase::getSFCompareFunc(void) const
{
    return &_sfCompareFunc;
}


SFReal32 *SamplerObjChunkBase::editSFMaxAnisotropy(void)
{
    editSField(MaxAnisotropyFieldMask);

    return &_sfMaxAnisotropy;
}

const SFReal32 *SamplerObjChunkBase::getSFMaxAnisotropy(void) const
{
    return &_sfMaxAnisotropy;
}






/*------------------------------ access -----------------------------------*/

SizeT SamplerObjChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }
    if(FieldBits::NoField != (TextureUnitsFieldMask & whichField))
    {
        returnValue += _mfTextureUnits.getBinSize();
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        returnValue += _sfBorderColor.getBinSize();
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }
    if(FieldBits::NoField != (MinLODFieldMask & whichField))
    {
        returnValue += _sfMinLOD.getBinSize();
    }
    if(FieldBits::NoField != (MaxLODFieldMask & whichField))
    {
        returnValue += _sfMaxLOD.getBinSize();
    }
    if(FieldBits::NoField != (LODBiasFieldMask & whichField))
    {
        returnValue += _sfLODBias.getBinSize();
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        returnValue += _sfCompareMode.getBinSize();
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        returnValue += _sfCompareFunc.getBinSize();
    }
    if(FieldBits::NoField != (MaxAnisotropyFieldMask & whichField))
    {
        returnValue += _sfMaxAnisotropy.getBinSize();
    }

    return returnValue;
}

void SamplerObjChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureUnitsFieldMask & whichField))
    {
        _mfTextureUnits.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinLODFieldMask & whichField))
    {
        _sfMinLOD.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaxLODFieldMask & whichField))
    {
        _sfMaxLOD.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LODBiasFieldMask & whichField))
    {
        _sfLODBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaxAnisotropyFieldMask & whichField))
    {
        _sfMaxAnisotropy.copyToBin(pMem);
    }
}

void SamplerObjChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        editSField(GLIdFieldMask);
        _sfGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureUnitsFieldMask & whichField))
    {
        editMField(TextureUnitsFieldMask, _mfTextureUnits);
        _mfTextureUnits.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        editSField(BorderColorFieldMask);
        _sfBorderColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        editSField(MinFilterFieldMask);
        _sfMinFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        editSField(MagFilterFieldMask);
        _sfMagFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        editSField(WrapSFieldMask);
        _sfWrapS.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        editSField(WrapTFieldMask);
        _sfWrapT.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        editSField(WrapRFieldMask);
        _sfWrapR.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinLODFieldMask & whichField))
    {
        editSField(MinLODFieldMask);
        _sfMinLOD.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaxLODFieldMask & whichField))
    {
        editSField(MaxLODFieldMask);
        _sfMaxLOD.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LODBiasFieldMask & whichField))
    {
        editSField(LODBiasFieldMask);
        _sfLODBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        editSField(CompareModeFieldMask);
        _sfCompareMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        editSField(CompareFuncFieldMask);
        _sfCompareFunc.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaxAnisotropyFieldMask & whichField))
    {
        editSField(MaxAnisotropyFieldMask);
        _sfMaxAnisotropy.copyFromBin(pMem);
    }
}

//! create a new instance of the class
SamplerObjChunkTransitPtr SamplerObjChunkBase::createLocal(BitVector bFlags)
{
    SamplerObjChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<SamplerObjChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
SamplerObjChunkTransitPtr SamplerObjChunkBase::createDependent(BitVector bFlags)
{
    SamplerObjChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<SamplerObjChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
SamplerObjChunkTransitPtr SamplerObjChunkBase::create(void)
{
    SamplerObjChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<SamplerObjChunk>(tmpPtr);
    }

    return fc;
}

SamplerObjChunk *SamplerObjChunkBase::createEmptyLocal(BitVector bFlags)
{
    SamplerObjChunk *returnValue;

    newPtr<SamplerObjChunk>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
SamplerObjChunk *SamplerObjChunkBase::createEmpty(void)
{
    SamplerObjChunk *returnValue;

    newPtr<SamplerObjChunk>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr SamplerObjChunkBase::shallowCopyLocal(
    BitVector bFlags) const
{
    SamplerObjChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const SamplerObjChunk *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr SamplerObjChunkBase::shallowCopyDependent(
    BitVector bFlags) const
{
    SamplerObjChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const SamplerObjChunk *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr SamplerObjChunkBase::shallowCopy(void) const
{
    SamplerObjChunk *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const SamplerObjChunk *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

SamplerObjChunkBase::SamplerObjChunkBase(void) :
    Inherited(),
    _sfGLId                   (GLenum(0)),
    _mfTextureUnits           (),
    _sfBorderColor            (Color4f(0,0,0,0)),
    _sfMinFilter              (GLenum(GL_LINEAR_MIPMAP_LINEAR)),
    _sfMagFilter              (GLenum(GL_LINEAR)),
    _sfWrapS                  (GLenum(GL_REPEAT)),
    _sfWrapT                  (GLenum(GL_REPEAT)),
    _sfWrapR                  (GLenum(GL_REPEAT)),
    _sfMinLOD                 (Real32(-1000.0)),
    _sfMaxLOD                 (Real32(1000.0)),
    _sfLODBias                (Real32(0.0)),
    _sfCompareMode            (GLenum(GL_NONE)),
    _sfCompareFunc            (GLenum(GL_LEQUAL)),
    _sfMaxAnisotropy          (Real32(1.0))
{
}

SamplerObjChunkBase::SamplerObjChunkBase(const SamplerObjChunkBase &source) :
    Inherited(source),
    _sfGLId                   (source._sfGLId                   ),
    _mfTextureUnits           (source._mfTextureUnits           ),
    _sfBorderColor            (source._sfBorderColor            ),
    _sfMinFilter              (source._sfMinFilter              ),
    _sfMagFilter              (source._sfMagFilter              ),
    _sfWrapS                  (source._sfWrapS                  ),
    _sfWrapT                  (source._sfWrapT                  ),
    _sfWrapR                  (source._sfWrapR                  ),
    _sfMinLOD                 (source._sfMinLOD                 ),
    _sfMaxLOD                 (source._sfMaxLOD                 ),
    _sfLODBias                (source._sfLODBias                ),
    _sfCompareMode            (source._sfCompareMode            ),
    _sfCompareFunc            (source._sfCompareFunc            ),
    _sfMaxAnisotropy          (source._sfMaxAnisotropy          )
{
}


/*-------------------------- destructors ----------------------------------*/

SamplerObjChunkBase::~SamplerObjChunkBase(void)
{
}


GetFieldHandlePtr SamplerObjChunkBase::getHandleGLId            (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleGLId           (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             this));


    editSField(GLIdFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleTextureUnits    (void) const
{
    MFUInt32::GetHandlePtr returnValue(
        new  MFUInt32::GetHandle(
             &_mfTextureUnits,
             this->getType().getFieldDesc(TextureUnitsFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleTextureUnits   (void)
{
    MFUInt32::EditHandlePtr returnValue(
        new  MFUInt32::EditHandle(
             &_mfTextureUnits,
             this->getType().getFieldDesc(TextureUnitsFieldId),
             this));


    editMField(TextureUnitsFieldMask, _mfTextureUnits);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleBorderColor     (void) const
{
    SFColor4f::GetHandlePtr returnValue(
        new  SFColor4f::GetHandle(
             &_sfBorderColor,
             this->getType().getFieldDesc(BorderColorFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleBorderColor    (void)
{
    SFColor4f::EditHandlePtr returnValue(
        new  SFColor4f::EditHandle(
             &_sfBorderColor,
             this->getType().getFieldDesc(BorderColorFieldId),
             this));


    editSField(BorderColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleMinFilter       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfMinFilter,
             this->getType().getFieldDesc(MinFilterFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleMinFilter      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfMinFilter,
             this->getType().getFieldDesc(MinFilterFieldId),
             this));


    editSField(MinFilterFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleMagFilter       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfMagFilter,
             this->getType().getFieldDesc(MagFilterFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleMagFilter      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfMagFilter,
             this->getType().getFieldDesc(MagFilterFieldId),
             this));


    editSField(MagFilterFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleWrapS           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapS,
             this->getType().getFieldDesc(WrapSFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleWrapS          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapS,
             this->getType().getFieldDesc(WrapSFieldId),
             this));


    editSField(WrapSFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleWrapT           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapT,
             this->getType().getFieldDesc(WrapTFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleWrapT          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapT,
             this->getType().getFieldDesc(WrapTFieldId),
             this));


    editSField(WrapTFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleWrapR           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapR,
             this->getType().getFieldDesc(WrapRFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleWrapR          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapR,
             this->getType().getFieldDesc(WrapRFieldId),
             this));


    editSField(WrapRFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleMinLOD          (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfMinLOD,
             this->getType().getFieldDesc(MinLODFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleMinLOD         (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfMinLOD,
             this->getType().getFieldDesc(MinLODFieldId),
             this));


    editSField(MinLODFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleMaxLOD          (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfMaxLOD,
             this->getType().getFieldDesc(MaxLODFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleMaxLOD         (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfMaxLOD,
             this->getType().getFieldDesc(MaxLODFieldId),
             this));


    editSField(MaxLODFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleLODBias         (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfLODBias,
             this->getType().getFieldDesc(LODBiasFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleLODBias        (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfLODBias,
             this->getType().getFieldDesc(LODBiasFieldId),
             this));


    editSField(LODBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleCompareMode     (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfCompareMode,
             this->getType().getFieldDesc(CompareModeFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleCompareMode    (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfCompareMode,
             this->getType().getFieldDesc(CompareModeFieldId),
             this));


    editSField(CompareModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleCompareFunc     (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfCompareFunc,
             this->getType().getFieldDesc(CompareFuncFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleCompareFunc    (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfCompareFunc,
             this->getType().getFieldDesc(CompareFuncFieldId),
             this));


    editSField(CompareFuncFieldMask);

    return returnValue;
}

GetFieldHandlePtr SamplerObjChunkBase::getHandleMaxAnisotropy   (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfMaxAnisotropy,
             this->getType().getFieldDesc(MaxAnisotropyFieldId),
             const_cast<SamplerObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SamplerObjChunkBase::editHandleMaxAnisotropy  (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfMaxAnisotropy,
             this->getType().getFieldDesc(MaxAnisotropyFieldId),
             this));


    editSField(MaxAnisotropyFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void SamplerObjChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    SamplerObjChunk *pThis = static_cast<SamplerObjChunk *>(this);

    pThis->execSync(static_cast<SamplerObjChunk *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *SamplerObjChunkBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    SamplerObjChunk *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const SamplerObjChunk *>(pRefAspect),
                  dynamic_cast<const SamplerObjChunk *>(this));

    return returnValue;
}
#endif

void SamplerObjChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfTextureUnits.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
