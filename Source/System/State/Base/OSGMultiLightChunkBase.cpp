/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class MultiLightChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"



#include "OSGNode.h"                    // Beacon Class

#include "OSGMultiLightChunkBase.h"
#include "OSGMultiLightChunk.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::MultiLightChunk
    See \ref PageSystemMultiLightChunk for a description.

    This chunk represents a number of lights that are exposed to shader code
    in form of a buffer in OpenGL std430 layout format.
    A shader, binding a shader storage block to the very same binding point, 
    is expected to respect the corresponding block layout. The layout is regulated
    by the feature field of the chunk. If a feature is not set the corresponding struct
    entries are omitted. The feature attribute is protected, but getter and setters for 
    each feature are publicly provided.

    The following features are supported:

    HAS_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX
    This flag determines if the matLSFromWS attribute is part of 
    the shader storage block, i.e. if the "mat4  matLSFromWS;" 
    entry is contained in the shader struct for the Light.

    HAS_WORLD_SPACE_FROM_LIGHT_SPACE_MATRIX
    This flag determines if the matWSFromLS attribute is part of 
    the shader storage block, i.e. if the "mat4  matWSFromLS;" 
    entry is contained in the shader struct for the Light.

    HAS_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX
    This flag determines if the matLSFromES attribute is part of 
    the shader storage block, i.e. if the "mat4  matLSFromES;" 
    entry is contained in the shader struct for the Light.
    Attention: If this flag is set the light shader storage block has to
    be updated with every redraw operation.

    HAS_EYE_SPACE_FROM_LIGHT_SPACE_MATRIX
    This flag determines if the matESFromLS attribute is part of 
    the shader storage block, i.e. if the "mat4  matESFromLS;" 
    entry is contained in the shader struct for the Light.
    Attention: If this flag is set the light shader storage block has to
    be updated with every redraw operation.

    HAS_PROJECTION_MATRIX
    This flag determines if the matProjection attribute is part of 
    the shader storage block, i.e. if the "mat4  matProjection;" 
    entry is contained in the shader struct for the Light.
    Implicitely set the hasProjection flag.

    HAS_INV_PROJECTION_MATRIX
    This flag determines if the matInvProjection attribute is part of 
    the shader storage block, i.e. if the "mat4  matInvProjection;" 
    entry is contained in the shader struct for the Light.
    Implicitely set the hasProjection flag.

    HAS_PROJECTION_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX
    This flag determines if the matProjLSFromWS attribute is part of 
    the shader storage block, i.e. if the "mat4  matProjLSFromWS;" 
    entry is contained in the shader struct for the Light.
    Implicitely set the hasProjection flag.

    HAS_INV_PROJECTION_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX
    This flag determines if the matInvProjLSFromWS attribute is part of 
    the shader storage block, i.e. if the "mat4  matInvProjLSFromWS;" 
    entry is contained in the shader struct for the Light.
    Implicitely set the hasProjection flag.

    HAS_PROJECTION_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX
    This flag determines if the matProjLSFromES attribute is part of 
    the shader storage block, i.e. if the "mat4  matProjLSFromES;" 
    entry is contained in the shader struct for the Light.
    Implicitely set the hasProjection flag.

    HAS_INV_PROJECTION_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX
    This flag determines if the matInvProjLSFromES attribute is part of 
    the shader storage block, i.e. if the "mat4  matInvProjLSFromES;" 
    entry is contained in the shader struct for the Light.
    Implicitely set the hasProjection flag.

    HAS_INTENSITY
    This flag determines if the color intensity attribute is part of the shader storage block, i.e.
    if the "vec3 intensity;" entry is contained in the shader struct for the Light.

    HAS_SEPARATE_INTENSITIES
    This flag determines if the color intensity attributes are part of the shader storage block, i.e.
    if the "vec3  Ia;", "vec3  Id;" and "vec3 Is;" entries are contained in the shader struct for the Light.

    HAS_ATTENUATION
    This flag determines if the attenuation attributes are part of the shader storage block, i.e.
    if the "float constantAttenuation;", "float linearAttenuation;" and "float quadraticAttenuation;"
    entries are contained in the shader struct for the Light.

    HAS_DECAY_ATTENUATION
    This flag determines if the attenuation decay attribute  is also part of the shader storage block, i.e.
    if the "float decayAttenuation" entry is contained in the shader struct for the Light.

    AUTO_CALC_RANGES
    If this flag is active and the lights have attenuations, then the cut on and cut off ranges
    are automatically calculated. They are, however, not provided automatically to the shader.
    For that, you have to set the hasRangeCutOn and hasRangeCutOff flags, respectively.

    HAS_RANGE_CUT_ON
    This flag determines if the rangeCutOn attribute is part of the shader storage block, i.e.
    if the "float rangeCutOn;" entry is contained in the shader struct for the Light.

    HAS_RANGE_CUT_OFF
    This flag determines if the hasRangeCutOff attribute is part of the shader storage block, i.e.
    if the "float hasRangeCutOff;" entry is contained in the shader struct for the Light.

    HAS_RANGE_NEAR_ZONE
    This flag determines if the hasRangeNearZone attribute is part of the shader storage block, i.e.
    if the "float hasRangeNearZone;" entry is contained in the shader struct for the Light.

    HAS_RANGE_FAR_ZONE
    This flag determines if the hasRangeFarZone attribute is part of the shader storage block, i.e.
    if the "float hasRangeFarZone;" entry is contained in the shader struct for the Light.

    HAS_SPOTLIGHT_ANGLE
    This flag determines if the spot light angle attribute is part of the shader storage block, i.e.
    if the "float spotlightAngle;" entry is contained in the shader struct for the Light.
    If neither this flag nor the hasCosSpotlightAngle flag is true, then the hasCosSpotlightAngle 
    flag is treated as if it has value true.

    HAS_COS_SPOTLIGHT_ANGLE
    This flag determines if the cosine spot light angle attribute is part of the shader storage block, i.e.
    if the "float cosSpotlightAngle;" entry is contained in the shader struct for the Light.
    If neither this flag nor the hasSpotlightAngle flag is true, then this flag is treated as if it 
    has value true.

    HAS_SPOTLIGHT_EXPONENT
    This flag determines if the spot expenent attribute is part of the shader storage block, i.e.
    if the "float spotlightExponent;" entry is contained in the shader struct for the Light.

    HAS_SPOTLIGHT_PENUMBRA_ANGLE
    This flag determines if the spot penumbra angle attribute is part of the shader storage block, i.e.
    if the "float cosPenumbraCone;" entry is contained in the shader struct for the Light.

    HAS_SPOTLIGHT_PENUMBRA_FACTOR
    This flag determines if the spot penumbra angle attribute is part of the shader storage block, i.e.
    if the "float cosPenumbraCone;" entry is contained in the shader struct for the Light. This flag
    additionally, determines that the penumbra angle is calculated from the spot light cone angle.

    HAS_SPOTLIGHT_PENUMBRA_FROSTBITE
    This flag determines if the spot light attributes are given in the Frostbite optimized model in the 
    shader storage block, i.e. if the "float spotScale;"  and "float spotOffset;" entries are contained
    in the shader struct for the Light.

    HAS_CINEMA_LIGHT
    This flag determines if the cinema light attributes are part of the shader storage block, i.e.
    if the "float innerSuperEllipsesWidth;", ... entries are contained in the shader struct for the Light.
    If true this flag overrides the hasRangeCutOn, hasRangeCutOff, hasRangeNearZone and hasRangeFarZone
    flags, because cinema lights are described the corresponding attributes.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse

    HAS_SHADOW
    This flag determines if the multi light supports shadowing. Is set to true the boolean
    shadow flag, the shadowIntensity and the shadow index are added to the light struct.

    HAS_GLOBAL_AMBIENT_INTENSITY
    This flag determines if the multi light supports a global ambient light state, i.e. if a vec3 global color
    entry 'ambientLight' exists in the light buffer which is to be added to the single light ambient intensities.

    HAS_LENGTH_FACTOR
    This flag determines if the multi light supports a global length factor light state, i.e. if a float 'lengthFactor'
    exists in the light buffer which is used for distance attenuation calculations.

    HAS_PROJECTION
    This flag determines if the multi light contains a projection matrix for each light, that is whether
    storage is provided for the projection matrix. It does not decide whether a struct entry for the light
    in the shader is generated. For that use the dedicated hasProjectionMatrix, hasInvProjectionMatrix,
    hasProjectionLightSpaceFromWorldSpaceMatrix, hasInvProjectionLightSpaceFromWorldSpaceMatrix,
    hasProjectionLightSpaceFromEyeSpaceMatrix, hasInvProjectionLightSpaceFromEyeSpaceMatrix
    flags. Usage of these, however, implicitely set this hasProjection flag.
    Additionally, the projection matrix is not automatically calculated. That is the duty of the user of the
    chunk. Typically, the multi light shadow stage does take responsibiltiy for the proper calculation and
    setting the projection matrix.

    EYE_SPACE
    The lights position and direction are transformed to eye space before loading into the shader. 
    On default they are provided in world space.

    The following code features are supported:
    CODE_DISTANCE_ATTENUATION_CLASSIC
    The classic OpenGL attenuation function is added to the light code snippet.

    CODE_DISTANCE_ATTENUATION_PHYSICAL
    A physically based attenuation function is added to the light code snippet.

    CODE_DISTANCE_ATTENUATION_DECAY
    A physically based attenuation function is added to the light code snippet.
    An additional decay parameter is used by the function.

    CODE_DISTANCE_ATTENUATION_MIX_PHYSICAL
    A physically based attenuation function is added to the light code snippet that
    also respect the classic OpenGL attenuation parameters.

    CODE_DISTANCE_ATTENUATION_MIX_DECAY
    A physically based attenuation function is added to the light code snippet that
    also respect the classic OpenGL attenuation parameters.
    An additional decay parameter is used by the function.

    CODE_DISTANCE_ATTENUATION_SMOOTH_HERMITE
    An attenuation function based on Hermitian smoothing is added to the light code snippet.

    CODE_SPOT_ATTENUATION_CLASSIC
    The classic OpenGL spot attenuation function is added to the light code snippet.
    This model uses the cosine cutoff angle and the spot exponent parameter.

    CODE_SPOT_ATTENUATION_SMOOTH_HERMITE
    A spot attenuation function based on Hermitian smoothing is added to the light code snippet.
    This model uses the cosine cutoff angle.

    CODE_SPOT_ATTENUATION_SMOOTH_HERMITE_2
    A spot attenuation function based on Hermitian smoothing is added to the light code snippet.
    This model uses the cosine cutoff angle and the cosine penumbra angle.

    CODE_SPOT_ATTENUATION_FROSTBITE
    A spot attenuation function based in accodrance to the Frostbite engine model.
    This optimized model uses a scale factor and an offset value.
    scale  := 1.0f / max (0.001f, (penumbraCos  - coneCos));
    offset := -coneCos * scale;

    Following is the light structure shown that is valid if all layout features are activated. Usually,
    one is working only with a part of these members. Some members are expected to be set by the application
    programmer and some are set by internal machinery of OpenSG.

    struct GlobalLight
    {
    vec3  ambientIntensity;
    }

    struct Light
    {
    mat4  matLSFromWS;
    mat4  matWSFromLS;
    mat4  matLSFromES;
    mat4  matESFromLS;
    mat4  matProjection;
    mat4  matInvProjection;
    mat4  matProjLSFromWS;
    mat4  matInvProjLSFromWS;
    mat4  matProjLSFromES;
    mat4  matInvProjLSFromES;
    vec3  position;
    vec3  direction;
    vec3  ambientIntensity;
    vec3  diffuseIntensity;
    vec3  specularIntensity;
    vec3  intensity;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
    float decayAttenuation;
    float lengthFactor;
    float rangeCutOn;
    float rangeCutOff;
    float rangeNearZone;
    float rangeFarZone;
    float cosSpotlightAngle;
    float tanSpotlightAngle;
    float spotlightAngle;
    float spotlightExponent;
    float spotlightScale;
    float spotlightOffset;
    float cosSpotlightPenumbraAngle;
    float innerSuperEllipsesWidth;
    float innerSuperEllipsesHeight;
    float outerSuperEllipsesWidth;
    float outerSuperEllipsesHeight;
    float superEllipsesRoundness;
    float superEllipsesTwist;
    int   type;
    bool  enabled;
    bool  shadow;
    int   shadowDataIndex;
    int   shadowParameterIndex;
    };

    layout (std430) buffer Lights
    {
    GlobalLight global;
    Light       light[];
    } lights;

    The chunk provides a convenient function that allows to adjust the struct layout
    for standard OpenGL lights 

    struct Light
    {
    vec3  position;
    vec3  direction;
    vec3  ambientIntensity;
    vec3  diffuseIntensity;
    vec3  specularIntensity;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
    float cosSpotlightAngle;
    float spotlightExponent;
    int   type;
    bool  enabled;
    };

    or for simple range lights:

    struct Light
    {
    vec3  position;
    vec3  direction;
    vec3  intensity;
    float rangeCutOff;
    float cosSpotlightAngle;
    int   type;
    bool  enabled;
    };
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var UInt32          MultiLightChunkBase::_sfFeature
    This value determines the set of attributes that the light struct encompasses.
    Some technique classes, e.g. the 'MultiLightShadowTechniqueSimple', automatically
    set some additional features that they need for their proper operation.
    The application programmer is expected to use the special 'getFragmentProgramSnippet()'
    function in order to get a compatible light structure layout for his shader.
    See the shadow examples for illustration.
*/

/*! \var UInt32          MultiLightChunkBase::_sfCodeFeature
    This value determines the set of attributes that governs the code generation
    process for the multi light.
*/

/*! \var Vec3f           MultiLightChunkBase::_sfGlobalAmbientIntensity
    The global ambient light intensity, that is to be added to the single light ambient intensities.
*/

/*! \var Pnt3f           MultiLightChunkBase::_mfPosition
    The light's position for point and spotlights in beacon space.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfDirection
    The light's direction for directional and spotlights in beacon space.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfIntensity
    The light's intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfAmbientIntensity
    The light's ambient intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfDiffuseIntensity
    The light's diffuse intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfSpecularIntensity
    The light's specular intensity.
*/

/*! \var Vec3f           MultiLightChunkBase::_mfAttenuation
    The light's attenuation consiting of the constant, linear and quadratic attenuation parts.
*/

/*! \var Real32          MultiLightChunkBase::_mfDecayAttenuation
    The light's attenuation consiting of the decay parameter.
*/

/*! \var Real32          MultiLightChunkBase::_mfLengthFactor
    All distance attenuation calculation are performed by multiplying the distance with the lengthFactor
    in order to allow adaptation between differing length unit systems.
*/

/*! \var Real32          MultiLightChunkBase::_mfSpotlightAngle
    The spot angle in degree.
*/

/*! \var Real32          MultiLightChunkBase::_mfSpotExponent
    The spotlight parameter. The meaning of this parameter dependes on the following flags:
    HAS_SPOTLIGHT_EXPONENT, HAS_SPOTLIGHT_PENUMBRA_ANGLE or HAS_SPOTLIGHT_PENUMBRA_FACTOR.
    In case of flag HAS_SPOTLIGHT_PENUMBRA_ANGLE the parameter is expected to be
    the spot penumbra angle in dedree. In case of flag HAS_SPOTLIGHT_PENUMBRA_FACTOR
    the parameter is expected to be in the range [0,1] and is used to calculate the
    spot penumbra angle from the spotlightAngle.
*/

/*! \var Real32          MultiLightChunkBase::_mfInnerSuperEllipsesWidth
    The cinema light is described among others by an inner ellipses. This is
    the width of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfInnerSuperEllipsesHeight
    The cinema light is described among others by an inner ellipses. This is
    the height of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfOuterSuperEllipsesWidth
    The cinema light is described among others by an outer ellipses. This is
    the width of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfOuterSuperEllipsesHeight
    The cinema light is described among others by an outer ellipses. This is
    the height of this ellipse.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfSuperEllipsesRoundness
    The cinema light is described among others by a roundness parameter. 
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfSuperEllipsesTwist
    The twist angle in degree by which the superellipses is rotatet in the xy-plane.
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeCutOn
    In the interval rangeCutOn to rangeCutOff the light is active and the
    fragements are lit. Outside is no light. This parameter can be manually
    set or automatically calculated.
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeCutOff
    In the interval rangeCutOn to rangeCutOff the light is active and the
    fragements are lit. Outside is no light. This parameter can be manually
    set or automatically calculated.
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeNearZone
    The cinema light is described among others by a rangeNearZone parameter.
    In the interval rangeCutOn-rangeNearZone to rangeCutOn the lighted fragments are
    partly lit.
    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html
    http://www.yaldex.com/open-gl/ch12lev1sec4.html
    https://en.wikipedia.org/wiki/Superellipse
*/

/*! \var Real32          MultiLightChunkBase::_mfRangeFarZone
    In the interval rangeCutOff to rangeCutOff+rangeFarZone the lighted fragments are
    partly lit.
*/

/*! \var Matrix          MultiLightChunkBase::_mfProjectionMatrix
    The light projection matrix. This is typically calculated newly for each render pass and
    this field allows storage of this calculated matrix. Usally, internally set by OpenSG.
*/

/*! \var UInt8           MultiLightChunkBase::_mfTypeOfLight
    Stores the light's type. This can be any of the set {POINT_LIGHT, DIRECTIONAL_LIGHT, SPOT_LIGHT, CINEMA_LIGHT}.
*/

/*! \var bool            MultiLightChunkBase::_mfEnabled
    The on/off state of the light.
*/

/*! \var bool            MultiLightChunkBase::_mfShadow
    The on/off shadow state of the light.
*/

/*! \var Int32           MultiLightChunkBase::_mfShadowDataIndex
    The index of the light into the shadow data array. The MultiLightShadowStage does provide an additional
    shader storage buffer object for each shadowing light. This index points into this array, allowing
    the shader to access particular runtime information for the shadowing technique at hand.
    This field is internally set by OpenSG. No user setting necessary.
*/

/*! \var Int32           MultiLightChunkBase::_mfShadowParameterIndex
    The index of the light into the shadow parameter array. The MultiLightShadowStage does provide an additional
    shader storage buffer object for the shadowing parameters that each shadowing lights should use. This index 
    points into this array, allowing the shader to access particular runtime information for the shadowing 
    technique at hand. The user adds MultiLightShadowParameter instances to the MultiLightShadowStage stage
    and uses the index of a particular instance for this field.
*/

/*! \var Node *          MultiLightChunkBase::_mfBeacon
    The light's beacon determining its position or direction.
*/

/*! \var bool            MultiLightChunkBase::_sfNormalizeDirection
    The camera last near value.
*/

/*! \var Matrix          MultiLightChunkBase::_mfBeaconMatrix
    The beacon matrices used for the last render pass. Internally set by OpenSG.
*/

/*! \var Real32          MultiLightChunkBase::_sfLastCamNear
    The camera last near value. Internally set by OpenSG.
*/

/*! \var Real32          MultiLightChunkBase::_sfLastCamFar
    The camera last far value. Internally set by OpenSG.
*/

/*! \var Matrix          MultiLightChunkBase::_sfLastCamToWorld
    The camera last to world matrix. Internally set by OpenSG.
*/

/*! \var std::string     MultiLightChunkBase::_sfLightBlockName
    The shader storage buffer block name for the light buffer.
*/

/*! \var std::string     MultiLightChunkBase::_sfLightVariableName
    The shader variable name for the light buffer.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<MultiLightChunk *, nsOSG>::_type(
    "MultiLightChunkPtr", 
    "ShaderStorageBufferObjStdLayoutChunkPtr", 
    MultiLightChunk::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(MultiLightChunk *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           MultiLightChunk *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           MultiLightChunk *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void MultiLightChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "feature",
        "This value determines the set of attributes that the light struct encompasses.\n"
        "Some technique classes, e.g. the 'MultiLightShadowTechniqueSimple', automatically\n"
        "set some additional features that they need for their proper operation.\n"
        "The application programmer is expected to use the special 'getFragmentProgramSnippet()'\n"
        "function in order to get a compatible light structure layout for his shader.\n"
        "See the shadow examples for illustration.\n",
        FeatureFieldId, FeatureFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleFeature),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleFeature));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "codeFeature",
        "This value determines the set of attributes that governs the code generation\n"
        "process for the multi light.\n",
        CodeFeatureFieldId, CodeFeatureFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleCodeFeature),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleCodeFeature));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(),
        "globalAmbientIntensity",
        "The global ambient light intensity, that is to be added to the single light ambient intensities.\n",
        GlobalAmbientIntensityFieldId, GlobalAmbientIntensityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleGlobalAmbientIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleGlobalAmbientIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFPnt3f::Description(
        MFPnt3f::getClassType(),
        "position",
        "The light's position for point and spotlights in beacon space.\n",
        PositionFieldId, PositionFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandlePosition),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandlePosition));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "direction",
        "The light's direction for directional and spotlights in beacon space.\n",
        DirectionFieldId, DirectionFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleDirection),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleDirection));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "intensity",
        "The light's intensity.\n",
        IntensityFieldId, IntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "ambientIntensity",
        "The light's ambient intensity.\n",
        AmbientIntensityFieldId, AmbientIntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleAmbientIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleAmbientIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "diffuseIntensity",
        "The light's diffuse intensity.\n",
        DiffuseIntensityFieldId, DiffuseIntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleDiffuseIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleDiffuseIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "specularIntensity",
        "The light's specular intensity.\n",
        SpecularIntensityFieldId, SpecularIntensityFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSpecularIntensity),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSpecularIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "attenuation",
        "The light's attenuation consiting of the constant, linear and quadratic attenuation parts.\n",
        AttenuationFieldId, AttenuationFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleAttenuation),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleAttenuation));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "decayAttenuation",
        "The light's attenuation consiting of the decay parameter.\n",
        DecayAttenuationFieldId, DecayAttenuationFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleDecayAttenuation),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleDecayAttenuation));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "lengthFactor",
        "All distance attenuation calculation are performed by multiplying the distance with the lengthFactor\n"
        "in order to allow adaptation between differing length unit systems.\n",
        LengthFactorFieldId, LengthFactorFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLengthFactor),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLengthFactor));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "spotlightAngle",
        "The spot angle in degree.\n",
        SpotlightAngleFieldId, SpotlightAngleFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSpotlightAngle),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSpotlightAngle));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "spotExponent",
        "The spotlight parameter. The meaning of this parameter dependes on the following flags:\n"
        "HAS_SPOTLIGHT_EXPONENT, HAS_SPOTLIGHT_PENUMBRA_ANGLE or HAS_SPOTLIGHT_PENUMBRA_FACTOR.\n"
        "In case of flag HAS_SPOTLIGHT_PENUMBRA_ANGLE the parameter is expected to be\n"
        "the spot penumbra angle in dedree. In case of flag HAS_SPOTLIGHT_PENUMBRA_FACTOR\n"
        "the parameter is expected to be in the range [0,1] and is used to calculate the\n"
        "spot penumbra angle from the spotlightAngle.\n",
        SpotExponentFieldId, SpotExponentFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSpotExponent),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSpotExponent));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "innerSuperEllipsesWidth",
        "The cinema light is described among others by an inner ellipses. This is\n"
        "the width of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        InnerSuperEllipsesWidthFieldId, InnerSuperEllipsesWidthFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleInnerSuperEllipsesWidth),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleInnerSuperEllipsesWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "innerSuperEllipsesHeight",
        "The cinema light is described among others by an inner ellipses. This is\n"
        "the height of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        InnerSuperEllipsesHeightFieldId, InnerSuperEllipsesHeightFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleInnerSuperEllipsesHeight),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleInnerSuperEllipsesHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "outerSuperEllipsesWidth",
        "The cinema light is described among others by an outer ellipses. This is\n"
        "the width of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        OuterSuperEllipsesWidthFieldId, OuterSuperEllipsesWidthFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleOuterSuperEllipsesWidth),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleOuterSuperEllipsesWidth));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "outerSuperEllipsesHeight",
        "The cinema light is described among others by an outer ellipses. This is\n"
        "the height of this ellipse.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        OuterSuperEllipsesHeightFieldId, OuterSuperEllipsesHeightFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleOuterSuperEllipsesHeight),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleOuterSuperEllipsesHeight));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "superEllipsesRoundness",
        "The cinema light is described among others by a roundness parameter. \n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        SuperEllipsesRoundnessFieldId, SuperEllipsesRoundnessFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSuperEllipsesRoundness),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSuperEllipsesRoundness));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "superEllipsesTwist",
        "The twist angle in degree by which the superellipses is rotatet in the xy-plane.\n",
        SuperEllipsesTwistFieldId, SuperEllipsesTwistFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleSuperEllipsesTwist),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleSuperEllipsesTwist));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeCutOn",
        "In the interval rangeCutOn to rangeCutOff the light is active and the\n"
        "fragements are lit. Outside is no light. This parameter can be manually\n"
        "set or automatically calculated.\n",
        RangeCutOnFieldId, RangeCutOnFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeCutOn),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeCutOn));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeCutOff",
        "In the interval rangeCutOn to rangeCutOff the light is active and the\n"
        "fragements are lit. Outside is no light. This parameter can be manually\n"
        "set or automatically calculated.\n",
        RangeCutOffFieldId, RangeCutOffFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeCutOff),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeCutOff));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeNearZone",
        "The cinema light is described among others by a rangeNearZone parameter.\n"
        "In the interval rangeCutOn-rangeNearZone to rangeCutOn the lighted fragments are\n"
        "partly lit.\n"
        "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
        "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
        "https://en.wikipedia.org/wiki/Superellipse\n",
        RangeNearZoneFieldId, RangeNearZoneFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeNearZone),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeNearZone));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "rangeFarZone",
        "In the interval rangeCutOff to rangeCutOff+rangeFarZone the lighted fragments are\n"
        "partly lit.\n",
        RangeFarZoneFieldId, RangeFarZoneFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleRangeFarZone),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleRangeFarZone));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMatrix::Description(
        MFMatrix::getClassType(),
        "projectionMatrix",
        "The light projection matrix. This is typically calculated newly for each render pass and\n"
        "this field allows storage of this calculated matrix. Usally, internally set by OpenSG.\n",
        ProjectionMatrixFieldId, ProjectionMatrixFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleProjectionMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleProjectionMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(),
        "typeOfLight",
        "Stores the light's type. This can be any of the set {POINT_LIGHT, DIRECTIONAL_LIGHT, SPOT_LIGHT, CINEMA_LIGHT}.\n",
        TypeOfLightFieldId, TypeOfLightFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleTypeOfLight),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleTypeOfLight));

    oType.addInitialDesc(pDesc);

    pDesc = new MFBool::Description(
        MFBool::getClassType(),
        "enabled",
        "The on/off state of the light.\n",
        EnabledFieldId, EnabledFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleEnabled),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleEnabled));

    oType.addInitialDesc(pDesc);

    pDesc = new MFBool::Description(
        MFBool::getClassType(),
        "shadow",
        "The on/off shadow state of the light.\n",
        ShadowFieldId, ShadowFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleShadow),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleShadow));

    oType.addInitialDesc(pDesc);

    pDesc = new MFInt32::Description(
        MFInt32::getClassType(),
        "shadowDataIndex",
        "The index of the light into the shadow data array. The MultiLightShadowStage does provide an additional\n"
        "shader storage buffer object for each shadowing light. This index points into this array, allowing\n"
        "the shader to access particular runtime information for the shadowing technique at hand.\n"
        "This field is internally set by OpenSG. No user setting necessary.\n",
        ShadowDataIndexFieldId, ShadowDataIndexFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleShadowDataIndex),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleShadowDataIndex));

    oType.addInitialDesc(pDesc);

    pDesc = new MFInt32::Description(
        MFInt32::getClassType(),
        "shadowParameterIndex",
        "The index of the light into the shadow parameter array. The MultiLightShadowStage does provide an additional\n"
        "shader storage buffer object for the shadowing parameters that each shadowing lights should use. This index \n"
        "points into this array, allowing the shader to access particular runtime information for the shadowing \n"
        "technique at hand. The user adds MultiLightShadowParameter instances to the MultiLightShadowStage stage\n"
        "and uses the index of a particular instance for this field.\n",
        ShadowParameterIndexFieldId, ShadowParameterIndexFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleShadowParameterIndex),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleShadowParameterIndex));

    oType.addInitialDesc(pDesc);

    pDesc = new MFWeakNodePtr::Description(
        MFWeakNodePtr::getClassType(),
        "beacon",
        "The light's beacon determining its position or direction.\n",
        BeaconFieldId, BeaconFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleBeacon),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleBeacon));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "normalizeDirection",
        "The camera last near value.\n",
        NormalizeDirectionFieldId, NormalizeDirectionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleNormalizeDirection),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleNormalizeDirection));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMatrix::Description(
        MFMatrix::getClassType(),
        "beaconMatrix",
        "The beacon matrices used for the last render pass. Internally set by OpenSG.\n",
        BeaconMatrixFieldId, BeaconMatrixFieldMask,
        true,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleBeaconMatrix),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleBeaconMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "lastCamNear",
        "The camera last near value. Internally set by OpenSG.\n",
        LastCamNearFieldId, LastCamNearFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLastCamNear),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLastCamNear));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "lastCamFar",
        "The camera last far value. Internally set by OpenSG.\n",
        LastCamFarFieldId, LastCamFarFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLastCamFar),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLastCamFar));

    oType.addInitialDesc(pDesc);

    pDesc = new SFMatrix::Description(
        SFMatrix::getClassType(),
        "lastCamToWorld",
        "The camera last to world matrix. Internally set by OpenSG.\n",
        LastCamToWorldFieldId, LastCamToWorldFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLastCamToWorld),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLastCamToWorld));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "LightBlockName",
        "The shader storage buffer block name for the light buffer.\n",
        LightBlockNameFieldId, LightBlockNameFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLightBlockName),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLightBlockName));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "LightVariableName",
        "The shader variable name for the light buffer.\n",
        LightVariableNameFieldId, LightVariableNameFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MultiLightChunk::editHandleLightVariableName),
        static_cast<FieldGetMethodSig >(&MultiLightChunk::getHandleLightVariableName));

    oType.addInitialDesc(pDesc);
}


MultiLightChunkBase::TypeObject MultiLightChunkBase::_type(
    MultiLightChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&MultiLightChunkBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&MultiLightChunk::initMethod),
    reinterpret_cast<ExitContainerF>(&MultiLightChunk::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&MultiLightChunk::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"MultiLightChunk\"\n"
    "    parent=\"ShaderStorageBufferObjStdLayoutChunk\"\n"
    "    library=\"System\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    docGroupBase=\"GrpSystemState\"\n"
    ">\n"
    "See \\ref PageSystemMultiLightChunk for a description.\n"
    "\n"
    "This chunk represents a number of lights that are exposed to shader code\n"
    "in form of a buffer in OpenGL std430 layout format.\n"
    "A shader, binding a shader storage block to the very same binding point, \n"
    "is expected to respect the corresponding block layout. The layout is regulated\n"
    "by the feature field of the chunk. If a feature is not set the corresponding struct\n"
    "entries are omitted. The feature attribute is protected, but getter and setters for \n"
    "each feature are publicly provided.\n"
    "\n"
    "The following features are supported:\n"
    "\n"
    "    HAS_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX\n"
    "        This flag determines if the matLSFromWS attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matLSFromWS;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_WORLD_SPACE_FROM_LIGHT_SPACE_MATRIX\n"
    "        This flag determines if the matWSFromLS attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matWSFromLS;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX\n"
    "        This flag determines if the matLSFromES attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matLSFromES;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Attention: If this flag is set the light shader storage block has to\n"
    "        be updated with every redraw operation.\n"
    "\n"
    "    HAS_EYE_SPACE_FROM_LIGHT_SPACE_MATRIX\n"
    "        This flag determines if the matESFromLS attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matESFromLS;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Attention: If this flag is set the light shader storage block has to\n"
    "        be updated with every redraw operation.\n"
    "\n"
    "    HAS_PROJECTION_MATRIX\n"
    "        This flag determines if the matProjection attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matProjection;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Implicitely set the hasProjection flag.\n"
    "\n"
    "    HAS_INV_PROJECTION_MATRIX\n"
    "        This flag determines if the matInvProjection attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matInvProjection;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Implicitely set the hasProjection flag.\n"
    "\n"
    "    HAS_PROJECTION_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX\n"
    "        This flag determines if the matProjLSFromWS attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matProjLSFromWS;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Implicitely set the hasProjection flag.\n"
    "\n"
    "    HAS_INV_PROJECTION_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX\n"
    "        This flag determines if the matInvProjLSFromWS attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matInvProjLSFromWS;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Implicitely set the hasProjection flag.\n"
    "\n"
    "    HAS_PROJECTION_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX\n"
    "        This flag determines if the matProjLSFromES attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matProjLSFromES;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Implicitely set the hasProjection flag.\n"
    "\n"
    "    HAS_INV_PROJECTION_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX\n"
    "        This flag determines if the matInvProjLSFromES attribute is part of \n"
    "        the shader storage block, i.e. if the \"mat4  matInvProjLSFromES;\" \n"
    "        entry is contained in the shader struct for the Light.\n"
    "        Implicitely set the hasProjection flag.\n"
    "\n"
    "    HAS_INTENSITY\n"
    "        This flag determines if the color intensity attribute is part of the shader storage block, i.e.\n"
    "        if the \"vec3 intensity;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_SEPARATE_INTENSITIES\n"
    "        This flag determines if the color intensity attributes are part of the shader storage block, i.e.\n"
    "        if the \"vec3  Ia;\", \"vec3  Id;\" and \"vec3 Is;\" entries are contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_ATTENUATION\n"
    "        This flag determines if the attenuation attributes are part of the shader storage block, i.e.\n"
    "        if the \"float constantAttenuation;\", \"float linearAttenuation;\" and \"float quadraticAttenuation;\"\n"
    "        entries are contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_DECAY_ATTENUATION\n"
    "        This flag determines if the attenuation decay attribute  is also part of the shader storage block, i.e.\n"
    "        if the \"float decayAttenuation\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    AUTO_CALC_RANGES\n"
    "        If this flag is active and the lights have attenuations, then the cut on and cut off ranges\n"
    "        are automatically calculated. They are, however, not provided automatically to the shader.\n"
    "        For that, you have to set the hasRangeCutOn and hasRangeCutOff flags, respectively.\n"
    "\n"
    "    HAS_RANGE_CUT_ON\n"
    "        This flag determines if the rangeCutOn attribute is part of the shader storage block, i.e.\n"
    "        if the \"float rangeCutOn;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_RANGE_CUT_OFF\n"
    "        This flag determines if the hasRangeCutOff attribute is part of the shader storage block, i.e.\n"
    "        if the \"float hasRangeCutOff;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_RANGE_NEAR_ZONE\n"
    "        This flag determines if the hasRangeNearZone attribute is part of the shader storage block, i.e.\n"
    "        if the \"float hasRangeNearZone;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_RANGE_FAR_ZONE\n"
    "        This flag determines if the hasRangeFarZone attribute is part of the shader storage block, i.e.\n"
    "        if the \"float hasRangeFarZone;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_SPOTLIGHT_ANGLE\n"
    "        This flag determines if the spot light angle attribute is part of the shader storage block, i.e.\n"
    "        if the \"float spotlightAngle;\" entry is contained in the shader struct for the Light.\n"
    "        If neither this flag nor the hasCosSpotlightAngle flag is true, then the hasCosSpotlightAngle \n"
    "        flag is treated as if it has value true.\n"
    "\n"
    "    HAS_COS_SPOTLIGHT_ANGLE\n"
    "        This flag determines if the cosine spot light angle attribute is part of the shader storage block, i.e.\n"
    "        if the \"float cosSpotlightAngle;\" entry is contained in the shader struct for the Light.\n"
    "        If neither this flag nor the hasSpotlightAngle flag is true, then this flag is treated as if it \n"
    "        has value true.\n"
    "\n"
    "    HAS_SPOTLIGHT_EXPONENT\n"
    "        This flag determines if the spot expenent attribute is part of the shader storage block, i.e.\n"
    "        if the \"float spotlightExponent;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_SPOTLIGHT_PENUMBRA_ANGLE\n"
    "        This flag determines if the spot penumbra angle attribute is part of the shader storage block, i.e.\n"
    "        if the \"float cosPenumbraCone;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "    HAS_SPOTLIGHT_PENUMBRA_FACTOR\n"
    "        This flag determines if the spot penumbra angle attribute is part of the shader storage block, i.e.\n"
    "        if the \"float cosPenumbraCone;\" entry is contained in the shader struct for the Light. This flag\n"
    "        additionally, determines that the penumbra angle is calculated from the spot light cone angle.\n"
    "\n"
    "    HAS_SPOTLIGHT_PENUMBRA_FROSTBITE\n"
    "        This flag determines if the spot light attributes are given in the Frostbite optimized model in the \n"
    "        shader storage block, i.e. if the \"float spotScale;\"  and \"float spotOffset;\" entries are contained\n"
    "        in the shader struct for the Light.\n"
    "\n"
    "    HAS_CINEMA_LIGHT\n"
    "        This flag determines if the cinema light attributes are part of the shader storage block, i.e.\n"
    "        if the \"float innerSuperEllipsesWidth;\", ... entries are contained in the shader struct for the Light.\n"
    "        If true this flag overrides the hasRangeCutOn, hasRangeCutOff, hasRangeNearZone and hasRangeFarZone\n"
    "        flags, because cinema lights are described the corresponding attributes.\n"
    "        See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "             http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "             https://en.wikipedia.org/wiki/Superellipse\n"
    "\n"
    "    HAS_SHADOW\n"
    "        This flag determines if the multi light supports shadowing. Is set to true the boolean\n"
    "        shadow flag, the shadowIntensity and the shadow index are added to the light struct.\n"
    "\n"
    "    HAS_GLOBAL_AMBIENT_INTENSITY\n"
    "        This flag determines if the multi light supports a global ambient light state, i.e. if a vec3 global color\n"
    "        entry 'ambientLight' exists in the light buffer which is to be added to the single light ambient intensities.\n"
    "\n"
    "    HAS_LENGTH_FACTOR\n"
    "        This flag determines if the multi light supports a global length factor light state, i.e. if a float 'lengthFactor'\n"
    "        exists in the light buffer which is used for distance attenuation calculations.\n"
    "        \n"
    "    HAS_PROJECTION\n"
    "        This flag determines if the multi light contains a projection matrix for each light, that is whether\n"
    "        storage is provided for the projection matrix. It does not decide whether a struct entry for the light\n"
    "        in the shader is generated. For that use the dedicated hasProjectionMatrix, hasInvProjectionMatrix,\n"
    "        hasProjectionLightSpaceFromWorldSpaceMatrix, hasInvProjectionLightSpaceFromWorldSpaceMatrix,\n"
    "        hasProjectionLightSpaceFromEyeSpaceMatrix, hasInvProjectionLightSpaceFromEyeSpaceMatrix\n"
    "        flags. Usage of these, however, implicitely set this hasProjection flag.\n"
    "        Additionally, the projection matrix is not automatically calculated. That is the duty of the user of the\n"
    "        chunk. Typically, the multi light shadow stage does take responsibiltiy for the proper calculation and\n"
    "        setting the projection matrix.\n"
    "\n"
    "    EYE_SPACE\n"
    "        The lights position and direction are transformed to eye space before loading into the shader. \n"
    "        On default they are provided in world space.\n"
    "\n"
    "    The following code features are supported:\n"
    "        CODE_DISTANCE_ATTENUATION_CLASSIC\n"
    "            The classic OpenGL attenuation function is added to the light code snippet.\n"
    "\n"
    "        CODE_DISTANCE_ATTENUATION_PHYSICAL\n"
    "            A physically based attenuation function is added to the light code snippet.\n"
    "\n"
    "        CODE_DISTANCE_ATTENUATION_DECAY\n"
    "            A physically based attenuation function is added to the light code snippet.\n"
    "            An additional decay parameter is used by the function.\n"
    "\n"
    "        CODE_DISTANCE_ATTENUATION_MIX_PHYSICAL\n"
    "            A physically based attenuation function is added to the light code snippet that\n"
    "            also respect the classic OpenGL attenuation parameters.\n"
    "\n"
    "        CODE_DISTANCE_ATTENUATION_MIX_DECAY\n"
    "            A physically based attenuation function is added to the light code snippet that\n"
    "            also respect the classic OpenGL attenuation parameters.\n"
    "            An additional decay parameter is used by the function.\n"
    "\n"
    "        CODE_DISTANCE_ATTENUATION_SMOOTH_HERMITE\n"
    "            An attenuation function based on Hermitian smoothing is added to the light code snippet.\n"
    "\n"
    "        CODE_SPOT_ATTENUATION_CLASSIC\n"
    "            The classic OpenGL spot attenuation function is added to the light code snippet.\n"
    "            This model uses the cosine cutoff angle and the spot exponent parameter.\n"
    "\n"
    "        CODE_SPOT_ATTENUATION_SMOOTH_HERMITE\n"
    "            A spot attenuation function based on Hermitian smoothing is added to the light code snippet.\n"
    "            This model uses the cosine cutoff angle.\n"
    "\n"
    "        CODE_SPOT_ATTENUATION_SMOOTH_HERMITE_2\n"
    "            A spot attenuation function based on Hermitian smoothing is added to the light code snippet.\n"
    "            This model uses the cosine cutoff angle and the cosine penumbra angle.\n"
    "\n"
    "        CODE_SPOT_ATTENUATION_FROSTBITE\n"
    "            A spot attenuation function based in accodrance to the Frostbite engine model.\n"
    "            This optimized model uses a scale factor and an offset value.\n"
    "                scale  := 1.0f / max (0.001f, (penumbraCos  - coneCos));\n"
    "                offset := -coneCos * scale;\n"
    "\n"
    "    Following is the light structure shown that is valid if all layout features are activated. Usually,\n"
    "    one is working only with a part of these members. Some members are expected to be set by the application\n"
    "    programmer and some are set by internal machinery of OpenSG.\n"
    "\n"
    "    struct GlobalLight\n"
    "    {\n"
    "        vec3  ambientIntensity;\n"
    "    }\n"
    "\n"
    "    struct Light\n"
    "    {\n"
    "        mat4  matLSFromWS;\n"
    "        mat4  matWSFromLS;\n"
    "        mat4  matLSFromES;\n"
    "        mat4  matESFromLS;\n"
    "        mat4  matProjection;\n"
    "        mat4  matInvProjection;\n"
    "        mat4  matProjLSFromWS;\n"
    "        mat4  matInvProjLSFromWS;\n"
    "        mat4  matProjLSFromES;\n"
    "        mat4  matInvProjLSFromES;\n"
    "        vec3  position;\n"
    "        vec3  direction;\n"
    "        vec3  ambientIntensity;\n"
    "        vec3  diffuseIntensity;\n"
    "        vec3  specularIntensity;\n"
    "        vec3  intensity;\n"
    "        float constantAttenuation;\n"
    "        float linearAttenuation;\n"
    "        float quadraticAttenuation;\n"
    "        float decayAttenuation;\n"
    "        float lengthFactor;\n"
    "        float rangeCutOn;\n"
    "        float rangeCutOff;\n"
    "        float rangeNearZone;\n"
    "        float rangeFarZone;\n"
    "        float cosSpotlightAngle;\n"
    "        float tanSpotlightAngle;\n"
    "        float spotlightAngle;\n"
    "        float spotlightExponent;\n"
    "        float spotlightScale;\n"
    "        float spotlightOffset;\n"
    "        float cosSpotlightPenumbraAngle;\n"
    "        float innerSuperEllipsesWidth;\n"
    "        float innerSuperEllipsesHeight;\n"
    "        float outerSuperEllipsesWidth;\n"
    "        float outerSuperEllipsesHeight;\n"
    "        float superEllipsesRoundness;\n"
    "        float superEllipsesTwist;\n"
    "        int   type;\n"
    "        bool  enabled;\n"
    "        bool  shadow;\n"
    "        int   shadowDataIndex;\n"
    "        int   shadowParameterIndex;\n"
    "    };\n"
    "\n"
    "    layout (std430) buffer Lights\n"
    "    {\n"
    "        GlobalLight global;\n"
    "        Light       light[];\n"
    "    } lights;\n"
    "\n"
    "The chunk provides a convenient function that allows to adjust the struct layout\n"
    "for standard OpenGL lights \n"
    "\n"
    "    struct Light\n"
    "    {\n"
    "        vec3  position;\n"
    "        vec3  direction;\n"
    "        vec3  ambientIntensity;\n"
    "        vec3  diffuseIntensity;\n"
    "        vec3  specularIntensity;\n"
    "        float constantAttenuation;\n"
    "        float linearAttenuation;\n"
    "        float quadraticAttenuation;\n"
    "        float cosSpotlightAngle;\n"
    "        float spotlightExponent;\n"
    "        int   type;\n"
    "        bool  enabled;\n"
    "    };\n"
    "\n"
    "or for simple range lights:\n"
    "\n"
    "    struct Light\n"
    "    {\n"
    "        vec3  position;\n"
    "        vec3  direction;\n"
    "        vec3  intensity;\n"
    "        float rangeCutOff;\n"
    "        float cosSpotlightAngle;\n"
    "        int   type;\n"
    "        bool  enabled;\n"
    "    };\n"
    "\n"
    "    <Field\n"
    "        name=\"feature\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0\"\n"
    "    >\n"
    "        This value determines the set of attributes that the light struct encompasses.\n"
    "        Some technique classes, e.g. the 'MultiLightShadowTechniqueSimple', automatically\n"
    "        set some additional features that they need for their proper operation.\n"
    "        The application programmer is expected to use the special 'getFragmentProgramSnippet()'\n"
    "        function in order to get a compatible light structure layout for his shader.\n"
    "        See the shadow examples for illustration.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"codeFeature\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0\"\n"
    "    >\n"
    "        This value determines the set of attributes that governs the code generation\n"
    "        process for the multi light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"globalAmbientIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"Vec3f(0,0,0)\"\n"
    "    >\n"
    "    The global ambient light intensity, that is to be added to the single light ambient intensities.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"position\"\n"
    "        type=\"Pnt3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        The light's position for point and spotlights in beacon space.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"direction\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's direction for directional and spotlights in beacon space.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"intensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"ambientIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's ambient intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"diffuseIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's diffuse intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"specularIntensity\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's specular intensity.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"attenuation\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's attenuation consiting of the constant, linear and quadratic attenuation parts.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"decayAttenuation\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's attenuation consiting of the decay parameter.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lengthFactor\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    All distance attenuation calculation are performed by multiplying the distance with the lengthFactor\n"
    "    in order to allow adaptation between differing length unit systems.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"spotlightAngle\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The spot angle in degree.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"spotExponent\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The spotlight parameter. The meaning of this parameter dependes on the following flags:\n"
    "    HAS_SPOTLIGHT_EXPONENT, HAS_SPOTLIGHT_PENUMBRA_ANGLE or HAS_SPOTLIGHT_PENUMBRA_FACTOR.\n"
    "    In case of flag HAS_SPOTLIGHT_PENUMBRA_ANGLE the parameter is expected to be\n"
    "    the spot penumbra angle in dedree. In case of flag HAS_SPOTLIGHT_PENUMBRA_FACTOR\n"
    "    the parameter is expected to be in the range [0,1] and is used to calculate the\n"
    "    spot penumbra angle from the spotlightAngle.\n"
    "   \n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"innerSuperEllipsesWidth\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an inner ellipses. This is\n"
    "    the width of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"innerSuperEllipsesHeight\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an inner ellipses. This is\n"
    "    the height of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"outerSuperEllipsesWidth\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an outer ellipses. This is\n"
    "    the width of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"outerSuperEllipsesHeight\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by an outer ellipses. This is\n"
    "    the height of this ellipse.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"superEllipsesRoundness\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by a roundness parameter. \n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"superEllipsesTwist\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The twist angle in degree by which the superellipses is rotatet in the xy-plane.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeCutOn\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    In the interval rangeCutOn to rangeCutOff the light is active and the\n"
    "    fragements are lit. Outside is no light. This parameter can be manually\n"
    "    set or automatically calculated.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeCutOff\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    In the interval rangeCutOn to rangeCutOff the light is active and the\n"
    "    fragements are lit. Outside is no light. This parameter can be manually\n"
    "    set or automatically calculated.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeNearZone\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The cinema light is described among others by a rangeNearZone parameter.\n"
    "    In the interval rangeCutOn-rangeNearZone to rangeCutOn the lighted fragments are\n"
    "    partly lit.\n"
    "    See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "         http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "         https://en.wikipedia.org/wiki/Superellipse\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"rangeFarZone\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    In the interval rangeCutOff to rangeCutOff+rangeFarZone the lighted fragments are\n"
    "    partly lit.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"projectionMatrix\"\n"
    "        type=\"Matrix\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light projection matrix. This is typically calculated newly for each render pass and\n"
    "    this field allows storage of this calculated matrix. Usally, internally set by OpenSG.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"typeOfLight\"\n"
    "        type=\"UInt8\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    Stores the light's type. This can be any of the set {POINT_LIGHT, DIRECTIONAL_LIGHT, SPOT_LIGHT, CINEMA_LIGHT}.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"enabled\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The on/off state of the light.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"shadow\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The on/off shadow state of the light.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"shadowDataIndex\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The index of the light into the shadow data array. The MultiLightShadowStage does provide an additional\n"
    "    shader storage buffer object for each shadowing light. This index points into this array, allowing\n"
    "    the shader to access particular runtime information for the shadowing technique at hand.\n"
    "    This field is internally set by OpenSG. No user setting necessary.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"shadowParameterIndex\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The index of the light into the shadow parameter array. The MultiLightShadowStage does provide an additional\n"
    "    shader storage buffer object for the shadowing parameters that each shadowing lights should use. This index \n"
    "    points into this array, allowing the shader to access particular runtime information for the shadowing \n"
    "    technique at hand. The user adds MultiLightShadowParameter instances to the MultiLightShadowStage stage\n"
    "    and uses the index of a particular instance for this field.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"beacon\"\n"
    "        type=\"Node\"\n"
    "        category=\"weakpointer\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The light's beacon determining its position or direction.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"normalizeDirection\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "    >\n"
    "    The camera last near value.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"beaconMatrix\"\n"
    "        type=\"Matrix\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The beacon matrices used for the last render pass. Internally set by OpenSG.\n"
    "    </Field>\n"
    "\n"
    "\n"
    "    <Field\n"
    "        name=\"lastCamNear\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0.f\"\n"
    "    >\n"
    "    The camera last near value. Internally set by OpenSG.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lastCamFar\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0.f\"\n"
    "    >\n"
    "    The camera last far value. Internally set by OpenSG.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lastCamToWorld\"\n"
    "        type=\"Matrix\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"protected\"\n"
    "    >\n"
    "    The camera last to world matrix. Internally set by OpenSG.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"LightBlockName\"\n"
    "        type=\"std::string\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue='\"Lights\"'\n"
    "    >\n"
    "    The shader storage buffer block name for the light buffer.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"LightVariableName\"\n"
    "        type=\"std::string\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue='\"lights\"'\n"
    "    >\n"
    "    The shader variable name for the light buffer.\n"
    "    </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "See \\ref PageSystemMultiLightChunk for a description.\n"
    "\n"
    "This chunk represents a number of lights that are exposed to shader code\n"
    "in form of a buffer in OpenGL std430 layout format.\n"
    "A shader, binding a shader storage block to the very same binding point, \n"
    "is expected to respect the corresponding block layout. The layout is regulated\n"
    "by the feature field of the chunk. If a feature is not set the corresponding struct\n"
    "entries are omitted. The feature attribute is protected, but getter and setters for \n"
    "each feature are publicly provided.\n"
    "\n"
    "The following features are supported:\n"
    "\n"
    "HAS_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX\n"
    "This flag determines if the matLSFromWS attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matLSFromWS;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_WORLD_SPACE_FROM_LIGHT_SPACE_MATRIX\n"
    "This flag determines if the matWSFromLS attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matWSFromLS;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX\n"
    "This flag determines if the matLSFromES attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matLSFromES;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Attention: If this flag is set the light shader storage block has to\n"
    "be updated with every redraw operation.\n"
    "\n"
    "HAS_EYE_SPACE_FROM_LIGHT_SPACE_MATRIX\n"
    "This flag determines if the matESFromLS attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matESFromLS;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Attention: If this flag is set the light shader storage block has to\n"
    "be updated with every redraw operation.\n"
    "\n"
    "HAS_PROJECTION_MATRIX\n"
    "This flag determines if the matProjection attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matProjection;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Implicitely set the hasProjection flag.\n"
    "\n"
    "HAS_INV_PROJECTION_MATRIX\n"
    "This flag determines if the matInvProjection attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matInvProjection;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Implicitely set the hasProjection flag.\n"
    "\n"
    "HAS_PROJECTION_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX\n"
    "This flag determines if the matProjLSFromWS attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matProjLSFromWS;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Implicitely set the hasProjection flag.\n"
    "\n"
    "HAS_INV_PROJECTION_LIGHT_SPACE_FROM_WORLD_SPACE_MATRIX\n"
    "This flag determines if the matInvProjLSFromWS attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matInvProjLSFromWS;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Implicitely set the hasProjection flag.\n"
    "\n"
    "HAS_PROJECTION_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX\n"
    "This flag determines if the matProjLSFromES attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matProjLSFromES;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Implicitely set the hasProjection flag.\n"
    "\n"
    "HAS_INV_PROJECTION_LIGHT_SPACE_FROM_EYE_SPACE_MATRIX\n"
    "This flag determines if the matInvProjLSFromES attribute is part of \n"
    "the shader storage block, i.e. if the \"mat4  matInvProjLSFromES;\" \n"
    "entry is contained in the shader struct for the Light.\n"
    "Implicitely set the hasProjection flag.\n"
    "\n"
    "HAS_INTENSITY\n"
    "This flag determines if the color intensity attribute is part of the shader storage block, i.e.\n"
    "if the \"vec3 intensity;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_SEPARATE_INTENSITIES\n"
    "This flag determines if the color intensity attributes are part of the shader storage block, i.e.\n"
    "if the \"vec3  Ia;\", \"vec3  Id;\" and \"vec3 Is;\" entries are contained in the shader struct for the Light.\n"
    "\n"
    "HAS_ATTENUATION\n"
    "This flag determines if the attenuation attributes are part of the shader storage block, i.e.\n"
    "if the \"float constantAttenuation;\", \"float linearAttenuation;\" and \"float quadraticAttenuation;\"\n"
    "entries are contained in the shader struct for the Light.\n"
    "\n"
    "HAS_DECAY_ATTENUATION\n"
    "This flag determines if the attenuation decay attribute  is also part of the shader storage block, i.e.\n"
    "if the \"float decayAttenuation\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "AUTO_CALC_RANGES\n"
    "If this flag is active and the lights have attenuations, then the cut on and cut off ranges\n"
    "are automatically calculated. They are, however, not provided automatically to the shader.\n"
    "For that, you have to set the hasRangeCutOn and hasRangeCutOff flags, respectively.\n"
    "\n"
    "HAS_RANGE_CUT_ON\n"
    "This flag determines if the rangeCutOn attribute is part of the shader storage block, i.e.\n"
    "if the \"float rangeCutOn;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_RANGE_CUT_OFF\n"
    "This flag determines if the hasRangeCutOff attribute is part of the shader storage block, i.e.\n"
    "if the \"float hasRangeCutOff;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_RANGE_NEAR_ZONE\n"
    "This flag determines if the hasRangeNearZone attribute is part of the shader storage block, i.e.\n"
    "if the \"float hasRangeNearZone;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_RANGE_FAR_ZONE\n"
    "This flag determines if the hasRangeFarZone attribute is part of the shader storage block, i.e.\n"
    "if the \"float hasRangeFarZone;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_SPOTLIGHT_ANGLE\n"
    "This flag determines if the spot light angle attribute is part of the shader storage block, i.e.\n"
    "if the \"float spotlightAngle;\" entry is contained in the shader struct for the Light.\n"
    "If neither this flag nor the hasCosSpotlightAngle flag is true, then the hasCosSpotlightAngle \n"
    "flag is treated as if it has value true.\n"
    "\n"
    "HAS_COS_SPOTLIGHT_ANGLE\n"
    "This flag determines if the cosine spot light angle attribute is part of the shader storage block, i.e.\n"
    "if the \"float cosSpotlightAngle;\" entry is contained in the shader struct for the Light.\n"
    "If neither this flag nor the hasSpotlightAngle flag is true, then this flag is treated as if it \n"
    "has value true.\n"
    "\n"
    "HAS_SPOTLIGHT_EXPONENT\n"
    "This flag determines if the spot expenent attribute is part of the shader storage block, i.e.\n"
    "if the \"float spotlightExponent;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_SPOTLIGHT_PENUMBRA_ANGLE\n"
    "This flag determines if the spot penumbra angle attribute is part of the shader storage block, i.e.\n"
    "if the \"float cosPenumbraCone;\" entry is contained in the shader struct for the Light.\n"
    "\n"
    "HAS_SPOTLIGHT_PENUMBRA_FACTOR\n"
    "This flag determines if the spot penumbra angle attribute is part of the shader storage block, i.e.\n"
    "if the \"float cosPenumbraCone;\" entry is contained in the shader struct for the Light. This flag\n"
    "additionally, determines that the penumbra angle is calculated from the spot light cone angle.\n"
    "\n"
    "HAS_SPOTLIGHT_PENUMBRA_FROSTBITE\n"
    "This flag determines if the spot light attributes are given in the Frostbite optimized model in the \n"
    "shader storage block, i.e. if the \"float spotScale;\"  and \"float spotOffset;\" entries are contained\n"
    "in the shader struct for the Light.\n"
    "\n"
    "HAS_CINEMA_LIGHT\n"
    "This flag determines if the cinema light attributes are part of the shader storage block, i.e.\n"
    "if the \"float innerSuperEllipsesWidth;\", ... entries are contained in the shader struct for the Light.\n"
    "If true this flag overrides the hasRangeCutOn, hasRangeCutOff, hasRangeNearZone and hasRangeFarZone\n"
    "flags, because cinema lights are described the corresponding attributes.\n"
    "See: http://http.developer.nvidia.com/GPUGems/gpugems_ch10.html\n"
    "http://www.yaldex.com/open-gl/ch12lev1sec4.html\n"
    "https://en.wikipedia.org/wiki/Superellipse\n"
    "\n"
    "HAS_SHADOW\n"
    "This flag determines if the multi light supports shadowing. Is set to true the boolean\n"
    "shadow flag, the shadowIntensity and the shadow index are added to the light struct.\n"
    "\n"
    "HAS_GLOBAL_AMBIENT_INTENSITY\n"
    "This flag determines if the multi light supports a global ambient light state, i.e. if a vec3 global color\n"
    "entry 'ambientLight' exists in the light buffer which is to be added to the single light ambient intensities.\n"
    "\n"
    "HAS_LENGTH_FACTOR\n"
    "This flag determines if the multi light supports a global length factor light state, i.e. if a float 'lengthFactor'\n"
    "exists in the light buffer which is used for distance attenuation calculations.\n"
    "\n"
    "HAS_PROJECTION\n"
    "This flag determines if the multi light contains a projection matrix for each light, that is whether\n"
    "storage is provided for the projection matrix. It does not decide whether a struct entry for the light\n"
    "in the shader is generated. For that use the dedicated hasProjectionMatrix, hasInvProjectionMatrix,\n"
    "hasProjectionLightSpaceFromWorldSpaceMatrix, hasInvProjectionLightSpaceFromWorldSpaceMatrix,\n"
    "hasProjectionLightSpaceFromEyeSpaceMatrix, hasInvProjectionLightSpaceFromEyeSpaceMatrix\n"
    "flags. Usage of these, however, implicitely set this hasProjection flag.\n"
    "Additionally, the projection matrix is not automatically calculated. That is the duty of the user of the\n"
    "chunk. Typically, the multi light shadow stage does take responsibiltiy for the proper calculation and\n"
    "setting the projection matrix.\n"
    "\n"
    "EYE_SPACE\n"
    "The lights position and direction are transformed to eye space before loading into the shader. \n"
    "On default they are provided in world space.\n"
    "\n"
    "The following code features are supported:\n"
    "CODE_DISTANCE_ATTENUATION_CLASSIC\n"
    "The classic OpenGL attenuation function is added to the light code snippet.\n"
    "\n"
    "CODE_DISTANCE_ATTENUATION_PHYSICAL\n"
    "A physically based attenuation function is added to the light code snippet.\n"
    "\n"
    "CODE_DISTANCE_ATTENUATION_DECAY\n"
    "A physically based attenuation function is added to the light code snippet.\n"
    "An additional decay parameter is used by the function.\n"
    "\n"
    "CODE_DISTANCE_ATTENUATION_MIX_PHYSICAL\n"
    "A physically based attenuation function is added to the light code snippet that\n"
    "also respect the classic OpenGL attenuation parameters.\n"
    "\n"
    "CODE_DISTANCE_ATTENUATION_MIX_DECAY\n"
    "A physically based attenuation function is added to the light code snippet that\n"
    "also respect the classic OpenGL attenuation parameters.\n"
    "An additional decay parameter is used by the function.\n"
    "\n"
    "CODE_DISTANCE_ATTENUATION_SMOOTH_HERMITE\n"
    "An attenuation function based on Hermitian smoothing is added to the light code snippet.\n"
    "\n"
    "CODE_SPOT_ATTENUATION_CLASSIC\n"
    "The classic OpenGL spot attenuation function is added to the light code snippet.\n"
    "This model uses the cosine cutoff angle and the spot exponent parameter.\n"
    "\n"
    "CODE_SPOT_ATTENUATION_SMOOTH_HERMITE\n"
    "A spot attenuation function based on Hermitian smoothing is added to the light code snippet.\n"
    "This model uses the cosine cutoff angle.\n"
    "\n"
    "CODE_SPOT_ATTENUATION_SMOOTH_HERMITE_2\n"
    "A spot attenuation function based on Hermitian smoothing is added to the light code snippet.\n"
    "This model uses the cosine cutoff angle and the cosine penumbra angle.\n"
    "\n"
    "CODE_SPOT_ATTENUATION_FROSTBITE\n"
    "A spot attenuation function based in accodrance to the Frostbite engine model.\n"
    "This optimized model uses a scale factor and an offset value.\n"
    "scale  := 1.0f / max (0.001f, (penumbraCos  - coneCos));\n"
    "offset := -coneCos * scale;\n"
    "\n"
    "Following is the light structure shown that is valid if all layout features are activated. Usually,\n"
    "one is working only with a part of these members. Some members are expected to be set by the application\n"
    "programmer and some are set by internal machinery of OpenSG.\n"
    "\n"
    "struct GlobalLight\n"
    "{\n"
    "vec3  ambientIntensity;\n"
    "}\n"
    "\n"
    "struct Light\n"
    "{\n"
    "mat4  matLSFromWS;\n"
    "mat4  matWSFromLS;\n"
    "mat4  matLSFromES;\n"
    "mat4  matESFromLS;\n"
    "mat4  matProjection;\n"
    "mat4  matInvProjection;\n"
    "mat4  matProjLSFromWS;\n"
    "mat4  matInvProjLSFromWS;\n"
    "mat4  matProjLSFromES;\n"
    "mat4  matInvProjLSFromES;\n"
    "vec3  position;\n"
    "vec3  direction;\n"
    "vec3  ambientIntensity;\n"
    "vec3  diffuseIntensity;\n"
    "vec3  specularIntensity;\n"
    "vec3  intensity;\n"
    "float constantAttenuation;\n"
    "float linearAttenuation;\n"
    "float quadraticAttenuation;\n"
    "float decayAttenuation;\n"
    "float lengthFactor;\n"
    "float rangeCutOn;\n"
    "float rangeCutOff;\n"
    "float rangeNearZone;\n"
    "float rangeFarZone;\n"
    "float cosSpotlightAngle;\n"
    "float tanSpotlightAngle;\n"
    "float spotlightAngle;\n"
    "float spotlightExponent;\n"
    "float spotlightScale;\n"
    "float spotlightOffset;\n"
    "float cosSpotlightPenumbraAngle;\n"
    "float innerSuperEllipsesWidth;\n"
    "float innerSuperEllipsesHeight;\n"
    "float outerSuperEllipsesWidth;\n"
    "float outerSuperEllipsesHeight;\n"
    "float superEllipsesRoundness;\n"
    "float superEllipsesTwist;\n"
    "int   type;\n"
    "bool  enabled;\n"
    "bool  shadow;\n"
    "int   shadowDataIndex;\n"
    "int   shadowParameterIndex;\n"
    "};\n"
    "\n"
    "layout (std430) buffer Lights\n"
    "{\n"
    "GlobalLight global;\n"
    "Light       light[];\n"
    "} lights;\n"
    "\n"
    "The chunk provides a convenient function that allows to adjust the struct layout\n"
    "for standard OpenGL lights \n"
    "\n"
    "struct Light\n"
    "{\n"
    "vec3  position;\n"
    "vec3  direction;\n"
    "vec3  ambientIntensity;\n"
    "vec3  diffuseIntensity;\n"
    "vec3  specularIntensity;\n"
    "float constantAttenuation;\n"
    "float linearAttenuation;\n"
    "float quadraticAttenuation;\n"
    "float cosSpotlightAngle;\n"
    "float spotlightExponent;\n"
    "int   type;\n"
    "bool  enabled;\n"
    "};\n"
    "\n"
    "or for simple range lights:\n"
    "\n"
    "struct Light\n"
    "{\n"
    "vec3  position;\n"
    "vec3  direction;\n"
    "vec3  intensity;\n"
    "float rangeCutOff;\n"
    "float cosSpotlightAngle;\n"
    "int   type;\n"
    "bool  enabled;\n"
    "};\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &MultiLightChunkBase::getType(void)
{
    return _type;
}

const FieldContainerType &MultiLightChunkBase::getType(void) const
{
    return _type;
}

UInt32 MultiLightChunkBase::getContainerSize(void) const
{
    return sizeof(MultiLightChunk);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *MultiLightChunkBase::editSFFeature(void)
{
    editSField(FeatureFieldMask);

    return &_sfFeature;
}

const SFUInt32 *MultiLightChunkBase::getSFFeature(void) const
{
    return &_sfFeature;
}


SFUInt32 *MultiLightChunkBase::editSFCodeFeature(void)
{
    editSField(CodeFeatureFieldMask);

    return &_sfCodeFeature;
}

const SFUInt32 *MultiLightChunkBase::getSFCodeFeature(void) const
{
    return &_sfCodeFeature;
}


SFVec3f *MultiLightChunkBase::editSFGlobalAmbientIntensity(void)
{
    editSField(GlobalAmbientIntensityFieldMask);

    return &_sfGlobalAmbientIntensity;
}

const SFVec3f *MultiLightChunkBase::getSFGlobalAmbientIntensity(void) const
{
    return &_sfGlobalAmbientIntensity;
}


MFPnt3f *MultiLightChunkBase::editMFPosition(void)
{
    editMField(PositionFieldMask, _mfPosition);

    return &_mfPosition;
}

const MFPnt3f *MultiLightChunkBase::getMFPosition(void) const
{
    return &_mfPosition;
}


MFVec3f *MultiLightChunkBase::editMFDirection(void)
{
    editMField(DirectionFieldMask, _mfDirection);

    return &_mfDirection;
}

const MFVec3f *MultiLightChunkBase::getMFDirection(void) const
{
    return &_mfDirection;
}


MFVec3f *MultiLightChunkBase::editMFIntensity(void)
{
    editMField(IntensityFieldMask, _mfIntensity);

    return &_mfIntensity;
}

const MFVec3f *MultiLightChunkBase::getMFIntensity(void) const
{
    return &_mfIntensity;
}


MFVec3f *MultiLightChunkBase::editMFAmbientIntensity(void)
{
    editMField(AmbientIntensityFieldMask, _mfAmbientIntensity);

    return &_mfAmbientIntensity;
}

const MFVec3f *MultiLightChunkBase::getMFAmbientIntensity(void) const
{
    return &_mfAmbientIntensity;
}


MFVec3f *MultiLightChunkBase::editMFDiffuseIntensity(void)
{
    editMField(DiffuseIntensityFieldMask, _mfDiffuseIntensity);

    return &_mfDiffuseIntensity;
}

const MFVec3f *MultiLightChunkBase::getMFDiffuseIntensity(void) const
{
    return &_mfDiffuseIntensity;
}


MFVec3f *MultiLightChunkBase::editMFSpecularIntensity(void)
{
    editMField(SpecularIntensityFieldMask, _mfSpecularIntensity);

    return &_mfSpecularIntensity;
}

const MFVec3f *MultiLightChunkBase::getMFSpecularIntensity(void) const
{
    return &_mfSpecularIntensity;
}


MFVec3f *MultiLightChunkBase::editMFAttenuation(void)
{
    editMField(AttenuationFieldMask, _mfAttenuation);

    return &_mfAttenuation;
}

const MFVec3f *MultiLightChunkBase::getMFAttenuation(void) const
{
    return &_mfAttenuation;
}


MFReal32 *MultiLightChunkBase::editMFDecayAttenuation(void)
{
    editMField(DecayAttenuationFieldMask, _mfDecayAttenuation);

    return &_mfDecayAttenuation;
}

const MFReal32 *MultiLightChunkBase::getMFDecayAttenuation(void) const
{
    return &_mfDecayAttenuation;
}


MFReal32 *MultiLightChunkBase::editMFLengthFactor(void)
{
    editMField(LengthFactorFieldMask, _mfLengthFactor);

    return &_mfLengthFactor;
}

const MFReal32 *MultiLightChunkBase::getMFLengthFactor(void) const
{
    return &_mfLengthFactor;
}


MFReal32 *MultiLightChunkBase::editMFSpotlightAngle(void)
{
    editMField(SpotlightAngleFieldMask, _mfSpotlightAngle);

    return &_mfSpotlightAngle;
}

const MFReal32 *MultiLightChunkBase::getMFSpotlightAngle(void) const
{
    return &_mfSpotlightAngle;
}


MFReal32 *MultiLightChunkBase::editMFSpotExponent(void)
{
    editMField(SpotExponentFieldMask, _mfSpotExponent);

    return &_mfSpotExponent;
}

const MFReal32 *MultiLightChunkBase::getMFSpotExponent(void) const
{
    return &_mfSpotExponent;
}


MFReal32 *MultiLightChunkBase::editMFInnerSuperEllipsesWidth(void)
{
    editMField(InnerSuperEllipsesWidthFieldMask, _mfInnerSuperEllipsesWidth);

    return &_mfInnerSuperEllipsesWidth;
}

const MFReal32 *MultiLightChunkBase::getMFInnerSuperEllipsesWidth(void) const
{
    return &_mfInnerSuperEllipsesWidth;
}


MFReal32 *MultiLightChunkBase::editMFInnerSuperEllipsesHeight(void)
{
    editMField(InnerSuperEllipsesHeightFieldMask, _mfInnerSuperEllipsesHeight);

    return &_mfInnerSuperEllipsesHeight;
}

const MFReal32 *MultiLightChunkBase::getMFInnerSuperEllipsesHeight(void) const
{
    return &_mfInnerSuperEllipsesHeight;
}


MFReal32 *MultiLightChunkBase::editMFOuterSuperEllipsesWidth(void)
{
    editMField(OuterSuperEllipsesWidthFieldMask, _mfOuterSuperEllipsesWidth);

    return &_mfOuterSuperEllipsesWidth;
}

const MFReal32 *MultiLightChunkBase::getMFOuterSuperEllipsesWidth(void) const
{
    return &_mfOuterSuperEllipsesWidth;
}


MFReal32 *MultiLightChunkBase::editMFOuterSuperEllipsesHeight(void)
{
    editMField(OuterSuperEllipsesHeightFieldMask, _mfOuterSuperEllipsesHeight);

    return &_mfOuterSuperEllipsesHeight;
}

const MFReal32 *MultiLightChunkBase::getMFOuterSuperEllipsesHeight(void) const
{
    return &_mfOuterSuperEllipsesHeight;
}


MFReal32 *MultiLightChunkBase::editMFSuperEllipsesRoundness(void)
{
    editMField(SuperEllipsesRoundnessFieldMask, _mfSuperEllipsesRoundness);

    return &_mfSuperEllipsesRoundness;
}

const MFReal32 *MultiLightChunkBase::getMFSuperEllipsesRoundness(void) const
{
    return &_mfSuperEllipsesRoundness;
}


MFReal32 *MultiLightChunkBase::editMFSuperEllipsesTwist(void)
{
    editMField(SuperEllipsesTwistFieldMask, _mfSuperEllipsesTwist);

    return &_mfSuperEllipsesTwist;
}

const MFReal32 *MultiLightChunkBase::getMFSuperEllipsesTwist(void) const
{
    return &_mfSuperEllipsesTwist;
}


MFReal32 *MultiLightChunkBase::editMFRangeCutOn(void)
{
    editMField(RangeCutOnFieldMask, _mfRangeCutOn);

    return &_mfRangeCutOn;
}

const MFReal32 *MultiLightChunkBase::getMFRangeCutOn(void) const
{
    return &_mfRangeCutOn;
}


MFReal32 *MultiLightChunkBase::editMFRangeCutOff(void)
{
    editMField(RangeCutOffFieldMask, _mfRangeCutOff);

    return &_mfRangeCutOff;
}

const MFReal32 *MultiLightChunkBase::getMFRangeCutOff(void) const
{
    return &_mfRangeCutOff;
}


MFReal32 *MultiLightChunkBase::editMFRangeNearZone(void)
{
    editMField(RangeNearZoneFieldMask, _mfRangeNearZone);

    return &_mfRangeNearZone;
}

const MFReal32 *MultiLightChunkBase::getMFRangeNearZone(void) const
{
    return &_mfRangeNearZone;
}


MFReal32 *MultiLightChunkBase::editMFRangeFarZone(void)
{
    editMField(RangeFarZoneFieldMask, _mfRangeFarZone);

    return &_mfRangeFarZone;
}

const MFReal32 *MultiLightChunkBase::getMFRangeFarZone(void) const
{
    return &_mfRangeFarZone;
}


MFMatrix *MultiLightChunkBase::editMFProjectionMatrix(void)
{
    editMField(ProjectionMatrixFieldMask, _mfProjectionMatrix);

    return &_mfProjectionMatrix;
}

const MFMatrix *MultiLightChunkBase::getMFProjectionMatrix(void) const
{
    return &_mfProjectionMatrix;
}


MFUInt8 *MultiLightChunkBase::editMFTypeOfLight(void)
{
    editMField(TypeOfLightFieldMask, _mfTypeOfLight);

    return &_mfTypeOfLight;
}

const MFUInt8 *MultiLightChunkBase::getMFTypeOfLight(void) const
{
    return &_mfTypeOfLight;
}


MFBool *MultiLightChunkBase::editMFEnabled(void)
{
    editMField(EnabledFieldMask, _mfEnabled);

    return &_mfEnabled;
}

const MFBool *MultiLightChunkBase::getMFEnabled(void) const
{
    return &_mfEnabled;
}


MFBool *MultiLightChunkBase::editMFShadow(void)
{
    editMField(ShadowFieldMask, _mfShadow);

    return &_mfShadow;
}

const MFBool *MultiLightChunkBase::getMFShadow(void) const
{
    return &_mfShadow;
}


MFInt32 *MultiLightChunkBase::editMFShadowDataIndex(void)
{
    editMField(ShadowDataIndexFieldMask, _mfShadowDataIndex);

    return &_mfShadowDataIndex;
}

const MFInt32 *MultiLightChunkBase::getMFShadowDataIndex(void) const
{
    return &_mfShadowDataIndex;
}


MFInt32 *MultiLightChunkBase::editMFShadowParameterIndex(void)
{
    editMField(ShadowParameterIndexFieldMask, _mfShadowParameterIndex);

    return &_mfShadowParameterIndex;
}

const MFInt32 *MultiLightChunkBase::getMFShadowParameterIndex(void) const
{
    return &_mfShadowParameterIndex;
}


//! Get the MultiLightChunk::_mfBeacon field.
const MFWeakNodePtr *MultiLightChunkBase::getMFBeacon(void) const
{
    return &_mfBeacon;
}

MFWeakNodePtr       *MultiLightChunkBase::editMFBeacon         (void)
{
    editMField(BeaconFieldMask, _mfBeacon);

    return &_mfBeacon;
}
Node * MultiLightChunkBase::getBeacon(const UInt32 index) const
{
    return _mfBeacon[index];
}

SFBool *MultiLightChunkBase::editSFNormalizeDirection(void)
{
    editSField(NormalizeDirectionFieldMask);

    return &_sfNormalizeDirection;
}

const SFBool *MultiLightChunkBase::getSFNormalizeDirection(void) const
{
    return &_sfNormalizeDirection;
}


MFMatrix *MultiLightChunkBase::editMFBeaconMatrix(void)
{
    editMField(BeaconMatrixFieldMask, _mfBeaconMatrix);

    return &_mfBeaconMatrix;
}

const MFMatrix *MultiLightChunkBase::getMFBeaconMatrix(void) const
{
    return &_mfBeaconMatrix;
}


SFReal32 *MultiLightChunkBase::editSFLastCamNear(void)
{
    editSField(LastCamNearFieldMask);

    return &_sfLastCamNear;
}

const SFReal32 *MultiLightChunkBase::getSFLastCamNear(void) const
{
    return &_sfLastCamNear;
}


SFReal32 *MultiLightChunkBase::editSFLastCamFar(void)
{
    editSField(LastCamFarFieldMask);

    return &_sfLastCamFar;
}

const SFReal32 *MultiLightChunkBase::getSFLastCamFar(void) const
{
    return &_sfLastCamFar;
}


SFMatrix *MultiLightChunkBase::editSFLastCamToWorld(void)
{
    editSField(LastCamToWorldFieldMask);

    return &_sfLastCamToWorld;
}

const SFMatrix *MultiLightChunkBase::getSFLastCamToWorld(void) const
{
    return &_sfLastCamToWorld;
}


SFString *MultiLightChunkBase::editSFLightBlockName(void)
{
    editSField(LightBlockNameFieldMask);

    return &_sfLightBlockName;
}

const SFString *MultiLightChunkBase::getSFLightBlockName(void) const
{
    return &_sfLightBlockName;
}


SFString *MultiLightChunkBase::editSFLightVariableName(void)
{
    editSField(LightVariableNameFieldMask);

    return &_sfLightVariableName;
}

const SFString *MultiLightChunkBase::getSFLightVariableName(void) const
{
    return &_sfLightVariableName;
}




void MultiLightChunkBase::pushToBeacon(Node * const value)
{
    editMField(BeaconFieldMask, _mfBeacon);

    _mfBeacon.push_back(value);
}

void MultiLightChunkBase::assignBeacon   (const MFWeakNodePtr     &value)
{
    MFWeakNodePtr    ::const_iterator elemIt  =
        value.begin();
    MFWeakNodePtr    ::const_iterator elemEnd =
        value.end  ();

    static_cast<MultiLightChunk *>(this)->clearBeacon();

    while(elemIt != elemEnd)
    {
        this->pushToBeacon(*elemIt);

        ++elemIt;
    }
}

void MultiLightChunkBase::removeFromBeacon(UInt32 uiIndex)
{
    if(uiIndex < _mfBeacon.size())
    {
        editMField(BeaconFieldMask, _mfBeacon);

        _mfBeacon.erase(uiIndex);
    }
}

void MultiLightChunkBase::removeObjFromBeacon(Node * const value)
{
    Int32 iElemIdx = _mfBeacon.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(BeaconFieldMask, _mfBeacon);

        _mfBeacon.erase(iElemIdx);
    }
}
void MultiLightChunkBase::clearBeacon(void)
{
    editMField(BeaconFieldMask, _mfBeacon);


    _mfBeacon.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT MultiLightChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (FeatureFieldMask & whichField))
    {
        returnValue += _sfFeature.getBinSize();
    }
    if(FieldBits::NoField != (CodeFeatureFieldMask & whichField))
    {
        returnValue += _sfCodeFeature.getBinSize();
    }
    if(FieldBits::NoField != (GlobalAmbientIntensityFieldMask & whichField))
    {
        returnValue += _sfGlobalAmbientIntensity.getBinSize();
    }
    if(FieldBits::NoField != (PositionFieldMask & whichField))
    {
        returnValue += _mfPosition.getBinSize();
    }
    if(FieldBits::NoField != (DirectionFieldMask & whichField))
    {
        returnValue += _mfDirection.getBinSize();
    }
    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        returnValue += _mfIntensity.getBinSize();
    }
    if(FieldBits::NoField != (AmbientIntensityFieldMask & whichField))
    {
        returnValue += _mfAmbientIntensity.getBinSize();
    }
    if(FieldBits::NoField != (DiffuseIntensityFieldMask & whichField))
    {
        returnValue += _mfDiffuseIntensity.getBinSize();
    }
    if(FieldBits::NoField != (SpecularIntensityFieldMask & whichField))
    {
        returnValue += _mfSpecularIntensity.getBinSize();
    }
    if(FieldBits::NoField != (AttenuationFieldMask & whichField))
    {
        returnValue += _mfAttenuation.getBinSize();
    }
    if(FieldBits::NoField != (DecayAttenuationFieldMask & whichField))
    {
        returnValue += _mfDecayAttenuation.getBinSize();
    }
    if(FieldBits::NoField != (LengthFactorFieldMask & whichField))
    {
        returnValue += _mfLengthFactor.getBinSize();
    }
    if(FieldBits::NoField != (SpotlightAngleFieldMask & whichField))
    {
        returnValue += _mfSpotlightAngle.getBinSize();
    }
    if(FieldBits::NoField != (SpotExponentFieldMask & whichField))
    {
        returnValue += _mfSpotExponent.getBinSize();
    }
    if(FieldBits::NoField != (InnerSuperEllipsesWidthFieldMask & whichField))
    {
        returnValue += _mfInnerSuperEllipsesWidth.getBinSize();
    }
    if(FieldBits::NoField != (InnerSuperEllipsesHeightFieldMask & whichField))
    {
        returnValue += _mfInnerSuperEllipsesHeight.getBinSize();
    }
    if(FieldBits::NoField != (OuterSuperEllipsesWidthFieldMask & whichField))
    {
        returnValue += _mfOuterSuperEllipsesWidth.getBinSize();
    }
    if(FieldBits::NoField != (OuterSuperEllipsesHeightFieldMask & whichField))
    {
        returnValue += _mfOuterSuperEllipsesHeight.getBinSize();
    }
    if(FieldBits::NoField != (SuperEllipsesRoundnessFieldMask & whichField))
    {
        returnValue += _mfSuperEllipsesRoundness.getBinSize();
    }
    if(FieldBits::NoField != (SuperEllipsesTwistFieldMask & whichField))
    {
        returnValue += _mfSuperEllipsesTwist.getBinSize();
    }
    if(FieldBits::NoField != (RangeCutOnFieldMask & whichField))
    {
        returnValue += _mfRangeCutOn.getBinSize();
    }
    if(FieldBits::NoField != (RangeCutOffFieldMask & whichField))
    {
        returnValue += _mfRangeCutOff.getBinSize();
    }
    if(FieldBits::NoField != (RangeNearZoneFieldMask & whichField))
    {
        returnValue += _mfRangeNearZone.getBinSize();
    }
    if(FieldBits::NoField != (RangeFarZoneFieldMask & whichField))
    {
        returnValue += _mfRangeFarZone.getBinSize();
    }
    if(FieldBits::NoField != (ProjectionMatrixFieldMask & whichField))
    {
        returnValue += _mfProjectionMatrix.getBinSize();
    }
    if(FieldBits::NoField != (TypeOfLightFieldMask & whichField))
    {
        returnValue += _mfTypeOfLight.getBinSize();
    }
    if(FieldBits::NoField != (EnabledFieldMask & whichField))
    {
        returnValue += _mfEnabled.getBinSize();
    }
    if(FieldBits::NoField != (ShadowFieldMask & whichField))
    {
        returnValue += _mfShadow.getBinSize();
    }
    if(FieldBits::NoField != (ShadowDataIndexFieldMask & whichField))
    {
        returnValue += _mfShadowDataIndex.getBinSize();
    }
    if(FieldBits::NoField != (ShadowParameterIndexFieldMask & whichField))
    {
        returnValue += _mfShadowParameterIndex.getBinSize();
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        returnValue += _mfBeacon.getBinSize();
    }
    if(FieldBits::NoField != (NormalizeDirectionFieldMask & whichField))
    {
        returnValue += _sfNormalizeDirection.getBinSize();
    }
    if(FieldBits::NoField != (BeaconMatrixFieldMask & whichField))
    {
        returnValue += _mfBeaconMatrix.getBinSize();
    }
    if(FieldBits::NoField != (LastCamNearFieldMask & whichField))
    {
        returnValue += _sfLastCamNear.getBinSize();
    }
    if(FieldBits::NoField != (LastCamFarFieldMask & whichField))
    {
        returnValue += _sfLastCamFar.getBinSize();
    }
    if(FieldBits::NoField != (LastCamToWorldFieldMask & whichField))
    {
        returnValue += _sfLastCamToWorld.getBinSize();
    }
    if(FieldBits::NoField != (LightBlockNameFieldMask & whichField))
    {
        returnValue += _sfLightBlockName.getBinSize();
    }
    if(FieldBits::NoField != (LightVariableNameFieldMask & whichField))
    {
        returnValue += _sfLightVariableName.getBinSize();
    }

    return returnValue;
}

void MultiLightChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (FeatureFieldMask & whichField))
    {
        _sfFeature.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CodeFeatureFieldMask & whichField))
    {
        _sfCodeFeature.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GlobalAmbientIntensityFieldMask & whichField))
    {
        _sfGlobalAmbientIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionFieldMask & whichField))
    {
        _mfPosition.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirectionFieldMask & whichField))
    {
        _mfDirection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        _mfIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AmbientIntensityFieldMask & whichField))
    {
        _mfAmbientIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DiffuseIntensityFieldMask & whichField))
    {
        _mfDiffuseIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpecularIntensityFieldMask & whichField))
    {
        _mfSpecularIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AttenuationFieldMask & whichField))
    {
        _mfAttenuation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DecayAttenuationFieldMask & whichField))
    {
        _mfDecayAttenuation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LengthFactorFieldMask & whichField))
    {
        _mfLengthFactor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpotlightAngleFieldMask & whichField))
    {
        _mfSpotlightAngle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpotExponentFieldMask & whichField))
    {
        _mfSpotExponent.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesWidthFieldMask & whichField))
    {
        _mfInnerSuperEllipsesWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesHeightFieldMask & whichField))
    {
        _mfInnerSuperEllipsesHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesWidthFieldMask & whichField))
    {
        _mfOuterSuperEllipsesWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesHeightFieldMask & whichField))
    {
        _mfOuterSuperEllipsesHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesRoundnessFieldMask & whichField))
    {
        _mfSuperEllipsesRoundness.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesTwistFieldMask & whichField))
    {
        _mfSuperEllipsesTwist.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOnFieldMask & whichField))
    {
        _mfRangeCutOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOffFieldMask & whichField))
    {
        _mfRangeCutOff.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeNearZoneFieldMask & whichField))
    {
        _mfRangeNearZone.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RangeFarZoneFieldMask & whichField))
    {
        _mfRangeFarZone.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ProjectionMatrixFieldMask & whichField))
    {
        _mfProjectionMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TypeOfLightFieldMask & whichField))
    {
        _mfTypeOfLight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnabledFieldMask & whichField))
    {
        _mfEnabled.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowFieldMask & whichField))
    {
        _mfShadow.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowDataIndexFieldMask & whichField))
    {
        _mfShadowDataIndex.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowParameterIndexFieldMask & whichField))
    {
        _mfShadowParameterIndex.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        _mfBeacon.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NormalizeDirectionFieldMask & whichField))
    {
        _sfNormalizeDirection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BeaconMatrixFieldMask & whichField))
    {
        _mfBeaconMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LastCamNearFieldMask & whichField))
    {
        _sfLastCamNear.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LastCamFarFieldMask & whichField))
    {
        _sfLastCamFar.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LastCamToWorldFieldMask & whichField))
    {
        _sfLastCamToWorld.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LightBlockNameFieldMask & whichField))
    {
        _sfLightBlockName.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LightVariableNameFieldMask & whichField))
    {
        _sfLightVariableName.copyToBin(pMem);
    }
}

void MultiLightChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (FeatureFieldMask & whichField))
    {
        editSField(FeatureFieldMask);
        _sfFeature.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CodeFeatureFieldMask & whichField))
    {
        editSField(CodeFeatureFieldMask);
        _sfCodeFeature.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GlobalAmbientIntensityFieldMask & whichField))
    {
        editSField(GlobalAmbientIntensityFieldMask);
        _sfGlobalAmbientIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionFieldMask & whichField))
    {
        editMField(PositionFieldMask, _mfPosition);
        _mfPosition.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirectionFieldMask & whichField))
    {
        editMField(DirectionFieldMask, _mfDirection);
        _mfDirection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IntensityFieldMask & whichField))
    {
        editMField(IntensityFieldMask, _mfIntensity);
        _mfIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AmbientIntensityFieldMask & whichField))
    {
        editMField(AmbientIntensityFieldMask, _mfAmbientIntensity);
        _mfAmbientIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DiffuseIntensityFieldMask & whichField))
    {
        editMField(DiffuseIntensityFieldMask, _mfDiffuseIntensity);
        _mfDiffuseIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpecularIntensityFieldMask & whichField))
    {
        editMField(SpecularIntensityFieldMask, _mfSpecularIntensity);
        _mfSpecularIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AttenuationFieldMask & whichField))
    {
        editMField(AttenuationFieldMask, _mfAttenuation);
        _mfAttenuation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DecayAttenuationFieldMask & whichField))
    {
        editMField(DecayAttenuationFieldMask, _mfDecayAttenuation);
        _mfDecayAttenuation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LengthFactorFieldMask & whichField))
    {
        editMField(LengthFactorFieldMask, _mfLengthFactor);
        _mfLengthFactor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpotlightAngleFieldMask & whichField))
    {
        editMField(SpotlightAngleFieldMask, _mfSpotlightAngle);
        _mfSpotlightAngle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpotExponentFieldMask & whichField))
    {
        editMField(SpotExponentFieldMask, _mfSpotExponent);
        _mfSpotExponent.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesWidthFieldMask & whichField))
    {
        editMField(InnerSuperEllipsesWidthFieldMask, _mfInnerSuperEllipsesWidth);
        _mfInnerSuperEllipsesWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InnerSuperEllipsesHeightFieldMask & whichField))
    {
        editMField(InnerSuperEllipsesHeightFieldMask, _mfInnerSuperEllipsesHeight);
        _mfInnerSuperEllipsesHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesWidthFieldMask & whichField))
    {
        editMField(OuterSuperEllipsesWidthFieldMask, _mfOuterSuperEllipsesWidth);
        _mfOuterSuperEllipsesWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OuterSuperEllipsesHeightFieldMask & whichField))
    {
        editMField(OuterSuperEllipsesHeightFieldMask, _mfOuterSuperEllipsesHeight);
        _mfOuterSuperEllipsesHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesRoundnessFieldMask & whichField))
    {
        editMField(SuperEllipsesRoundnessFieldMask, _mfSuperEllipsesRoundness);
        _mfSuperEllipsesRoundness.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SuperEllipsesTwistFieldMask & whichField))
    {
        editMField(SuperEllipsesTwistFieldMask, _mfSuperEllipsesTwist);
        _mfSuperEllipsesTwist.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOnFieldMask & whichField))
    {
        editMField(RangeCutOnFieldMask, _mfRangeCutOn);
        _mfRangeCutOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeCutOffFieldMask & whichField))
    {
        editMField(RangeCutOffFieldMask, _mfRangeCutOff);
        _mfRangeCutOff.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeNearZoneFieldMask & whichField))
    {
        editMField(RangeNearZoneFieldMask, _mfRangeNearZone);
        _mfRangeNearZone.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RangeFarZoneFieldMask & whichField))
    {
        editMField(RangeFarZoneFieldMask, _mfRangeFarZone);
        _mfRangeFarZone.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ProjectionMatrixFieldMask & whichField))
    {
        editMField(ProjectionMatrixFieldMask, _mfProjectionMatrix);
        _mfProjectionMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TypeOfLightFieldMask & whichField))
    {
        editMField(TypeOfLightFieldMask, _mfTypeOfLight);
        _mfTypeOfLight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnabledFieldMask & whichField))
    {
        editMField(EnabledFieldMask, _mfEnabled);
        _mfEnabled.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowFieldMask & whichField))
    {
        editMField(ShadowFieldMask, _mfShadow);
        _mfShadow.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowDataIndexFieldMask & whichField))
    {
        editMField(ShadowDataIndexFieldMask, _mfShadowDataIndex);
        _mfShadowDataIndex.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowParameterIndexFieldMask & whichField))
    {
        editMField(ShadowParameterIndexFieldMask, _mfShadowParameterIndex);
        _mfShadowParameterIndex.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        editMField(BeaconFieldMask, _mfBeacon);
        _mfBeacon.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NormalizeDirectionFieldMask & whichField))
    {
        editSField(NormalizeDirectionFieldMask);
        _sfNormalizeDirection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BeaconMatrixFieldMask & whichField))
    {
        editMField(BeaconMatrixFieldMask, _mfBeaconMatrix);
        _mfBeaconMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LastCamNearFieldMask & whichField))
    {
        editSField(LastCamNearFieldMask);
        _sfLastCamNear.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LastCamFarFieldMask & whichField))
    {
        editSField(LastCamFarFieldMask);
        _sfLastCamFar.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LastCamToWorldFieldMask & whichField))
    {
        editSField(LastCamToWorldFieldMask);
        _sfLastCamToWorld.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LightBlockNameFieldMask & whichField))
    {
        editSField(LightBlockNameFieldMask);
        _sfLightBlockName.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LightVariableNameFieldMask & whichField))
    {
        editSField(LightVariableNameFieldMask);
        _sfLightVariableName.copyFromBin(pMem);
    }
}

//! create a new instance of the class
MultiLightChunkTransitPtr MultiLightChunkBase::createLocal(BitVector bFlags)
{
    MultiLightChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<MultiLightChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
MultiLightChunkTransitPtr MultiLightChunkBase::createDependent(BitVector bFlags)
{
    MultiLightChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<MultiLightChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
MultiLightChunkTransitPtr MultiLightChunkBase::create(void)
{
    MultiLightChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<MultiLightChunk>(tmpPtr);
    }

    return fc;
}

MultiLightChunk *MultiLightChunkBase::createEmptyLocal(BitVector bFlags)
{
    MultiLightChunk *returnValue;

    newPtr<MultiLightChunk>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
MultiLightChunk *MultiLightChunkBase::createEmpty(void)
{
    MultiLightChunk *returnValue;

    newPtr<MultiLightChunk>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr MultiLightChunkBase::shallowCopyLocal(
    BitVector bFlags) const
{
    MultiLightChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightChunk *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightChunkBase::shallowCopyDependent(
    BitVector bFlags) const
{
    MultiLightChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MultiLightChunk *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr MultiLightChunkBase::shallowCopy(void) const
{
    MultiLightChunk *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const MultiLightChunk *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

MultiLightChunkBase::MultiLightChunkBase(void) :
    Inherited(),
    _sfFeature                (UInt32(0)),
    _sfCodeFeature            (UInt32(0)),
    _sfGlobalAmbientIntensity (Vec3f(Vec3f(0,0,0))),
    _mfPosition               (),
    _mfDirection              (),
    _mfIntensity              (),
    _mfAmbientIntensity       (),
    _mfDiffuseIntensity       (),
    _mfSpecularIntensity      (),
    _mfAttenuation            (),
    _mfDecayAttenuation       (),
    _mfLengthFactor           (),
    _mfSpotlightAngle         (),
    _mfSpotExponent           (),
    _mfInnerSuperEllipsesWidth(),
    _mfInnerSuperEllipsesHeight(),
    _mfOuterSuperEllipsesWidth(),
    _mfOuterSuperEllipsesHeight(),
    _mfSuperEllipsesRoundness (),
    _mfSuperEllipsesTwist     (),
    _mfRangeCutOn             (),
    _mfRangeCutOff            (),
    _mfRangeNearZone          (),
    _mfRangeFarZone           (),
    _mfProjectionMatrix       (),
    _mfTypeOfLight            (),
    _mfEnabled                (),
    _mfShadow                 (),
    _mfShadowDataIndex        (),
    _mfShadowParameterIndex   (),
    _mfBeacon                 (),
    _sfNormalizeDirection     (bool(true)),
    _mfBeaconMatrix           (),
    _sfLastCamNear            (Real32(0.f)),
    _sfLastCamFar             (Real32(0.f)),
    _sfLastCamToWorld         (),
    _sfLightBlockName         (std::string("Lights")),
    _sfLightVariableName      (std::string("lights"))
{
}

MultiLightChunkBase::MultiLightChunkBase(const MultiLightChunkBase &source) :
    Inherited(source),
    _sfFeature                (source._sfFeature                ),
    _sfCodeFeature            (source._sfCodeFeature            ),
    _sfGlobalAmbientIntensity (source._sfGlobalAmbientIntensity ),
    _mfPosition               (source._mfPosition               ),
    _mfDirection              (source._mfDirection              ),
    _mfIntensity              (source._mfIntensity              ),
    _mfAmbientIntensity       (source._mfAmbientIntensity       ),
    _mfDiffuseIntensity       (source._mfDiffuseIntensity       ),
    _mfSpecularIntensity      (source._mfSpecularIntensity      ),
    _mfAttenuation            (source._mfAttenuation            ),
    _mfDecayAttenuation       (source._mfDecayAttenuation       ),
    _mfLengthFactor           (source._mfLengthFactor           ),
    _mfSpotlightAngle         (source._mfSpotlightAngle         ),
    _mfSpotExponent           (source._mfSpotExponent           ),
    _mfInnerSuperEllipsesWidth(source._mfInnerSuperEllipsesWidth),
    _mfInnerSuperEllipsesHeight(source._mfInnerSuperEllipsesHeight),
    _mfOuterSuperEllipsesWidth(source._mfOuterSuperEllipsesWidth),
    _mfOuterSuperEllipsesHeight(source._mfOuterSuperEllipsesHeight),
    _mfSuperEllipsesRoundness (source._mfSuperEllipsesRoundness ),
    _mfSuperEllipsesTwist     (source._mfSuperEllipsesTwist     ),
    _mfRangeCutOn             (source._mfRangeCutOn             ),
    _mfRangeCutOff            (source._mfRangeCutOff            ),
    _mfRangeNearZone          (source._mfRangeNearZone          ),
    _mfRangeFarZone           (source._mfRangeFarZone           ),
    _mfProjectionMatrix       (source._mfProjectionMatrix       ),
    _mfTypeOfLight            (source._mfTypeOfLight            ),
    _mfEnabled                (source._mfEnabled                ),
    _mfShadow                 (source._mfShadow                 ),
    _mfShadowDataIndex        (source._mfShadowDataIndex        ),
    _mfShadowParameterIndex   (source._mfShadowParameterIndex   ),
    _mfBeacon                 (),
    _sfNormalizeDirection     (source._sfNormalizeDirection     ),
    _mfBeaconMatrix           (source._mfBeaconMatrix           ),
    _sfLastCamNear            (source._sfLastCamNear            ),
    _sfLastCamFar             (source._sfLastCamFar             ),
    _sfLastCamToWorld         (source._sfLastCamToWorld         ),
    _sfLightBlockName         (source._sfLightBlockName         ),
    _sfLightVariableName      (source._sfLightVariableName      )
{
}


/*-------------------------- destructors ----------------------------------*/

MultiLightChunkBase::~MultiLightChunkBase(void)
{
}

void MultiLightChunkBase::onCreate(const MultiLightChunk *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        MultiLightChunk *pThis = static_cast<MultiLightChunk *>(this);

        MFWeakNodePtr::const_iterator BeaconIt  =
            source->_mfBeacon.begin();
        MFWeakNodePtr::const_iterator BeaconEnd =
            source->_mfBeacon.end  ();

        while(BeaconIt != BeaconEnd)
        {
            pThis->pushToBeacon(*BeaconIt);

            ++BeaconIt;
        }
    }
}

GetFieldHandlePtr MultiLightChunkBase::getHandleFeature         (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfFeature,
             this->getType().getFieldDesc(FeatureFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleFeature        (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfFeature,
             this->getType().getFieldDesc(FeatureFieldId),
             this));


    editSField(FeatureFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleCodeFeature     (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfCodeFeature,
             this->getType().getFieldDesc(CodeFeatureFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleCodeFeature    (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfCodeFeature,
             this->getType().getFieldDesc(CodeFeatureFieldId),
             this));


    editSField(CodeFeatureFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleGlobalAmbientIntensity (void) const
{
    SFVec3f::GetHandlePtr returnValue(
        new  SFVec3f::GetHandle(
             &_sfGlobalAmbientIntensity,
             this->getType().getFieldDesc(GlobalAmbientIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleGlobalAmbientIntensity(void)
{
    SFVec3f::EditHandlePtr returnValue(
        new  SFVec3f::EditHandle(
             &_sfGlobalAmbientIntensity,
             this->getType().getFieldDesc(GlobalAmbientIntensityFieldId),
             this));


    editSField(GlobalAmbientIntensityFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandlePosition        (void) const
{
    MFPnt3f::GetHandlePtr returnValue(
        new  MFPnt3f::GetHandle(
             &_mfPosition,
             this->getType().getFieldDesc(PositionFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandlePosition       (void)
{
    MFPnt3f::EditHandlePtr returnValue(
        new  MFPnt3f::EditHandle(
             &_mfPosition,
             this->getType().getFieldDesc(PositionFieldId),
             this));


    editMField(PositionFieldMask, _mfPosition);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleDirection       (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfDirection,
             this->getType().getFieldDesc(DirectionFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleDirection      (void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfDirection,
             this->getType().getFieldDesc(DirectionFieldId),
             this));


    editMField(DirectionFieldMask, _mfDirection);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleIntensity       (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfIntensity,
             this->getType().getFieldDesc(IntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleIntensity      (void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfIntensity,
             this->getType().getFieldDesc(IntensityFieldId),
             this));


    editMField(IntensityFieldMask, _mfIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleAmbientIntensity (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfAmbientIntensity,
             this->getType().getFieldDesc(AmbientIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleAmbientIntensity(void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfAmbientIntensity,
             this->getType().getFieldDesc(AmbientIntensityFieldId),
             this));


    editMField(AmbientIntensityFieldMask, _mfAmbientIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleDiffuseIntensity (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfDiffuseIntensity,
             this->getType().getFieldDesc(DiffuseIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleDiffuseIntensity(void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfDiffuseIntensity,
             this->getType().getFieldDesc(DiffuseIntensityFieldId),
             this));


    editMField(DiffuseIntensityFieldMask, _mfDiffuseIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSpecularIntensity (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfSpecularIntensity,
             this->getType().getFieldDesc(SpecularIntensityFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSpecularIntensity(void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfSpecularIntensity,
             this->getType().getFieldDesc(SpecularIntensityFieldId),
             this));


    editMField(SpecularIntensityFieldMask, _mfSpecularIntensity);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleAttenuation     (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfAttenuation,
             this->getType().getFieldDesc(AttenuationFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleAttenuation    (void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfAttenuation,
             this->getType().getFieldDesc(AttenuationFieldId),
             this));


    editMField(AttenuationFieldMask, _mfAttenuation);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleDecayAttenuation (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfDecayAttenuation,
             this->getType().getFieldDesc(DecayAttenuationFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleDecayAttenuation(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfDecayAttenuation,
             this->getType().getFieldDesc(DecayAttenuationFieldId),
             this));


    editMField(DecayAttenuationFieldMask, _mfDecayAttenuation);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLengthFactor    (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfLengthFactor,
             this->getType().getFieldDesc(LengthFactorFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLengthFactor   (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfLengthFactor,
             this->getType().getFieldDesc(LengthFactorFieldId),
             this));


    editMField(LengthFactorFieldMask, _mfLengthFactor);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSpotlightAngle  (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSpotlightAngle,
             this->getType().getFieldDesc(SpotlightAngleFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSpotlightAngle (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSpotlightAngle,
             this->getType().getFieldDesc(SpotlightAngleFieldId),
             this));


    editMField(SpotlightAngleFieldMask, _mfSpotlightAngle);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSpotExponent    (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSpotExponent,
             this->getType().getFieldDesc(SpotExponentFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSpotExponent   (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSpotExponent,
             this->getType().getFieldDesc(SpotExponentFieldId),
             this));


    editMField(SpotExponentFieldMask, _mfSpotExponent);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleInnerSuperEllipsesWidth (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfInnerSuperEllipsesWidth,
             this->getType().getFieldDesc(InnerSuperEllipsesWidthFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleInnerSuperEllipsesWidth(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfInnerSuperEllipsesWidth,
             this->getType().getFieldDesc(InnerSuperEllipsesWidthFieldId),
             this));


    editMField(InnerSuperEllipsesWidthFieldMask, _mfInnerSuperEllipsesWidth);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleInnerSuperEllipsesHeight (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfInnerSuperEllipsesHeight,
             this->getType().getFieldDesc(InnerSuperEllipsesHeightFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleInnerSuperEllipsesHeight(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfInnerSuperEllipsesHeight,
             this->getType().getFieldDesc(InnerSuperEllipsesHeightFieldId),
             this));


    editMField(InnerSuperEllipsesHeightFieldMask, _mfInnerSuperEllipsesHeight);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleOuterSuperEllipsesWidth (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfOuterSuperEllipsesWidth,
             this->getType().getFieldDesc(OuterSuperEllipsesWidthFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleOuterSuperEllipsesWidth(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfOuterSuperEllipsesWidth,
             this->getType().getFieldDesc(OuterSuperEllipsesWidthFieldId),
             this));


    editMField(OuterSuperEllipsesWidthFieldMask, _mfOuterSuperEllipsesWidth);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleOuterSuperEllipsesHeight (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfOuterSuperEllipsesHeight,
             this->getType().getFieldDesc(OuterSuperEllipsesHeightFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleOuterSuperEllipsesHeight(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfOuterSuperEllipsesHeight,
             this->getType().getFieldDesc(OuterSuperEllipsesHeightFieldId),
             this));


    editMField(OuterSuperEllipsesHeightFieldMask, _mfOuterSuperEllipsesHeight);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSuperEllipsesRoundness (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSuperEllipsesRoundness,
             this->getType().getFieldDesc(SuperEllipsesRoundnessFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSuperEllipsesRoundness(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSuperEllipsesRoundness,
             this->getType().getFieldDesc(SuperEllipsesRoundnessFieldId),
             this));


    editMField(SuperEllipsesRoundnessFieldMask, _mfSuperEllipsesRoundness);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleSuperEllipsesTwist (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfSuperEllipsesTwist,
             this->getType().getFieldDesc(SuperEllipsesTwistFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleSuperEllipsesTwist(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfSuperEllipsesTwist,
             this->getType().getFieldDesc(SuperEllipsesTwistFieldId),
             this));


    editMField(SuperEllipsesTwistFieldMask, _mfSuperEllipsesTwist);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeCutOn      (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeCutOn,
             this->getType().getFieldDesc(RangeCutOnFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeCutOn     (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeCutOn,
             this->getType().getFieldDesc(RangeCutOnFieldId),
             this));


    editMField(RangeCutOnFieldMask, _mfRangeCutOn);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeCutOff     (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeCutOff,
             this->getType().getFieldDesc(RangeCutOffFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeCutOff    (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeCutOff,
             this->getType().getFieldDesc(RangeCutOffFieldId),
             this));


    editMField(RangeCutOffFieldMask, _mfRangeCutOff);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeNearZone   (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeNearZone,
             this->getType().getFieldDesc(RangeNearZoneFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeNearZone  (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeNearZone,
             this->getType().getFieldDesc(RangeNearZoneFieldId),
             this));


    editMField(RangeNearZoneFieldMask, _mfRangeNearZone);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleRangeFarZone    (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfRangeFarZone,
             this->getType().getFieldDesc(RangeFarZoneFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleRangeFarZone   (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfRangeFarZone,
             this->getType().getFieldDesc(RangeFarZoneFieldId),
             this));


    editMField(RangeFarZoneFieldMask, _mfRangeFarZone);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleProjectionMatrix (void) const
{
    MFMatrix::GetHandlePtr returnValue(
        new  MFMatrix::GetHandle(
             &_mfProjectionMatrix,
             this->getType().getFieldDesc(ProjectionMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleProjectionMatrix(void)
{
    MFMatrix::EditHandlePtr returnValue(
        new  MFMatrix::EditHandle(
             &_mfProjectionMatrix,
             this->getType().getFieldDesc(ProjectionMatrixFieldId),
             this));


    editMField(ProjectionMatrixFieldMask, _mfProjectionMatrix);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleTypeOfLight     (void) const
{
    MFUInt8::GetHandlePtr returnValue(
        new  MFUInt8::GetHandle(
             &_mfTypeOfLight,
             this->getType().getFieldDesc(TypeOfLightFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleTypeOfLight    (void)
{
    MFUInt8::EditHandlePtr returnValue(
        new  MFUInt8::EditHandle(
             &_mfTypeOfLight,
             this->getType().getFieldDesc(TypeOfLightFieldId),
             this));


    editMField(TypeOfLightFieldMask, _mfTypeOfLight);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleEnabled         (void) const
{
    MFBool::GetHandlePtr returnValue(
        new  MFBool::GetHandle(
             &_mfEnabled,
             this->getType().getFieldDesc(EnabledFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleEnabled        (void)
{
    MFBool::EditHandlePtr returnValue(
        new  MFBool::EditHandle(
             &_mfEnabled,
             this->getType().getFieldDesc(EnabledFieldId),
             this));


    editMField(EnabledFieldMask, _mfEnabled);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleShadow          (void) const
{
    MFBool::GetHandlePtr returnValue(
        new  MFBool::GetHandle(
             &_mfShadow,
             this->getType().getFieldDesc(ShadowFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleShadow         (void)
{
    MFBool::EditHandlePtr returnValue(
        new  MFBool::EditHandle(
             &_mfShadow,
             this->getType().getFieldDesc(ShadowFieldId),
             this));


    editMField(ShadowFieldMask, _mfShadow);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleShadowDataIndex (void) const
{
    MFInt32::GetHandlePtr returnValue(
        new  MFInt32::GetHandle(
             &_mfShadowDataIndex,
             this->getType().getFieldDesc(ShadowDataIndexFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleShadowDataIndex(void)
{
    MFInt32::EditHandlePtr returnValue(
        new  MFInt32::EditHandle(
             &_mfShadowDataIndex,
             this->getType().getFieldDesc(ShadowDataIndexFieldId),
             this));


    editMField(ShadowDataIndexFieldMask, _mfShadowDataIndex);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleShadowParameterIndex (void) const
{
    MFInt32::GetHandlePtr returnValue(
        new  MFInt32::GetHandle(
             &_mfShadowParameterIndex,
             this->getType().getFieldDesc(ShadowParameterIndexFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleShadowParameterIndex(void)
{
    MFInt32::EditHandlePtr returnValue(
        new  MFInt32::EditHandle(
             &_mfShadowParameterIndex,
             this->getType().getFieldDesc(ShadowParameterIndexFieldId),
             this));


    editMField(ShadowParameterIndexFieldMask, _mfShadowParameterIndex);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleBeacon          (void) const
{
    MFWeakNodePtr::GetHandlePtr returnValue(
        new  MFWeakNodePtr::GetHandle(
             &_mfBeacon,
             this->getType().getFieldDesc(BeaconFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleBeacon         (void)
{
    MFWeakNodePtr::EditHandlePtr returnValue(
        new  MFWeakNodePtr::EditHandle(
             &_mfBeacon,
             this->getType().getFieldDesc(BeaconFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&MultiLightChunk::pushToBeacon,
                    static_cast<MultiLightChunk *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveMethod(
        boost::bind(&MultiLightChunk::removeFromBeacon,
                    static_cast<MultiLightChunk *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveObjMethod(
        boost::bind(&MultiLightChunk::removeObjFromBeacon,
                    static_cast<MultiLightChunk *>(this), ::boost::placeholders::_1));
    returnValue->setClearMethod(
        boost::bind(&MultiLightChunk::clearBeacon,
                    static_cast<MultiLightChunk *>(this)));

    editMField(BeaconFieldMask, _mfBeacon);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleNormalizeDirection (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfNormalizeDirection,
             this->getType().getFieldDesc(NormalizeDirectionFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleNormalizeDirection(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfNormalizeDirection,
             this->getType().getFieldDesc(NormalizeDirectionFieldId),
             this));


    editSField(NormalizeDirectionFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleBeaconMatrix    (void) const
{
    MFMatrix::GetHandlePtr returnValue(
        new  MFMatrix::GetHandle(
             &_mfBeaconMatrix,
             this->getType().getFieldDesc(BeaconMatrixFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleBeaconMatrix   (void)
{
    MFMatrix::EditHandlePtr returnValue(
        new  MFMatrix::EditHandle(
             &_mfBeaconMatrix,
             this->getType().getFieldDesc(BeaconMatrixFieldId),
             this));


    editMField(BeaconMatrixFieldMask, _mfBeaconMatrix);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLastCamNear     (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfLastCamNear,
             this->getType().getFieldDesc(LastCamNearFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLastCamNear    (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfLastCamNear,
             this->getType().getFieldDesc(LastCamNearFieldId),
             this));


    editSField(LastCamNearFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLastCamFar      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfLastCamFar,
             this->getType().getFieldDesc(LastCamFarFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLastCamFar     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfLastCamFar,
             this->getType().getFieldDesc(LastCamFarFieldId),
             this));


    editSField(LastCamFarFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLastCamToWorld  (void) const
{
    SFMatrix::GetHandlePtr returnValue(
        new  SFMatrix::GetHandle(
             &_sfLastCamToWorld,
             this->getType().getFieldDesc(LastCamToWorldFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLastCamToWorld (void)
{
    SFMatrix::EditHandlePtr returnValue(
        new  SFMatrix::EditHandle(
             &_sfLastCamToWorld,
             this->getType().getFieldDesc(LastCamToWorldFieldId),
             this));


    editSField(LastCamToWorldFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLightBlockName  (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfLightBlockName,
             this->getType().getFieldDesc(LightBlockNameFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLightBlockName (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfLightBlockName,
             this->getType().getFieldDesc(LightBlockNameFieldId),
             this));


    editSField(LightBlockNameFieldMask);

    return returnValue;
}

GetFieldHandlePtr MultiLightChunkBase::getHandleLightVariableName (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfLightVariableName,
             this->getType().getFieldDesc(LightVariableNameFieldId),
             const_cast<MultiLightChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MultiLightChunkBase::editHandleLightVariableName(void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfLightVariableName,
             this->getType().getFieldDesc(LightVariableNameFieldId),
             this));


    editSField(LightVariableNameFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void MultiLightChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    MultiLightChunk *pThis = static_cast<MultiLightChunk *>(this);

    pThis->execSync(static_cast<MultiLightChunk *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *MultiLightChunkBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    MultiLightChunk *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const MultiLightChunk *>(pRefAspect),
                  dynamic_cast<const MultiLightChunk *>(this));

    return returnValue;
}
#endif

void MultiLightChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<MultiLightChunk *>(this)->clearBeacon();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfPosition.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfDirection.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfAmbientIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfDiffuseIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSpecularIntensity.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfAttenuation.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfDecayAttenuation.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfLengthFactor.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSpotlightAngle.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSpotExponent.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfInnerSuperEllipsesWidth.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfInnerSuperEllipsesHeight.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfOuterSuperEllipsesWidth.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfOuterSuperEllipsesHeight.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSuperEllipsesRoundness.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfSuperEllipsesTwist.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeCutOn.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeCutOff.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeNearZone.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfRangeFarZone.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfProjectionMatrix.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfTypeOfLight.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfEnabled.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfShadow.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfShadowDataIndex.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfShadowParameterIndex.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfBeaconMatrix.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
