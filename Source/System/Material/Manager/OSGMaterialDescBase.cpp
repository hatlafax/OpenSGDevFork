/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class MaterialDesc!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"


#include "OSGGL.h"                        // CullFace default header
#include "OSGGL.h"                        // FrontFace default header
#include "OSGGL.h"                        // FrontMode default header
#include "OSGGL.h"                        // BackMode default header

#include "OSGTextureDesc.h"             // TextureDesc Class

#include "OSGMaterialDescBase.h"
#include "OSGMaterialDesc.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::MaterialDesc
    This class provides a sufficient broad collection of material parameters.
    It allows to define texture stacks for different texture types. This
    description class has been designed among other things  to be compatible
    with the Assimp library material description. In order to fully utilize 
    the description a sophisticated material and shader backend is needed.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var std::string     MaterialDescBase::_sfName
    The name of the material, if available.
*/

/*! \var UInt64          MaterialDescBase::_sfDescHash
    Additional hash value that allows to discriminate different
    MaterialDesc instances with otherwise identical field values.
    A MaterialDesc object, for instance, is used to build a DescMaterial
    instance. Typically, these are managed in order to allow material
    sharing. Sometimes, however, a separate DescMaterial for identical
    MaterialDesc objects is needed. This field allows to provide an
    additional descriminator.
*/

/*! \var UInt32          MaterialDescBase::_sfModeFlags
    A number of boolean material modes. For each mode a set and get function is provided.
    SRGB_COLOR_MODE
    Any non texture material color value is regarded as an sRGB color space value.
    This flag is enabled on default.
    SHADOW_ONLY_MODE
    The material is only visible in regions that are shadowed.
    PBR_SPECULAR_MODE
    The material evaluates the specular workflow in COOK_TORRANCE_SHADING model.
    UNLIT_MODE
    The material does not participate in any lighting calculations.
    HAS_NORMALS_MODE
    Specifies whether the mesh vertices have normals attached to it.
    HAS_TANGENTS_AND_BITANGENTS_MODE
    Specifies whether the mesh vertices have tangents and bitangets attached to it.
    FLAT_SHADING_MODE
    Enables flat shading, i.e. the use if the vertice normal vectors without fragment interpolation.
    OFFSET_POINT_MODE
    Enables offsetting for points.
    OFFSET_LINE_MODE
    Enables offsetting for lines.
    OFFSET_FILL_MODE
    Enables offsetting for polygons.
    XOR_MODE
    The material shoud set the xor-Render mode specified by a LogicOpChunk.
    NO_DEPTH_TEST_MODE
    The material contains a DepthChunk which is not enabled.
    PBR_CLEAR_COAT_MODE
    The PBR material should evaluate clear coat information.
    PBR_SHEEN_COLOR_MODE
    The PBR material should evaluate sheen color information.
    PBR_ANISOTROPY_MODE
    The PBR material should evaluate anisotropy information.
*/

/*! \var UInt32          MaterialDescBase::_sfNumUVChannels
    The number of UV channes, i.e. texture coordinates that the material must support.
    This is mesh information but needed for proper shader code generation.
*/

/*! \var UInt8           MaterialDescBase::_mfUVDimension
    The dimensionality of each of the UV channes, i.e. texture coordinates that the
    material supports. Allowed values are 1, 2 or 3.
    This is mesh information but needed for proper shader code generation.
*/

/*! \var UInt32          MaterialDescBase::_sfNumColorChannels
    The number of separate color channes that the material must support.
    This is mesh information but needed for proper shader code generation.
*/

/*! \var UInt32          MaterialDescBase::_sfShadingModel
    This value defines the shading model that should be used for shading
    with this material. Allowed values are found in the ShadingModel enumeration
    in the header file, e.g. NO_SHADING_MODEL, GOURAUD_SHADING_MODEL, PHONG_SHADING_MODEL,
    BLINN_PHONG_SHADING_MODEL, COOK_TORRANCE_SHADING_MODEL, OREN_NAYAR_SHADING_MODEL, 
    TOON_SHADING_MODEL, GOOCH_SHADING_MODEL.
*/

/*! \var UInt32          MaterialDescBase::_sfOverrideShadingModel
    This value defines the shading model that took presedence over the actual shading model.
    This is useful for instance if the material should temporarily be shaded with another
    shading model. This can e.g. be used for a global GOOCH shading task. This value only
    takes place if is not equal to NO_SHADING_MODEL.
*/

/*! \var UInt32          MaterialDescBase::_sfBlendMode
    Defines how the final color value in the screen buffer is computed from the given 
    color at that position and the newly computed color from the material. Simply said, 
    alpha blending settings. Allowed values are DEFAULT_BLEND_MODE and ADDITIVE_BLEND_MODE.
*/

/*! \var Color3f         MaterialDescBase::_sfEmissive
    The emissive color for the material.
*/

/*! \var Color3f         MaterialDescBase::_sfAlbedo
    The albedo (diffuse) color for the material.
*/

/*! \var Color3f         MaterialDescBase::_sfSpecular
    The specular color for the material.
*/

/*! \var Color3f         MaterialDescBase::_sfTransparent
    Defines the transparent color of the material, this is the color to be multiplied with
    the color of translucent light to construct the final 'destination color' for a particular 
    position in the screen buffer.
*/

/*! \var Color3f         MaterialDescBase::_sfReflective
    Defines the reflective color of the material. This is typically scaled by the amount of 
    incoming light from the direction of mirror reflection. Usually combined with an enviroment
    lightmap.
*/

/*! \var Real32          MaterialDescBase::_sfSpecularStrength
    Scales the specular color of the material.
    This value is kept separate from the specular color by most modelers, and so do we.
*/

/*! \var Real32          MaterialDescBase::_sfEmissiveStrength
    Scales the emissive color of the material.
*/

/*! \var Real32          MaterialDescBase::_sfOpacity
    Defines how transparent objects are rendered with this material.
    Use this value to decide whether you have to activate alpha blending 
    for rendering. opacity != 1 usually also implies twosided=true to avoid 
    cull artifacts.
*/

/*! \var Real32          MaterialDescBase::_sfOpacityCutOff
    Any opacity value less than this value is set to zero. This allows to
    fight certain artifacts when using opacity textures.
*/

/*! \var UInt32          MaterialDescBase::_sfOpacityMode
    This mode governs the interpretation of the opacity value. It can have the
    following values:
    NO_OPACITY_MODE     - The mode is not evaluated. Standard handling takes place.
    This is the default value.
    OPAQUE_OPACITY_MODE - The rendered output is fully opaque and any alpha value
    is ignored. A depth value is written for every pixel and mesh sorting is
    not required for correct output.
    MASK_OPACITY_MODE   - The rendered output is either fully opaque or fully 
    transparent depending on the alpha value and the specified opacity cutoff
    value.
    If the alpha value is greater than or equal to the alphaCutoff value then
    it is rendered as fully opaque, otherwise, it is rendered as fully transparent.
    A depth value is not written for a pixel that is discarded after the alpha test.
    A depth value is written for all other pixels. Mesh sorting is not required 
    for correct output.
    BLEND_OPACITY_MODE  - The rendered output is combined with the background using
    the normal painting operation.
    Whether depth value is written or whether to sort is up to the implementation.
*/

/*! \var Real32          MaterialDescBase::_sfReflectivity
    Scales the reflective color of the material.
*/

/*! \var Real32          MaterialDescBase::_sfReflectance
    Defines the perceptual reflectance R at normal incidance according to the fresnel law.
    The perceptual reflectance R relates to the physical reflectance f0 = (n-1)^2 / (n+1)^2
    by the equation f0 = 0.16 * R^2, where n is the optical index of refraction for dielectric
    materials. It follows that R = sqrt(f0/0.16) = 2.5 * (n-1)/(n+1) or n = 2/(1-sqrt(f0)) - 1.
*/

/*! \var Real32          MaterialDescBase::_sfBumpScaling
    Bump height scaling.
*/

/*! \var Real32          MaterialDescBase::_sfAnisotropy
    Anisotropy parameter in the range of [-1,1]
*/

/*! \var Real32          MaterialDescBase::_sfRoughness
    The 'Perceived roughness Rp' for the material. The 'micro facet model roughness Ra' is calculated
    from the 'Perceived roughness Rp' by equation: Ra = Rp^2.
    The 'Perceived roughness Rp' is a more user friendly parameter then model roughness Ra.
    This is used in a PBR shader but has no use in a classical shading model.
*/

/*! \var Real32          MaterialDescBase::_sfMetalness
    The metalness for the material. This is used in a PBR shader but has
    no use in a classical shading model.
*/

/*! \var Real32          MaterialDescBase::_sfClearCoatStrength
    Strength of the clear coat layer. This value is expected to be in range [0,1].
    This is used in a PBR shader but has no use in a classical shading model.
*/

/*! \var Real32          MaterialDescBase::_sfClearCoatRoughness
    Perceived smoothness or roughness of the clear coat layer. This value is expected to be in range [0,1].
    This is used in a PBR shader but has no use in a classical shading model.
*/

/*! \var Color3f         MaterialDescBase::_sfSheenColor
    Specular tint to create two-tone specular fabrics (defaults to 0.04 to match the standard reflectance).
    This is used in a PBR shader but has no use in a classical shading model.
*/

/*! \var Color3f         MaterialDescBase::_sfSubSurfaceColor
    Tint for the diffuse color after scattering and absorption through the material.
    This is used in a PBR shader but has no use in a classical shading model.
*/

/*! \var Int32           MaterialDescBase::_sfToonLevels
    The number of Toon levels for the material used by Toon shading.
*/

/*! \var Color3f         MaterialDescBase::_sfGoochCool
    The cool Gooch color used for Gooch shading.
*/

/*! \var Color3f         MaterialDescBase::_sfGoochWarm
    The warm Gooch color used for Gooch shading.
*/

/*! \var Real32          MaterialDescBase::_sfGoochMixin
    The mix factor used for Gooch shading.
*/

/*! \var Real32          MaterialDescBase::_sfGoochCoolMixin
    The mix factor used for adapting the cool color in Gooch shading
    with respect to the albedo color.
*/

/*! \var Real32          MaterialDescBase::_sfGoochWarmMixin
    The mix factor used for adapting the warm color in Gooch shading
    with respect to the albedo color.
*/

/*! \var GLenum          MaterialDescBase::_sfCullFace
    Defines which side of the polygon is invisible. Set to GL_NONE to not cull anything. See glCullFace.
    Allowed values: GL_NONE,GL_FRONT,GL_BACK,GL_FRONT_AND_BACK
*/

/*! \var GLenum          MaterialDescBase::_sfFrontFace
    Defines which side of the polygon is considered the front side base on vertex ordering
    of clockwise (CW) of counter clockwise (CCW). defaults to GL_CCW.  See glFrontFace.
    Allowed values: GL_CCW,GL_CW
*/

/*! \var GLenum          MaterialDescBase::_sfFrontMode
    Defines if polygon front sides are rendered filled (default), outlined or as points. See glPolygonMode.
    Allowed values: GL_FILL,GL_LINE,GL_POINT
*/

/*! \var GLenum          MaterialDescBase::_sfBackMode
    Defines if polygon front sides are rendered filled (default), outlined or as points. See glPolygonMode.
    Allowed values: GL_FILL,GL_LINE,GL_POINT
*/

/*! \var Real32          MaterialDescBase::_sfOffsetFactor
    Defines the polygon offset factor. See glPolygonOffset.
*/

/*! \var Real32          MaterialDescBase::_sfOffsetBias
    Defines the polygon offset bias. See glPolygonOffset.
*/

/*! \var TextureDesc *   MaterialDescBase::_mfTextureDesc
    The list of material textures.
*/

/*! \var BitVector       MaterialDescBase::_sfExcludeHashingMask
    All field mask that are contained in this value do not participate in the
    hash calculation procedure.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<MaterialDesc *, nsOSG>::_type(
    "MaterialDescPtr", 
    "FieldContainerPtr", 
    MaterialDesc::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(MaterialDesc *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           MaterialDesc *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           MaterialDesc *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void MaterialDescBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFString::Description(
        SFString::getClassType(),
        "name",
        "The name of the material, if available.\n",
        NameFieldId, NameFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleName),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleName));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt64::Description(
        SFUInt64::getClassType(),
        "descHash",
        "Additional hash value that allows to discriminate different\n"
        "MaterialDesc instances with otherwise identical field values.\n"
        "A MaterialDesc object, for instance, is used to build a DescMaterial\n"
        "instance. Typically, these are managed in order to allow material\n"
        "sharing. Sometimes, however, a separate DescMaterial for identical\n"
        "MaterialDesc objects is needed. This field allows to provide an\n"
        "additional descriminator.\n",
        DescHashFieldId, DescHashFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleDescHash),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleDescHash));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "modeFlags",
        "A number of boolean material modes. For each mode a set and get function is provided.\n"
        "SRGB_COLOR_MODE\n"
        "Any non texture material color value is regarded as an sRGB color space value.\n"
        "This flag is enabled on default.\n"
        "SHADOW_ONLY_MODE\n"
        "The material is only visible in regions that are shadowed.\n"
        "PBR_SPECULAR_MODE\n"
        "The material evaluates the specular workflow in COOK_TORRANCE_SHADING model.\n"
        "UNLIT_MODE\n"
        "The material does not participate in any lighting calculations.\n"
        "HAS_NORMALS_MODE\n"
        "Specifies whether the mesh vertices have normals attached to it.\n"
        "HAS_TANGENTS_AND_BITANGENTS_MODE\n"
        "Specifies whether the mesh vertices have tangents and bitangets attached to it.\n"
        "FLAT_SHADING_MODE\n"
        "Enables flat shading, i.e. the use if the vertice normal vectors without fragment interpolation.\n"
        "OFFSET_POINT_MODE\n"
        "Enables offsetting for points.\n"
        "OFFSET_LINE_MODE\n"
        "Enables offsetting for lines.\n"
        "OFFSET_FILL_MODE\n"
        "Enables offsetting for polygons.\n"
        "XOR_MODE\n"
        "The material shoud set the xor-Render mode specified by a LogicOpChunk.\n"
        "NO_DEPTH_TEST_MODE\n"
        "The material contains a DepthChunk which is not enabled.\n"
        "PBR_CLEAR_COAT_MODE\n"
        "The PBR material should evaluate clear coat information.\n"
        "PBR_SHEEN_COLOR_MODE\n"
        "The PBR material should evaluate sheen color information.\n"
        "PBR_ANISOTROPY_MODE\n"
        "The PBR material should evaluate anisotropy information.\n",
        ModeFlagsFieldId, ModeFlagsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleModeFlags),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleModeFlags));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "numUVChannels",
        "The number of UV channes, i.e. texture coordinates that the material must support.\n"
        "This is mesh information but needed for proper shader code generation.\n",
        NumUVChannelsFieldId, NumUVChannelsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleNumUVChannels),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleNumUVChannels));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(),
        "UVDimension",
        "The dimensionality of each of the UV channes, i.e. texture coordinates that the\n"
        "material supports. Allowed values are 1, 2 or 3.\n"
        "This is mesh information but needed for proper shader code generation.\n",
        UVDimensionFieldId, UVDimensionFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleUVDimension),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleUVDimension));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "numColorChannels",
        "The number of separate color channes that the material must support.\n"
        "This is mesh information but needed for proper shader code generation.\n",
        NumColorChannelsFieldId, NumColorChannelsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleNumColorChannels),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleNumColorChannels));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "shadingModel",
        "This value defines the shading model that should be used for shading\n"
        "with this material. Allowed values are found in the ShadingModel enumeration\n"
        "in the header file, e.g. NO_SHADING_MODEL, GOURAUD_SHADING_MODEL, PHONG_SHADING_MODEL,\n"
        "BLINN_PHONG_SHADING_MODEL, COOK_TORRANCE_SHADING_MODEL, OREN_NAYAR_SHADING_MODEL, \n"
        "TOON_SHADING_MODEL, GOOCH_SHADING_MODEL.\n",
        ShadingModelFieldId, ShadingModelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleShadingModel),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleShadingModel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "overrideShadingModel",
        "This value defines the shading model that took presedence over the actual shading model.\n"
        "This is useful for instance if the material should temporarily be shaded with another\n"
        "shading model. This can e.g. be used for a global GOOCH shading task. This value only\n"
        "takes place if is not equal to NO_SHADING_MODEL.\n",
        OverrideShadingModelFieldId, OverrideShadingModelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleOverrideShadingModel),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleOverrideShadingModel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "blendMode",
        "Defines how the final color value in the screen buffer is computed from the given \n"
        "color at that position and the newly computed color from the material. Simply said, \n"
        "alpha blending settings. Allowed values are DEFAULT_BLEND_MODE and ADDITIVE_BLEND_MODE.\n",
        BlendModeFieldId, BlendModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleBlendMode),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleBlendMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "emissive",
        "The emissive color for the material.\n",
        EmissiveFieldId, EmissiveFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleEmissive),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleEmissive));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "albedo",
        "The albedo (diffuse) color for the material.\n",
        AlbedoFieldId, AlbedoFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleAlbedo),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleAlbedo));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "specular",
        "The specular color for the material.\n",
        SpecularFieldId, SpecularFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleSpecular),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleSpecular));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "transparent",
        "Defines the transparent color of the material, this is the color to be multiplied with\n"
        "the color of translucent light to construct the final 'destination color' for a particular \n"
        "position in the screen buffer.\n",
        TransparentFieldId, TransparentFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleTransparent),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleTransparent));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "reflective",
        "Defines the reflective color of the material. This is typically scaled by the amount of \n"
        "incoming light from the direction of mirror reflection. Usually combined with an enviroment\n"
        "lightmap.\n",
        ReflectiveFieldId, ReflectiveFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleReflective),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleReflective));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "specularStrength",
        "Scales the specular color of the material.\n"
        "This value is kept separate from the specular color by most modelers, and so do we.\n",
        SpecularStrengthFieldId, SpecularStrengthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleSpecularStrength),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleSpecularStrength));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "emissiveStrength",
        "Scales the emissive color of the material.\n",
        EmissiveStrengthFieldId, EmissiveStrengthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleEmissiveStrength),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleEmissiveStrength));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "opacity",
        "Defines how transparent objects are rendered with this material.\n"
        "Use this value to decide whether you have to activate alpha blending \n"
        "for rendering. opacity != 1 usually also implies twosided=true to avoid \n"
        "cull artifacts.\n",
        OpacityFieldId, OpacityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleOpacity),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleOpacity));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "opacityCutOff",
        "Any opacity value less than this value is set to zero. This allows to\n"
        "fight certain artifacts when using opacity textures.\n",
        OpacityCutOffFieldId, OpacityCutOffFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleOpacityCutOff),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleOpacityCutOff));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "opacityMode",
        "This mode governs the interpretation of the opacity value. It can have the\n"
        "following values:\n"
        "NO_OPACITY_MODE     - The mode is not evaluated. Standard handling takes place.\n"
        "This is the default value.\n"
        "OPAQUE_OPACITY_MODE - The rendered output is fully opaque and any alpha value\n"
        "is ignored. A depth value is written for every pixel and mesh sorting is\n"
        "not required for correct output.\n"
        "MASK_OPACITY_MODE   - The rendered output is either fully opaque or fully \n"
        "transparent depending on the alpha value and the specified opacity cutoff\n"
        "value.\n"
        "If the alpha value is greater than or equal to the alphaCutoff value then\n"
        "it is rendered as fully opaque, otherwise, it is rendered as fully transparent.\n"
        "A depth value is not written for a pixel that is discarded after the alpha test.\n"
        "A depth value is written for all other pixels. Mesh sorting is not required \n"
        "for correct output.\n"
        "BLEND_OPACITY_MODE  - The rendered output is combined with the background using\n"
        "the normal painting operation.\n"
        "Whether depth value is written or whether to sort is up to the implementation.\n",
        OpacityModeFieldId, OpacityModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleOpacityMode),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleOpacityMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "reflectivity",
        "Scales the reflective color of the material.\n",
        ReflectivityFieldId, ReflectivityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleReflectivity),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleReflectivity));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "reflectance",
        "Defines the perceptual reflectance R at normal incidance according to the fresnel law.\n"
        "The perceptual reflectance R relates to the physical reflectance f0 = (n-1)^2 / (n+1)^2\n"
        "by the equation f0 = 0.16 * R^2, where n is the optical index of refraction for dielectric\n"
        "materials. It follows that R = sqrt(f0/0.16) = 2.5 * (n-1)/(n+1) or n = 2/(1-sqrt(f0)) - 1.\n",
        ReflectanceFieldId, ReflectanceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleReflectance),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleReflectance));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "bumpScaling",
        "Bump height scaling.\n",
        BumpScalingFieldId, BumpScalingFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleBumpScaling),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleBumpScaling));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "Anisotropy",
        "Anisotropy parameter in the range of [-1,1]\n",
        AnisotropyFieldId, AnisotropyFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleAnisotropy),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleAnisotropy));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "roughness",
        "The 'Perceived roughness Rp' for the material. The 'micro facet model roughness Ra' is calculated\n"
        "from the 'Perceived roughness Rp' by equation: Ra = Rp^2.\n"
        "The 'Perceived roughness Rp' is a more user friendly parameter then model roughness Ra.\n"
        "This is used in a PBR shader but has no use in a classical shading model.\n",
        RoughnessFieldId, RoughnessFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleRoughness),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleRoughness));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "metalness",
        "The metalness for the material. This is used in a PBR shader but has\n"
        "no use in a classical shading model.\n",
        MetalnessFieldId, MetalnessFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleMetalness),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleMetalness));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "clearCoatStrength",
        "Strength of the clear coat layer. This value is expected to be in range [0,1].\n"
        "This is used in a PBR shader but has no use in a classical shading model.\n",
        ClearCoatStrengthFieldId, ClearCoatStrengthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleClearCoatStrength),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleClearCoatStrength));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "clearCoatRoughness",
        "Perceived smoothness or roughness of the clear coat layer. This value is expected to be in range [0,1].\n"
        "This is used in a PBR shader but has no use in a classical shading model.\n",
        ClearCoatRoughnessFieldId, ClearCoatRoughnessFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleClearCoatRoughness),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleClearCoatRoughness));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "sheenColor",
        "Specular tint to create two-tone specular fabrics (defaults to 0.04 to match the standard reflectance).\n"
        "This is used in a PBR shader but has no use in a classical shading model.\n",
        SheenColorFieldId, SheenColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleSheenColor),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleSheenColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "subSurfaceColor",
        "Tint for the diffuse color after scattering and absorption through the material.\n"
        "This is used in a PBR shader but has no use in a classical shading model.\n",
        SubSurfaceColorFieldId, SubSurfaceColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleSubSurfaceColor),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleSubSurfaceColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "toonLevels",
        "The number of Toon levels for the material used by Toon shading.\n",
        ToonLevelsFieldId, ToonLevelsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleToonLevels),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleToonLevels));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "goochCool",
        "The cool Gooch color used for Gooch shading.\n",
        GoochCoolFieldId, GoochCoolFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleGoochCool),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleGoochCool));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "goochWarm",
        "The warm Gooch color used for Gooch shading.\n",
        GoochWarmFieldId, GoochWarmFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleGoochWarm),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleGoochWarm));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "goochMixin",
        "The mix factor used for Gooch shading.\n",
        GoochMixinFieldId, GoochMixinFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleGoochMixin),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleGoochMixin));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "goochCoolMixin",
        "The mix factor used for adapting the cool color in Gooch shading\n"
        "with respect to the albedo color.\n",
        GoochCoolMixinFieldId, GoochCoolMixinFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleGoochCoolMixin),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleGoochCoolMixin));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "goochWarmMixin",
        "The mix factor used for adapting the warm color in Gooch shading\n"
        "with respect to the albedo color.\n",
        GoochWarmMixinFieldId, GoochWarmMixinFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleGoochWarmMixin),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleGoochWarmMixin));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "cullFace",
        "Defines which side of the polygon is invisible. Set to GL_NONE to not cull anything. See glCullFace.\n"
        "Allowed values: GL_NONE,GL_FRONT,GL_BACK,GL_FRONT_AND_BACK\n",
        CullFaceFieldId, CullFaceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleCullFace),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleCullFace));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "frontFace",
        "Defines which side of the polygon is considered the front side base on vertex ordering\n"
        "of clockwise (CW) of counter clockwise (CCW). defaults to GL_CCW.  See glFrontFace.\n"
        "Allowed values: GL_CCW,GL_CW\n",
        FrontFaceFieldId, FrontFaceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleFrontFace),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleFrontFace));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "frontMode",
        "Defines if polygon front sides are rendered filled (default), outlined or as points. See glPolygonMode.\n"
        "Allowed values: GL_FILL,GL_LINE,GL_POINT\n",
        FrontModeFieldId, FrontModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleFrontMode),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleFrontMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "backMode",
        "Defines if polygon front sides are rendered filled (default), outlined or as points. See glPolygonMode.\n"
        "Allowed values: GL_FILL,GL_LINE,GL_POINT\n",
        BackModeFieldId, BackModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleBackMode),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleBackMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offsetFactor",
        "Defines the polygon offset factor. See glPolygonOffset.\n",
        OffsetFactorFieldId, OffsetFactorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleOffsetFactor),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleOffsetFactor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offsetBias",
        "Defines the polygon offset bias. See glPolygonOffset.\n",
        OffsetBiasFieldId, OffsetBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleOffsetBias),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleOffsetBias));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecTextureDescPtr::Description(
        MFUnrecTextureDescPtr::getClassType(),
        "textureDesc",
        "The list of material textures.\n",
        TextureDescFieldId, TextureDescFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleTextureDesc),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleTextureDesc));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBitVector::Description(
        SFBitVector::getClassType(),
        "excludeHashingMask",
        "All field mask that are contained in this value do not participate in the\n"
        "hash calculation procedure.\n",
        ExcludeHashingMaskFieldId, ExcludeHashingMaskFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&MaterialDesc::editHandleExcludeHashingMask),
        static_cast<FieldGetMethodSig >(&MaterialDesc::getHandleExcludeHashingMask));

    oType.addInitialDesc(pDesc);
}


MaterialDescBase::TypeObject MaterialDescBase::_type(
    MaterialDescBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&MaterialDescBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&MaterialDesc::initMethod),
    reinterpret_cast<ExitContainerF>(&MaterialDesc::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&MaterialDesc::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"MaterialDesc\"\n"
    "    parent=\"FieldContainer\"\n"
    "    library=\"System\"\n"
    "    structure=\"concrete\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    docGroupBase=\"GrpSystemMaterial\"\n"
    "    >\n"
    "    This class provides a sufficient broad collection of material parameters.\n"
    "    It allows to define texture stacks for different texture types. This\n"
    "    description class has been designed among other things  to be compatible\n"
    "    with the Assimp library material description. In order to fully utilize \n"
    "    the description a sophisticated material and shader backend is needed.\n"
    "\n"
    "    <Field\n"
    "        name=\"name\"\n"
    "        type=\"std::string\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"\"\n"
    "        >\n"
    "        The name of the material, if available.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"descHash\"\n"
    "        type=\"UInt64\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Additional hash value that allows to discriminate different\n"
    "        MaterialDesc instances with otherwise identical field values.\n"
    "        A MaterialDesc object, for instance, is used to build a DescMaterial\n"
    "        instance. Typically, these are managed in order to allow material\n"
    "        sharing. Sometimes, however, a separate DescMaterial for identical\n"
    "        MaterialDesc objects is needed. This field allows to provide an\n"
    "        additional descriminator.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"modeFlags\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        defaultValue=\"0x01\"\n"
    "        >\n"
    "        A number of boolean material modes. For each mode a set and get function is provided.\n"
    "            SRGB_COLOR_MODE\n"
    "                Any non texture material color value is regarded as an sRGB color space value.\n"
    "                This flag is enabled on default.\n"
    "            SHADOW_ONLY_MODE\n"
    "                The material is only visible in regions that are shadowed.\n"
    "            PBR_SPECULAR_MODE\n"
    "                The material evaluates the specular workflow in COOK_TORRANCE_SHADING model.\n"
    "            UNLIT_MODE\n"
    "                The material does not participate in any lighting calculations.\n"
    "            HAS_NORMALS_MODE\n"
    "                Specifies whether the mesh vertices have normals attached to it.\n"
    "            HAS_TANGENTS_AND_BITANGENTS_MODE\n"
    "                Specifies whether the mesh vertices have tangents and bitangets attached to it.\n"
    "            FLAT_SHADING_MODE\n"
    "                Enables flat shading, i.e. the use if the vertice normal vectors without fragment interpolation.\n"
    "            OFFSET_POINT_MODE\n"
    "                Enables offsetting for points.\n"
    "            OFFSET_LINE_MODE\n"
    "                Enables offsetting for lines.\n"
    "            OFFSET_FILL_MODE\n"
    "                Enables offsetting for polygons.\n"
    "            XOR_MODE\n"
    "                The material shoud set the xor-Render mode specified by a LogicOpChunk.\n"
    "            NO_DEPTH_TEST_MODE\n"
    "                The material contains a DepthChunk which is not enabled.\n"
    "            PBR_CLEAR_COAT_MODE\n"
    "                The PBR material should evaluate clear coat information.\n"
    "            PBR_SHEEN_COLOR_MODE\n"
    "                The PBR material should evaluate sheen color information.\n"
    "            PBR_ANISOTROPY_MODE\n"
    "                The PBR material should evaluate anisotropy information.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"numUVChannels\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        The number of UV channes, i.e. texture coordinates that the material must support.\n"
    "        This is mesh information but needed for proper shader code generation.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"UVDimension\"\n"
    "        type=\"UInt8\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The dimensionality of each of the UV channes, i.e. texture coordinates that the\n"
    "        material supports. Allowed values are 1, 2 or 3.\n"
    "        This is mesh information but needed for proper shader code generation.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"numColorChannels\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        The number of separate color channes that the material must support.\n"
    "        This is mesh information but needed for proper shader code generation.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"shadingModel\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"2\"\n"
    "        >\n"
    "        This value defines the shading model that should be used for shading\n"
    "        with this material. Allowed values are found in the ShadingModel enumeration\n"
    "        in the header file, e.g. NO_SHADING_MODEL, GOURAUD_SHADING_MODEL, PHONG_SHADING_MODEL,\n"
    "        BLINN_PHONG_SHADING_MODEL, COOK_TORRANCE_SHADING_MODEL, OREN_NAYAR_SHADING_MODEL, \n"
    "        TOON_SHADING_MODEL, GOOCH_SHADING_MODEL.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"overrideShadingModel\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        This value defines the shading model that took presedence over the actual shading model.\n"
    "        This is useful for instance if the material should temporarily be shaded with another\n"
    "        shading model. This can e.g. be used for a global GOOCH shading task. This value only\n"
    "        takes place if is not equal to NO_SHADING_MODEL.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"blendMode\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Defines how the final color value in the screen buffer is computed from the given \n"
    "        color at that position and the newly computed color from the material. Simply said, \n"
    "        alpha blending settings. Allowed values are DEFAULT_BLEND_MODE and ADDITIVE_BLEND_MODE.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"emissive\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f,0.f,0.f\"\n"
    "        >\n"
    "        The emissive color for the material.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"albedo\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f,0.f,0.f\"\n"
    "        >\n"
    "        The albedo (diffuse) color for the material.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"specular\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f,0.f,0.f\"\n"
    "        >\n"
    "        The specular color for the material.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"transparent\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f,1.f,1.f\"\n"
    "        >\n"
    "        Defines the transparent color of the material, this is the color to be multiplied with\n"
    "        the color of translucent light to construct the final 'destination color' for a particular \n"
    "        position in the screen buffer.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"reflective\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f,1.f,1.f\"\n"
    "        >\n"
    "        Defines the reflective color of the material. This is typically scaled by the amount of \n"
    "        incoming light from the direction of mirror reflection. Usually combined with an enviroment\n"
    "        lightmap.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"specularStrength\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        Scales the specular color of the material.\n"
    "        This value is kept separate from the specular color by most modelers, and so do we.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"emissiveStrength\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        Scales the emissive color of the material.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"opacity\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        Defines how transparent objects are rendered with this material.\n"
    "        Use this value to decide whether you have to activate alpha blending \n"
    "        for rendering. opacity != 1 usually also implies twosided=true to avoid \n"
    "        cull artifacts.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"opacityCutOff\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.5f\"\n"
    "        >\n"
    "        Any opacity value less than this value is set to zero. This allows to\n"
    "        fight certain artifacts when using opacity textures.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"opacityMode\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        This mode governs the interpretation of the opacity value. It can have the\n"
    "        following values:\n"
    "        NO_OPACITY_MODE     - The mode is not evaluated. Standard handling takes place.\n"
    "            This is the default value.\n"
    "        OPAQUE_OPACITY_MODE - The rendered output is fully opaque and any alpha value\n"
    "            is ignored. A depth value is written for every pixel and mesh sorting is\n"
    "            not required for correct output.\n"
    "        MASK_OPACITY_MODE   - The rendered output is either fully opaque or fully \n"
    "            transparent depending on the alpha value and the specified opacity cutoff\n"
    "            value.\n"
    "            If the alpha value is greater than or equal to the alphaCutoff value then\n"
    "            it is rendered as fully opaque, otherwise, it is rendered as fully transparent.\n"
    "            A depth value is not written for a pixel that is discarded after the alpha test.\n"
    "            A depth value is written for all other pixels. Mesh sorting is not required \n"
    "            for correct output.\n"
    "        BLEND_OPACITY_MODE  - The rendered output is combined with the background using\n"
    "            the normal painting operation.\n"
    "            Whether depth value is written or whether to sort is up to the implementation.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"reflectivity\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        Scales the reflective color of the material.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"reflectance\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.5f\"\n"
    "        >\n"
    "        Defines the perceptual reflectance R at normal incidance according to the fresnel law.\n"
    "        The perceptual reflectance R relates to the physical reflectance f0 = (n-1)^2 / (n+1)^2\n"
    "        by the equation f0 = 0.16 * R^2, where n is the optical index of refraction for dielectric\n"
    "        materials. It follows that R = sqrt(f0/0.16) = 2.5 * (n-1)/(n+1) or n = 2/(1-sqrt(f0)) - 1.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"bumpScaling\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        Bump height scaling.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"Anisotropy\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        Anisotropy parameter in the range of [-1,1]\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"roughness\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.5f\"\n"
    "        >\n"
    "        The 'Perceived roughness Rp' for the material. The 'micro facet model roughness Ra' is calculated\n"
    "        from the 'Perceived roughness Rp' by equation: Ra = Rp^2.\n"
    "        The 'Perceived roughness Rp' is a more user friendly parameter then model roughness Ra.\n"
    "        This is used in a PBR shader but has no use in a classical shading model.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"metalness\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        The metalness for the material. This is used in a PBR shader but has\n"
    "        no use in a classical shading model.\n"
    "    </Field>\n"
    "\n"
    "\n"
    "    <Field\n"
    "        name=\"clearCoatStrength\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        Strength of the clear coat layer. This value is expected to be in range [0,1].\n"
    "        This is used in a PBR shader but has no use in a classical shading model.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"clearCoatRoughness\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.5f\"\n"
    "        >\n"
    "        Perceived smoothness or roughness of the clear coat layer. This value is expected to be in range [0,1].\n"
    "        This is used in a PBR shader but has no use in a classical shading model.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"sheenColor\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.04f,0.04f,0.04f\"\n"
    "        >\n"
    "        Specular tint to create two-tone specular fabrics (defaults to 0.04 to match the standard reflectance).\n"
    "        This is used in a PBR shader but has no use in a classical shading model.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"subSurfaceColor\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.04f,0.04f,0.04f\"\n"
    "        >\n"
    "        Tint for the diffuse color after scattering and absorption through the material.\n"
    "        This is used in a PBR shader but has no use in a classical shading model.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"toonLevels\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"3\"\n"
    "        >\n"
    "        The number of Toon levels for the material used by Toon shading.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"goochCool\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.000f, 0.000f, 0.686f\"\n"
    "        >\n"
    "        The cool Gooch color used for Gooch shading.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"goochWarm\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.000f, 0.686f, 0.686f\"\n"
    "        >\n"
    "        The warm Gooch color used for Gooch shading.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"goochMixin\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.796f\"\n"
    "        >\n"
    "        The mix factor used for Gooch shading.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"goochCoolMixin\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        The mix factor used for adapting the cool color in Gooch shading\n"
    "        with respect to the albedo color.\n"
    "    </Field>\n"
    "     <Field\n"
    "        name=\"goochWarmMixin\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"1.f\"\n"
    "        >\n"
    "        The mix factor used for adapting the warm color in Gooch shading\n"
    "        with respect to the albedo color.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"cullFace\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"GL_BACK\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "    >\n"
    "    Defines which side of the polygon is invisible. Set to GL_NONE to not cull anything. See glCullFace.\n"
    "    Allowed values: GL_NONE,GL_FRONT,GL_BACK,GL_FRONT_AND_BACK\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"frontFace\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"GL_CCW\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        >\n"
    "        Defines which side of the polygon is considered the front side base on vertex ordering\n"
    "        of clockwise (CW) of counter clockwise (CCW). defaults to GL_CCW.  See glFrontFace.\n"
    "        Allowed values: GL_CCW,GL_CW\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"frontMode\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"GL_FILL\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        >\n"
    "        Defines if polygon front sides are rendered filled (default), outlined or as points. See glPolygonMode.\n"
    "        Allowed values: GL_FILL,GL_LINE,GL_POINT\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"backMode\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"GL_FILL\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        >\n"
    "        Defines if polygon front sides are rendered filled (default), outlined or as points. See glPolygonMode.\n"
    "        Allowed values: GL_FILL,GL_LINE,GL_POINT\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"offsetFactor\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Defines the polygon offset factor. See glPolygonOffset.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"offsetBias\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Defines the polygon offset bias. See glPolygonOffset.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"textureDesc\"\n"
    "        type=\"TextureDescPtr\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        >\n"
    "        The list of material textures.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"excludeHashingMask\"\n"
    "        type=\"BitVector\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        All field mask that are contained in this value do not participate in the\n"
    "        hash calculation procedure.\n"
    "    </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "This class provides a sufficient broad collection of material parameters.\n"
    "It allows to define texture stacks for different texture types. This\n"
    "description class has been designed among other things  to be compatible\n"
    "with the Assimp library material description. In order to fully utilize \n"
    "the description a sophisticated material and shader backend is needed.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &MaterialDescBase::getType(void)
{
    return _type;
}

const FieldContainerType &MaterialDescBase::getType(void) const
{
    return _type;
}

UInt32 MaterialDescBase::getContainerSize(void) const
{
    return sizeof(MaterialDesc);
}

/*------------------------- decorator get ------------------------------*/


SFString *MaterialDescBase::editSFName(void)
{
    editSField(NameFieldMask);

    return &_sfName;
}

const SFString *MaterialDescBase::getSFName(void) const
{
    return &_sfName;
}


SFUInt64 *MaterialDescBase::editSFDescHash(void)
{
    editSField(DescHashFieldMask);

    return &_sfDescHash;
}

const SFUInt64 *MaterialDescBase::getSFDescHash(void) const
{
    return &_sfDescHash;
}


SFUInt32 *MaterialDescBase::editSFModeFlags(void)
{
    editSField(ModeFlagsFieldMask);

    return &_sfModeFlags;
}

const SFUInt32 *MaterialDescBase::getSFModeFlags(void) const
{
    return &_sfModeFlags;
}


SFUInt32 *MaterialDescBase::editSFNumUVChannels(void)
{
    editSField(NumUVChannelsFieldMask);

    return &_sfNumUVChannels;
}

const SFUInt32 *MaterialDescBase::getSFNumUVChannels(void) const
{
    return &_sfNumUVChannels;
}


MFUInt8 *MaterialDescBase::editMFUVDimension(void)
{
    editMField(UVDimensionFieldMask, _mfUVDimension);

    return &_mfUVDimension;
}

const MFUInt8 *MaterialDescBase::getMFUVDimension(void) const
{
    return &_mfUVDimension;
}


SFUInt32 *MaterialDescBase::editSFNumColorChannels(void)
{
    editSField(NumColorChannelsFieldMask);

    return &_sfNumColorChannels;
}

const SFUInt32 *MaterialDescBase::getSFNumColorChannels(void) const
{
    return &_sfNumColorChannels;
}


SFUInt32 *MaterialDescBase::editSFShadingModel(void)
{
    editSField(ShadingModelFieldMask);

    return &_sfShadingModel;
}

const SFUInt32 *MaterialDescBase::getSFShadingModel(void) const
{
    return &_sfShadingModel;
}


SFUInt32 *MaterialDescBase::editSFOverrideShadingModel(void)
{
    editSField(OverrideShadingModelFieldMask);

    return &_sfOverrideShadingModel;
}

const SFUInt32 *MaterialDescBase::getSFOverrideShadingModel(void) const
{
    return &_sfOverrideShadingModel;
}


SFUInt32 *MaterialDescBase::editSFBlendMode(void)
{
    editSField(BlendModeFieldMask);

    return &_sfBlendMode;
}

const SFUInt32 *MaterialDescBase::getSFBlendMode(void) const
{
    return &_sfBlendMode;
}


SFColor3f *MaterialDescBase::editSFEmissive(void)
{
    editSField(EmissiveFieldMask);

    return &_sfEmissive;
}

const SFColor3f *MaterialDescBase::getSFEmissive(void) const
{
    return &_sfEmissive;
}


SFColor3f *MaterialDescBase::editSFAlbedo(void)
{
    editSField(AlbedoFieldMask);

    return &_sfAlbedo;
}

const SFColor3f *MaterialDescBase::getSFAlbedo(void) const
{
    return &_sfAlbedo;
}


SFColor3f *MaterialDescBase::editSFSpecular(void)
{
    editSField(SpecularFieldMask);

    return &_sfSpecular;
}

const SFColor3f *MaterialDescBase::getSFSpecular(void) const
{
    return &_sfSpecular;
}


SFColor3f *MaterialDescBase::editSFTransparent(void)
{
    editSField(TransparentFieldMask);

    return &_sfTransparent;
}

const SFColor3f *MaterialDescBase::getSFTransparent(void) const
{
    return &_sfTransparent;
}


SFColor3f *MaterialDescBase::editSFReflective(void)
{
    editSField(ReflectiveFieldMask);

    return &_sfReflective;
}

const SFColor3f *MaterialDescBase::getSFReflective(void) const
{
    return &_sfReflective;
}


SFReal32 *MaterialDescBase::editSFSpecularStrength(void)
{
    editSField(SpecularStrengthFieldMask);

    return &_sfSpecularStrength;
}

const SFReal32 *MaterialDescBase::getSFSpecularStrength(void) const
{
    return &_sfSpecularStrength;
}


SFReal32 *MaterialDescBase::editSFEmissiveStrength(void)
{
    editSField(EmissiveStrengthFieldMask);

    return &_sfEmissiveStrength;
}

const SFReal32 *MaterialDescBase::getSFEmissiveStrength(void) const
{
    return &_sfEmissiveStrength;
}


SFReal32 *MaterialDescBase::editSFOpacity(void)
{
    editSField(OpacityFieldMask);

    return &_sfOpacity;
}

const SFReal32 *MaterialDescBase::getSFOpacity(void) const
{
    return &_sfOpacity;
}


SFReal32 *MaterialDescBase::editSFOpacityCutOff(void)
{
    editSField(OpacityCutOffFieldMask);

    return &_sfOpacityCutOff;
}

const SFReal32 *MaterialDescBase::getSFOpacityCutOff(void) const
{
    return &_sfOpacityCutOff;
}


SFUInt32 *MaterialDescBase::editSFOpacityMode(void)
{
    editSField(OpacityModeFieldMask);

    return &_sfOpacityMode;
}

const SFUInt32 *MaterialDescBase::getSFOpacityMode(void) const
{
    return &_sfOpacityMode;
}


SFReal32 *MaterialDescBase::editSFReflectivity(void)
{
    editSField(ReflectivityFieldMask);

    return &_sfReflectivity;
}

const SFReal32 *MaterialDescBase::getSFReflectivity(void) const
{
    return &_sfReflectivity;
}


SFReal32 *MaterialDescBase::editSFReflectance(void)
{
    editSField(ReflectanceFieldMask);

    return &_sfReflectance;
}

const SFReal32 *MaterialDescBase::getSFReflectance(void) const
{
    return &_sfReflectance;
}


SFReal32 *MaterialDescBase::editSFBumpScaling(void)
{
    editSField(BumpScalingFieldMask);

    return &_sfBumpScaling;
}

const SFReal32 *MaterialDescBase::getSFBumpScaling(void) const
{
    return &_sfBumpScaling;
}


SFReal32 *MaterialDescBase::editSFAnisotropy(void)
{
    editSField(AnisotropyFieldMask);

    return &_sfAnisotropy;
}

const SFReal32 *MaterialDescBase::getSFAnisotropy(void) const
{
    return &_sfAnisotropy;
}


SFReal32 *MaterialDescBase::editSFRoughness(void)
{
    editSField(RoughnessFieldMask);

    return &_sfRoughness;
}

const SFReal32 *MaterialDescBase::getSFRoughness(void) const
{
    return &_sfRoughness;
}


SFReal32 *MaterialDescBase::editSFMetalness(void)
{
    editSField(MetalnessFieldMask);

    return &_sfMetalness;
}

const SFReal32 *MaterialDescBase::getSFMetalness(void) const
{
    return &_sfMetalness;
}


SFReal32 *MaterialDescBase::editSFClearCoatStrength(void)
{
    editSField(ClearCoatStrengthFieldMask);

    return &_sfClearCoatStrength;
}

const SFReal32 *MaterialDescBase::getSFClearCoatStrength(void) const
{
    return &_sfClearCoatStrength;
}


SFReal32 *MaterialDescBase::editSFClearCoatRoughness(void)
{
    editSField(ClearCoatRoughnessFieldMask);

    return &_sfClearCoatRoughness;
}

const SFReal32 *MaterialDescBase::getSFClearCoatRoughness(void) const
{
    return &_sfClearCoatRoughness;
}


SFColor3f *MaterialDescBase::editSFSheenColor(void)
{
    editSField(SheenColorFieldMask);

    return &_sfSheenColor;
}

const SFColor3f *MaterialDescBase::getSFSheenColor(void) const
{
    return &_sfSheenColor;
}


SFColor3f *MaterialDescBase::editSFSubSurfaceColor(void)
{
    editSField(SubSurfaceColorFieldMask);

    return &_sfSubSurfaceColor;
}

const SFColor3f *MaterialDescBase::getSFSubSurfaceColor(void) const
{
    return &_sfSubSurfaceColor;
}


SFInt32 *MaterialDescBase::editSFToonLevels(void)
{
    editSField(ToonLevelsFieldMask);

    return &_sfToonLevels;
}

const SFInt32 *MaterialDescBase::getSFToonLevels(void) const
{
    return &_sfToonLevels;
}


SFColor3f *MaterialDescBase::editSFGoochCool(void)
{
    editSField(GoochCoolFieldMask);

    return &_sfGoochCool;
}

const SFColor3f *MaterialDescBase::getSFGoochCool(void) const
{
    return &_sfGoochCool;
}


SFColor3f *MaterialDescBase::editSFGoochWarm(void)
{
    editSField(GoochWarmFieldMask);

    return &_sfGoochWarm;
}

const SFColor3f *MaterialDescBase::getSFGoochWarm(void) const
{
    return &_sfGoochWarm;
}


SFReal32 *MaterialDescBase::editSFGoochMixin(void)
{
    editSField(GoochMixinFieldMask);

    return &_sfGoochMixin;
}

const SFReal32 *MaterialDescBase::getSFGoochMixin(void) const
{
    return &_sfGoochMixin;
}


SFReal32 *MaterialDescBase::editSFGoochCoolMixin(void)
{
    editSField(GoochCoolMixinFieldMask);

    return &_sfGoochCoolMixin;
}

const SFReal32 *MaterialDescBase::getSFGoochCoolMixin(void) const
{
    return &_sfGoochCoolMixin;
}


SFReal32 *MaterialDescBase::editSFGoochWarmMixin(void)
{
    editSField(GoochWarmMixinFieldMask);

    return &_sfGoochWarmMixin;
}

const SFReal32 *MaterialDescBase::getSFGoochWarmMixin(void) const
{
    return &_sfGoochWarmMixin;
}


SFGLenum *MaterialDescBase::editSFCullFace(void)
{
    editSField(CullFaceFieldMask);

    return &_sfCullFace;
}

const SFGLenum *MaterialDescBase::getSFCullFace(void) const
{
    return &_sfCullFace;
}


SFGLenum *MaterialDescBase::editSFFrontFace(void)
{
    editSField(FrontFaceFieldMask);

    return &_sfFrontFace;
}

const SFGLenum *MaterialDescBase::getSFFrontFace(void) const
{
    return &_sfFrontFace;
}


SFGLenum *MaterialDescBase::editSFFrontMode(void)
{
    editSField(FrontModeFieldMask);

    return &_sfFrontMode;
}

const SFGLenum *MaterialDescBase::getSFFrontMode(void) const
{
    return &_sfFrontMode;
}


SFGLenum *MaterialDescBase::editSFBackMode(void)
{
    editSField(BackModeFieldMask);

    return &_sfBackMode;
}

const SFGLenum *MaterialDescBase::getSFBackMode(void) const
{
    return &_sfBackMode;
}


SFReal32 *MaterialDescBase::editSFOffsetFactor(void)
{
    editSField(OffsetFactorFieldMask);

    return &_sfOffsetFactor;
}

const SFReal32 *MaterialDescBase::getSFOffsetFactor(void) const
{
    return &_sfOffsetFactor;
}


SFReal32 *MaterialDescBase::editSFOffsetBias(void)
{
    editSField(OffsetBiasFieldMask);

    return &_sfOffsetBias;
}

const SFReal32 *MaterialDescBase::getSFOffsetBias(void) const
{
    return &_sfOffsetBias;
}


//! Get the MaterialDesc::_mfTextureDesc field.
const MFUnrecTextureDescPtr *MaterialDescBase::getMFTextureDesc(void) const
{
    return &_mfTextureDesc;
}

MFUnrecTextureDescPtr *MaterialDescBase::editMFTextureDesc    (void)
{
    editMField(TextureDescFieldMask, _mfTextureDesc);

    return &_mfTextureDesc;
}
TextureDesc * MaterialDescBase::getTextureDesc(const UInt32 index) const
{
    return _mfTextureDesc[index];
}

SFBitVector *MaterialDescBase::editSFExcludeHashingMask(void)
{
    editSField(ExcludeHashingMaskFieldMask);

    return &_sfExcludeHashingMask;
}

const SFBitVector *MaterialDescBase::getSFExcludeHashingMask(void) const
{
    return &_sfExcludeHashingMask;
}




void MaterialDescBase::pushToTextureDesc(TextureDesc * const value)
{
    editMField(TextureDescFieldMask, _mfTextureDesc);

    _mfTextureDesc.push_back(value);
}

void MaterialDescBase::assignTextureDesc(const MFUnrecTextureDescPtr &value)
{
    MFUnrecTextureDescPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecTextureDescPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<MaterialDesc *>(this)->clearTextureDesc();

    while(elemIt != elemEnd)
    {
        this->pushToTextureDesc(*elemIt);

        ++elemIt;
    }
}

void MaterialDescBase::removeFromTextureDesc(UInt32 uiIndex)
{
    if(uiIndex < _mfTextureDesc.size())
    {
        editMField(TextureDescFieldMask, _mfTextureDesc);

        _mfTextureDesc.erase(uiIndex);
    }
}

void MaterialDescBase::removeObjFromTextureDesc(TextureDesc * const value)
{
    Int32 iElemIdx = _mfTextureDesc.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TextureDescFieldMask, _mfTextureDesc);

        _mfTextureDesc.erase(iElemIdx);
    }
}
void MaterialDescBase::clearTextureDesc(void)
{
    editMField(TextureDescFieldMask, _mfTextureDesc);


    _mfTextureDesc.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT MaterialDescBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        returnValue += _sfName.getBinSize();
    }
    if(FieldBits::NoField != (DescHashFieldMask & whichField))
    {
        returnValue += _sfDescHash.getBinSize();
    }
    if(FieldBits::NoField != (ModeFlagsFieldMask & whichField))
    {
        returnValue += _sfModeFlags.getBinSize();
    }
    if(FieldBits::NoField != (NumUVChannelsFieldMask & whichField))
    {
        returnValue += _sfNumUVChannels.getBinSize();
    }
    if(FieldBits::NoField != (UVDimensionFieldMask & whichField))
    {
        returnValue += _mfUVDimension.getBinSize();
    }
    if(FieldBits::NoField != (NumColorChannelsFieldMask & whichField))
    {
        returnValue += _sfNumColorChannels.getBinSize();
    }
    if(FieldBits::NoField != (ShadingModelFieldMask & whichField))
    {
        returnValue += _sfShadingModel.getBinSize();
    }
    if(FieldBits::NoField != (OverrideShadingModelFieldMask & whichField))
    {
        returnValue += _sfOverrideShadingModel.getBinSize();
    }
    if(FieldBits::NoField != (BlendModeFieldMask & whichField))
    {
        returnValue += _sfBlendMode.getBinSize();
    }
    if(FieldBits::NoField != (EmissiveFieldMask & whichField))
    {
        returnValue += _sfEmissive.getBinSize();
    }
    if(FieldBits::NoField != (AlbedoFieldMask & whichField))
    {
        returnValue += _sfAlbedo.getBinSize();
    }
    if(FieldBits::NoField != (SpecularFieldMask & whichField))
    {
        returnValue += _sfSpecular.getBinSize();
    }
    if(FieldBits::NoField != (TransparentFieldMask & whichField))
    {
        returnValue += _sfTransparent.getBinSize();
    }
    if(FieldBits::NoField != (ReflectiveFieldMask & whichField))
    {
        returnValue += _sfReflective.getBinSize();
    }
    if(FieldBits::NoField != (SpecularStrengthFieldMask & whichField))
    {
        returnValue += _sfSpecularStrength.getBinSize();
    }
    if(FieldBits::NoField != (EmissiveStrengthFieldMask & whichField))
    {
        returnValue += _sfEmissiveStrength.getBinSize();
    }
    if(FieldBits::NoField != (OpacityFieldMask & whichField))
    {
        returnValue += _sfOpacity.getBinSize();
    }
    if(FieldBits::NoField != (OpacityCutOffFieldMask & whichField))
    {
        returnValue += _sfOpacityCutOff.getBinSize();
    }
    if(FieldBits::NoField != (OpacityModeFieldMask & whichField))
    {
        returnValue += _sfOpacityMode.getBinSize();
    }
    if(FieldBits::NoField != (ReflectivityFieldMask & whichField))
    {
        returnValue += _sfReflectivity.getBinSize();
    }
    if(FieldBits::NoField != (ReflectanceFieldMask & whichField))
    {
        returnValue += _sfReflectance.getBinSize();
    }
    if(FieldBits::NoField != (BumpScalingFieldMask & whichField))
    {
        returnValue += _sfBumpScaling.getBinSize();
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        returnValue += _sfAnisotropy.getBinSize();
    }
    if(FieldBits::NoField != (RoughnessFieldMask & whichField))
    {
        returnValue += _sfRoughness.getBinSize();
    }
    if(FieldBits::NoField != (MetalnessFieldMask & whichField))
    {
        returnValue += _sfMetalness.getBinSize();
    }
    if(FieldBits::NoField != (ClearCoatStrengthFieldMask & whichField))
    {
        returnValue += _sfClearCoatStrength.getBinSize();
    }
    if(FieldBits::NoField != (ClearCoatRoughnessFieldMask & whichField))
    {
        returnValue += _sfClearCoatRoughness.getBinSize();
    }
    if(FieldBits::NoField != (SheenColorFieldMask & whichField))
    {
        returnValue += _sfSheenColor.getBinSize();
    }
    if(FieldBits::NoField != (SubSurfaceColorFieldMask & whichField))
    {
        returnValue += _sfSubSurfaceColor.getBinSize();
    }
    if(FieldBits::NoField != (ToonLevelsFieldMask & whichField))
    {
        returnValue += _sfToonLevels.getBinSize();
    }
    if(FieldBits::NoField != (GoochCoolFieldMask & whichField))
    {
        returnValue += _sfGoochCool.getBinSize();
    }
    if(FieldBits::NoField != (GoochWarmFieldMask & whichField))
    {
        returnValue += _sfGoochWarm.getBinSize();
    }
    if(FieldBits::NoField != (GoochMixinFieldMask & whichField))
    {
        returnValue += _sfGoochMixin.getBinSize();
    }
    if(FieldBits::NoField != (GoochCoolMixinFieldMask & whichField))
    {
        returnValue += _sfGoochCoolMixin.getBinSize();
    }
    if(FieldBits::NoField != (GoochWarmMixinFieldMask & whichField))
    {
        returnValue += _sfGoochWarmMixin.getBinSize();
    }
    if(FieldBits::NoField != (CullFaceFieldMask & whichField))
    {
        returnValue += _sfCullFace.getBinSize();
    }
    if(FieldBits::NoField != (FrontFaceFieldMask & whichField))
    {
        returnValue += _sfFrontFace.getBinSize();
    }
    if(FieldBits::NoField != (FrontModeFieldMask & whichField))
    {
        returnValue += _sfFrontMode.getBinSize();
    }
    if(FieldBits::NoField != (BackModeFieldMask & whichField))
    {
        returnValue += _sfBackMode.getBinSize();
    }
    if(FieldBits::NoField != (OffsetFactorFieldMask & whichField))
    {
        returnValue += _sfOffsetFactor.getBinSize();
    }
    if(FieldBits::NoField != (OffsetBiasFieldMask & whichField))
    {
        returnValue += _sfOffsetBias.getBinSize();
    }
    if(FieldBits::NoField != (TextureDescFieldMask & whichField))
    {
        returnValue += _mfTextureDesc.getBinSize();
    }
    if(FieldBits::NoField != (ExcludeHashingMaskFieldMask & whichField))
    {
        returnValue += _sfExcludeHashingMask.getBinSize();
    }

    return returnValue;
}

void MaterialDescBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DescHashFieldMask & whichField))
    {
        _sfDescHash.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ModeFlagsFieldMask & whichField))
    {
        _sfModeFlags.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumUVChannelsFieldMask & whichField))
    {
        _sfNumUVChannels.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UVDimensionFieldMask & whichField))
    {
        _mfUVDimension.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumColorChannelsFieldMask & whichField))
    {
        _sfNumColorChannels.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadingModelFieldMask & whichField))
    {
        _sfShadingModel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OverrideShadingModelFieldMask & whichField))
    {
        _sfOverrideShadingModel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BlendModeFieldMask & whichField))
    {
        _sfBlendMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EmissiveFieldMask & whichField))
    {
        _sfEmissive.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AlbedoFieldMask & whichField))
    {
        _sfAlbedo.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpecularFieldMask & whichField))
    {
        _sfSpecular.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TransparentFieldMask & whichField))
    {
        _sfTransparent.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ReflectiveFieldMask & whichField))
    {
        _sfReflective.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SpecularStrengthFieldMask & whichField))
    {
        _sfSpecularStrength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EmissiveStrengthFieldMask & whichField))
    {
        _sfEmissiveStrength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OpacityFieldMask & whichField))
    {
        _sfOpacity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OpacityCutOffFieldMask & whichField))
    {
        _sfOpacityCutOff.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OpacityModeFieldMask & whichField))
    {
        _sfOpacityMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ReflectivityFieldMask & whichField))
    {
        _sfReflectivity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ReflectanceFieldMask & whichField))
    {
        _sfReflectance.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BumpScalingFieldMask & whichField))
    {
        _sfBumpScaling.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RoughnessFieldMask & whichField))
    {
        _sfRoughness.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MetalnessFieldMask & whichField))
    {
        _sfMetalness.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ClearCoatStrengthFieldMask & whichField))
    {
        _sfClearCoatStrength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ClearCoatRoughnessFieldMask & whichField))
    {
        _sfClearCoatRoughness.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SheenColorFieldMask & whichField))
    {
        _sfSheenColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SubSurfaceColorFieldMask & whichField))
    {
        _sfSubSurfaceColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ToonLevelsFieldMask & whichField))
    {
        _sfToonLevels.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GoochCoolFieldMask & whichField))
    {
        _sfGoochCool.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GoochWarmFieldMask & whichField))
    {
        _sfGoochWarm.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GoochMixinFieldMask & whichField))
    {
        _sfGoochMixin.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GoochCoolMixinFieldMask & whichField))
    {
        _sfGoochCoolMixin.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GoochWarmMixinFieldMask & whichField))
    {
        _sfGoochWarmMixin.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CullFaceFieldMask & whichField))
    {
        _sfCullFace.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrontFaceFieldMask & whichField))
    {
        _sfFrontFace.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrontModeFieldMask & whichField))
    {
        _sfFrontMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BackModeFieldMask & whichField))
    {
        _sfBackMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFactorFieldMask & whichField))
    {
        _sfOffsetFactor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffsetBiasFieldMask & whichField))
    {
        _sfOffsetBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureDescFieldMask & whichField))
    {
        _mfTextureDesc.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeHashingMaskFieldMask & whichField))
    {
        _sfExcludeHashingMask.copyToBin(pMem);
    }
}

void MaterialDescBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        editSField(NameFieldMask);
        _sfName.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DescHashFieldMask & whichField))
    {
        editSField(DescHashFieldMask);
        _sfDescHash.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ModeFlagsFieldMask & whichField))
    {
        editSField(ModeFlagsFieldMask);
        _sfModeFlags.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumUVChannelsFieldMask & whichField))
    {
        editSField(NumUVChannelsFieldMask);
        _sfNumUVChannels.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UVDimensionFieldMask & whichField))
    {
        editMField(UVDimensionFieldMask, _mfUVDimension);
        _mfUVDimension.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumColorChannelsFieldMask & whichField))
    {
        editSField(NumColorChannelsFieldMask);
        _sfNumColorChannels.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadingModelFieldMask & whichField))
    {
        editSField(ShadingModelFieldMask);
        _sfShadingModel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OverrideShadingModelFieldMask & whichField))
    {
        editSField(OverrideShadingModelFieldMask);
        _sfOverrideShadingModel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BlendModeFieldMask & whichField))
    {
        editSField(BlendModeFieldMask);
        _sfBlendMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EmissiveFieldMask & whichField))
    {
        editSField(EmissiveFieldMask);
        _sfEmissive.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AlbedoFieldMask & whichField))
    {
        editSField(AlbedoFieldMask);
        _sfAlbedo.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpecularFieldMask & whichField))
    {
        editSField(SpecularFieldMask);
        _sfSpecular.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TransparentFieldMask & whichField))
    {
        editSField(TransparentFieldMask);
        _sfTransparent.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ReflectiveFieldMask & whichField))
    {
        editSField(ReflectiveFieldMask);
        _sfReflective.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SpecularStrengthFieldMask & whichField))
    {
        editSField(SpecularStrengthFieldMask);
        _sfSpecularStrength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EmissiveStrengthFieldMask & whichField))
    {
        editSField(EmissiveStrengthFieldMask);
        _sfEmissiveStrength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OpacityFieldMask & whichField))
    {
        editSField(OpacityFieldMask);
        _sfOpacity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OpacityCutOffFieldMask & whichField))
    {
        editSField(OpacityCutOffFieldMask);
        _sfOpacityCutOff.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OpacityModeFieldMask & whichField))
    {
        editSField(OpacityModeFieldMask);
        _sfOpacityMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ReflectivityFieldMask & whichField))
    {
        editSField(ReflectivityFieldMask);
        _sfReflectivity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ReflectanceFieldMask & whichField))
    {
        editSField(ReflectanceFieldMask);
        _sfReflectance.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BumpScalingFieldMask & whichField))
    {
        editSField(BumpScalingFieldMask);
        _sfBumpScaling.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        editSField(AnisotropyFieldMask);
        _sfAnisotropy.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RoughnessFieldMask & whichField))
    {
        editSField(RoughnessFieldMask);
        _sfRoughness.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MetalnessFieldMask & whichField))
    {
        editSField(MetalnessFieldMask);
        _sfMetalness.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ClearCoatStrengthFieldMask & whichField))
    {
        editSField(ClearCoatStrengthFieldMask);
        _sfClearCoatStrength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ClearCoatRoughnessFieldMask & whichField))
    {
        editSField(ClearCoatRoughnessFieldMask);
        _sfClearCoatRoughness.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SheenColorFieldMask & whichField))
    {
        editSField(SheenColorFieldMask);
        _sfSheenColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SubSurfaceColorFieldMask & whichField))
    {
        editSField(SubSurfaceColorFieldMask);
        _sfSubSurfaceColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ToonLevelsFieldMask & whichField))
    {
        editSField(ToonLevelsFieldMask);
        _sfToonLevels.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GoochCoolFieldMask & whichField))
    {
        editSField(GoochCoolFieldMask);
        _sfGoochCool.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GoochWarmFieldMask & whichField))
    {
        editSField(GoochWarmFieldMask);
        _sfGoochWarm.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GoochMixinFieldMask & whichField))
    {
        editSField(GoochMixinFieldMask);
        _sfGoochMixin.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GoochCoolMixinFieldMask & whichField))
    {
        editSField(GoochCoolMixinFieldMask);
        _sfGoochCoolMixin.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GoochWarmMixinFieldMask & whichField))
    {
        editSField(GoochWarmMixinFieldMask);
        _sfGoochWarmMixin.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CullFaceFieldMask & whichField))
    {
        editSField(CullFaceFieldMask);
        _sfCullFace.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrontFaceFieldMask & whichField))
    {
        editSField(FrontFaceFieldMask);
        _sfFrontFace.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrontModeFieldMask & whichField))
    {
        editSField(FrontModeFieldMask);
        _sfFrontMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BackModeFieldMask & whichField))
    {
        editSField(BackModeFieldMask);
        _sfBackMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffsetFactorFieldMask & whichField))
    {
        editSField(OffsetFactorFieldMask);
        _sfOffsetFactor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffsetBiasFieldMask & whichField))
    {
        editSField(OffsetBiasFieldMask);
        _sfOffsetBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureDescFieldMask & whichField))
    {
        editMField(TextureDescFieldMask, _mfTextureDesc);
        _mfTextureDesc.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeHashingMaskFieldMask & whichField))
    {
        editSField(ExcludeHashingMaskFieldMask);
        _sfExcludeHashingMask.copyFromBin(pMem);
    }
}

//! create a new instance of the class
MaterialDescTransitPtr MaterialDescBase::createLocal(BitVector bFlags)
{
    MaterialDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<MaterialDesc>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
MaterialDescTransitPtr MaterialDescBase::createDependent(BitVector bFlags)
{
    MaterialDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<MaterialDesc>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
MaterialDescTransitPtr MaterialDescBase::create(void)
{
    MaterialDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<MaterialDesc>(tmpPtr);
    }

    return fc;
}

MaterialDesc *MaterialDescBase::createEmptyLocal(BitVector bFlags)
{
    MaterialDesc *returnValue;

    newPtr<MaterialDesc>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
MaterialDesc *MaterialDescBase::createEmpty(void)
{
    MaterialDesc *returnValue;

    newPtr<MaterialDesc>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr MaterialDescBase::shallowCopyLocal(
    BitVector bFlags) const
{
    MaterialDesc *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MaterialDesc *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr MaterialDescBase::shallowCopyDependent(
    BitVector bFlags) const
{
    MaterialDesc *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const MaterialDesc *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr MaterialDescBase::shallowCopy(void) const
{
    MaterialDesc *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const MaterialDesc *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

MaterialDescBase::MaterialDescBase(void) :
    Inherited(),
    _sfName                   (),
    _sfDescHash               (UInt64(0)),
    _sfModeFlags              (UInt32(0x01)),
    _sfNumUVChannels          (UInt32(0)),
    _mfUVDimension            (),
    _sfNumColorChannels       (UInt32(0)),
    _sfShadingModel           (UInt32(2)),
    _sfOverrideShadingModel   (UInt32(0)),
    _sfBlendMode              (UInt32(0)),
    _sfEmissive               (Color3f(0.f,0.f,0.f)),
    _sfAlbedo                 (Color3f(0.f,0.f,0.f)),
    _sfSpecular               (Color3f(0.f,0.f,0.f)),
    _sfTransparent            (Color3f(1.f,1.f,1.f)),
    _sfReflective             (Color3f(1.f,1.f,1.f)),
    _sfSpecularStrength       (Real32(1.f)),
    _sfEmissiveStrength       (Real32(1.f)),
    _sfOpacity                (Real32(1.f)),
    _sfOpacityCutOff          (Real32(0.5f)),
    _sfOpacityMode            (UInt32(0)),
    _sfReflectivity           (Real32(0.f)),
    _sfReflectance            (Real32(0.5f)),
    _sfBumpScaling            (Real32(1.f)),
    _sfAnisotropy             (Real32(0.f)),
    _sfRoughness              (Real32(0.5f)),
    _sfMetalness              (Real32(0.f)),
    _sfClearCoatStrength      (Real32(0.f)),
    _sfClearCoatRoughness     (Real32(0.5f)),
    _sfSheenColor             (Color3f(0.04f,0.04f,0.04f)),
    _sfSubSurfaceColor        (Color3f(0.04f,0.04f,0.04f)),
    _sfToonLevels             (Int32(3)),
    _sfGoochCool              (Color3f(0.000f, 0.000f, 0.686f)),
    _sfGoochWarm              (Color3f(0.000f, 0.686f, 0.686f)),
    _sfGoochMixin             (Real32(0.796f)),
    _sfGoochCoolMixin         (Real32(1.f)),
    _sfGoochWarmMixin         (Real32(1.f)),
    _sfCullFace               (GLenum(GL_BACK)),
    _sfFrontFace              (GLenum(GL_CCW)),
    _sfFrontMode              (GLenum(GL_FILL)),
    _sfBackMode               (GLenum(GL_FILL)),
    _sfOffsetFactor           (Real32(0)),
    _sfOffsetBias             (Real32(0)),
    _mfTextureDesc            (),
    _sfExcludeHashingMask     (BitVector(0))
{
}

MaterialDescBase::MaterialDescBase(const MaterialDescBase &source) :
    Inherited(source),
    _sfName                   (source._sfName                   ),
    _sfDescHash               (source._sfDescHash               ),
    _sfModeFlags              (source._sfModeFlags              ),
    _sfNumUVChannels          (source._sfNumUVChannels          ),
    _mfUVDimension            (source._mfUVDimension            ),
    _sfNumColorChannels       (source._sfNumColorChannels       ),
    _sfShadingModel           (source._sfShadingModel           ),
    _sfOverrideShadingModel   (source._sfOverrideShadingModel   ),
    _sfBlendMode              (source._sfBlendMode              ),
    _sfEmissive               (source._sfEmissive               ),
    _sfAlbedo                 (source._sfAlbedo                 ),
    _sfSpecular               (source._sfSpecular               ),
    _sfTransparent            (source._sfTransparent            ),
    _sfReflective             (source._sfReflective             ),
    _sfSpecularStrength       (source._sfSpecularStrength       ),
    _sfEmissiveStrength       (source._sfEmissiveStrength       ),
    _sfOpacity                (source._sfOpacity                ),
    _sfOpacityCutOff          (source._sfOpacityCutOff          ),
    _sfOpacityMode            (source._sfOpacityMode            ),
    _sfReflectivity           (source._sfReflectivity           ),
    _sfReflectance            (source._sfReflectance            ),
    _sfBumpScaling            (source._sfBumpScaling            ),
    _sfAnisotropy             (source._sfAnisotropy             ),
    _sfRoughness              (source._sfRoughness              ),
    _sfMetalness              (source._sfMetalness              ),
    _sfClearCoatStrength      (source._sfClearCoatStrength      ),
    _sfClearCoatRoughness     (source._sfClearCoatRoughness     ),
    _sfSheenColor             (source._sfSheenColor             ),
    _sfSubSurfaceColor        (source._sfSubSurfaceColor        ),
    _sfToonLevels             (source._sfToonLevels             ),
    _sfGoochCool              (source._sfGoochCool              ),
    _sfGoochWarm              (source._sfGoochWarm              ),
    _sfGoochMixin             (source._sfGoochMixin             ),
    _sfGoochCoolMixin         (source._sfGoochCoolMixin         ),
    _sfGoochWarmMixin         (source._sfGoochWarmMixin         ),
    _sfCullFace               (source._sfCullFace               ),
    _sfFrontFace              (source._sfFrontFace              ),
    _sfFrontMode              (source._sfFrontMode              ),
    _sfBackMode               (source._sfBackMode               ),
    _sfOffsetFactor           (source._sfOffsetFactor           ),
    _sfOffsetBias             (source._sfOffsetBias             ),
    _mfTextureDesc            (),
    _sfExcludeHashingMask     (source._sfExcludeHashingMask     )
{
}


/*-------------------------- destructors ----------------------------------*/

MaterialDescBase::~MaterialDescBase(void)
{
}

void MaterialDescBase::onCreate(const MaterialDesc *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        MaterialDesc *pThis = static_cast<MaterialDesc *>(this);

        MFUnrecTextureDescPtr::const_iterator TextureDescIt  =
            source->_mfTextureDesc.begin();
        MFUnrecTextureDescPtr::const_iterator TextureDescEnd =
            source->_mfTextureDesc.end  ();

        while(TextureDescIt != TextureDescEnd)
        {
            pThis->pushToTextureDesc(*TextureDescIt);

            ++TextureDescIt;
        }
    }
}

GetFieldHandlePtr MaterialDescBase::getHandleName            (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfName,
             this->getType().getFieldDesc(NameFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleName           (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfName,
             this->getType().getFieldDesc(NameFieldId),
             this));


    editSField(NameFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleDescHash        (void) const
{
    SFUInt64::GetHandlePtr returnValue(
        new  SFUInt64::GetHandle(
             &_sfDescHash,
             this->getType().getFieldDesc(DescHashFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleDescHash       (void)
{
    SFUInt64::EditHandlePtr returnValue(
        new  SFUInt64::EditHandle(
             &_sfDescHash,
             this->getType().getFieldDesc(DescHashFieldId),
             this));


    editSField(DescHashFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleModeFlags       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfModeFlags,
             this->getType().getFieldDesc(ModeFlagsFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleModeFlags      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfModeFlags,
             this->getType().getFieldDesc(ModeFlagsFieldId),
             this));


    editSField(ModeFlagsFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleNumUVChannels   (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfNumUVChannels,
             this->getType().getFieldDesc(NumUVChannelsFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleNumUVChannels  (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfNumUVChannels,
             this->getType().getFieldDesc(NumUVChannelsFieldId),
             this));


    editSField(NumUVChannelsFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleUVDimension     (void) const
{
    MFUInt8::GetHandlePtr returnValue(
        new  MFUInt8::GetHandle(
             &_mfUVDimension,
             this->getType().getFieldDesc(UVDimensionFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleUVDimension    (void)
{
    MFUInt8::EditHandlePtr returnValue(
        new  MFUInt8::EditHandle(
             &_mfUVDimension,
             this->getType().getFieldDesc(UVDimensionFieldId),
             this));


    editMField(UVDimensionFieldMask, _mfUVDimension);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleNumColorChannels (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfNumColorChannels,
             this->getType().getFieldDesc(NumColorChannelsFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleNumColorChannels(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfNumColorChannels,
             this->getType().getFieldDesc(NumColorChannelsFieldId),
             this));


    editSField(NumColorChannelsFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleShadingModel    (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfShadingModel,
             this->getType().getFieldDesc(ShadingModelFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleShadingModel   (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfShadingModel,
             this->getType().getFieldDesc(ShadingModelFieldId),
             this));


    editSField(ShadingModelFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleOverrideShadingModel (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfOverrideShadingModel,
             this->getType().getFieldDesc(OverrideShadingModelFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleOverrideShadingModel(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfOverrideShadingModel,
             this->getType().getFieldDesc(OverrideShadingModelFieldId),
             this));


    editSField(OverrideShadingModelFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleBlendMode       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfBlendMode,
             this->getType().getFieldDesc(BlendModeFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleBlendMode      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfBlendMode,
             this->getType().getFieldDesc(BlendModeFieldId),
             this));


    editSField(BlendModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleEmissive        (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfEmissive,
             this->getType().getFieldDesc(EmissiveFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleEmissive       (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfEmissive,
             this->getType().getFieldDesc(EmissiveFieldId),
             this));


    editSField(EmissiveFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleAlbedo          (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfAlbedo,
             this->getType().getFieldDesc(AlbedoFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleAlbedo         (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfAlbedo,
             this->getType().getFieldDesc(AlbedoFieldId),
             this));


    editSField(AlbedoFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleSpecular        (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfSpecular,
             this->getType().getFieldDesc(SpecularFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleSpecular       (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfSpecular,
             this->getType().getFieldDesc(SpecularFieldId),
             this));


    editSField(SpecularFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleTransparent     (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfTransparent,
             this->getType().getFieldDesc(TransparentFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleTransparent    (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfTransparent,
             this->getType().getFieldDesc(TransparentFieldId),
             this));


    editSField(TransparentFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleReflective      (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfReflective,
             this->getType().getFieldDesc(ReflectiveFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleReflective     (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfReflective,
             this->getType().getFieldDesc(ReflectiveFieldId),
             this));


    editSField(ReflectiveFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleSpecularStrength (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfSpecularStrength,
             this->getType().getFieldDesc(SpecularStrengthFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleSpecularStrength(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfSpecularStrength,
             this->getType().getFieldDesc(SpecularStrengthFieldId),
             this));


    editSField(SpecularStrengthFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleEmissiveStrength (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfEmissiveStrength,
             this->getType().getFieldDesc(EmissiveStrengthFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleEmissiveStrength(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfEmissiveStrength,
             this->getType().getFieldDesc(EmissiveStrengthFieldId),
             this));


    editSField(EmissiveStrengthFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleOpacity         (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOpacity,
             this->getType().getFieldDesc(OpacityFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleOpacity        (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOpacity,
             this->getType().getFieldDesc(OpacityFieldId),
             this));


    editSField(OpacityFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleOpacityCutOff   (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOpacityCutOff,
             this->getType().getFieldDesc(OpacityCutOffFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleOpacityCutOff  (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOpacityCutOff,
             this->getType().getFieldDesc(OpacityCutOffFieldId),
             this));


    editSField(OpacityCutOffFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleOpacityMode     (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfOpacityMode,
             this->getType().getFieldDesc(OpacityModeFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleOpacityMode    (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfOpacityMode,
             this->getType().getFieldDesc(OpacityModeFieldId),
             this));


    editSField(OpacityModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleReflectivity    (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfReflectivity,
             this->getType().getFieldDesc(ReflectivityFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleReflectivity   (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfReflectivity,
             this->getType().getFieldDesc(ReflectivityFieldId),
             this));


    editSField(ReflectivityFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleReflectance     (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfReflectance,
             this->getType().getFieldDesc(ReflectanceFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleReflectance    (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfReflectance,
             this->getType().getFieldDesc(ReflectanceFieldId),
             this));


    editSField(ReflectanceFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleBumpScaling     (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBumpScaling,
             this->getType().getFieldDesc(BumpScalingFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleBumpScaling    (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBumpScaling,
             this->getType().getFieldDesc(BumpScalingFieldId),
             this));


    editSField(BumpScalingFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleAnisotropy      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfAnisotropy,
             this->getType().getFieldDesc(AnisotropyFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleAnisotropy     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfAnisotropy,
             this->getType().getFieldDesc(AnisotropyFieldId),
             this));


    editSField(AnisotropyFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleRoughness       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfRoughness,
             this->getType().getFieldDesc(RoughnessFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleRoughness      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfRoughness,
             this->getType().getFieldDesc(RoughnessFieldId),
             this));


    editSField(RoughnessFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleMetalness       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfMetalness,
             this->getType().getFieldDesc(MetalnessFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleMetalness      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfMetalness,
             this->getType().getFieldDesc(MetalnessFieldId),
             this));


    editSField(MetalnessFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleClearCoatStrength (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfClearCoatStrength,
             this->getType().getFieldDesc(ClearCoatStrengthFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleClearCoatStrength(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfClearCoatStrength,
             this->getType().getFieldDesc(ClearCoatStrengthFieldId),
             this));


    editSField(ClearCoatStrengthFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleClearCoatRoughness (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfClearCoatRoughness,
             this->getType().getFieldDesc(ClearCoatRoughnessFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleClearCoatRoughness(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfClearCoatRoughness,
             this->getType().getFieldDesc(ClearCoatRoughnessFieldId),
             this));


    editSField(ClearCoatRoughnessFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleSheenColor      (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfSheenColor,
             this->getType().getFieldDesc(SheenColorFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleSheenColor     (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfSheenColor,
             this->getType().getFieldDesc(SheenColorFieldId),
             this));


    editSField(SheenColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleSubSurfaceColor (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfSubSurfaceColor,
             this->getType().getFieldDesc(SubSurfaceColorFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleSubSurfaceColor(void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfSubSurfaceColor,
             this->getType().getFieldDesc(SubSurfaceColorFieldId),
             this));


    editSField(SubSurfaceColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleToonLevels      (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfToonLevels,
             this->getType().getFieldDesc(ToonLevelsFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleToonLevels     (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfToonLevels,
             this->getType().getFieldDesc(ToonLevelsFieldId),
             this));


    editSField(ToonLevelsFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleGoochCool       (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfGoochCool,
             this->getType().getFieldDesc(GoochCoolFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleGoochCool      (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfGoochCool,
             this->getType().getFieldDesc(GoochCoolFieldId),
             this));


    editSField(GoochCoolFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleGoochWarm       (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfGoochWarm,
             this->getType().getFieldDesc(GoochWarmFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleGoochWarm      (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfGoochWarm,
             this->getType().getFieldDesc(GoochWarmFieldId),
             this));


    editSField(GoochWarmFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleGoochMixin      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfGoochMixin,
             this->getType().getFieldDesc(GoochMixinFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleGoochMixin     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfGoochMixin,
             this->getType().getFieldDesc(GoochMixinFieldId),
             this));


    editSField(GoochMixinFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleGoochCoolMixin  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfGoochCoolMixin,
             this->getType().getFieldDesc(GoochCoolMixinFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleGoochCoolMixin (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfGoochCoolMixin,
             this->getType().getFieldDesc(GoochCoolMixinFieldId),
             this));


    editSField(GoochCoolMixinFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleGoochWarmMixin  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfGoochWarmMixin,
             this->getType().getFieldDesc(GoochWarmMixinFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleGoochWarmMixin (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfGoochWarmMixin,
             this->getType().getFieldDesc(GoochWarmMixinFieldId),
             this));


    editSField(GoochWarmMixinFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleCullFace        (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfCullFace,
             this->getType().getFieldDesc(CullFaceFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleCullFace       (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfCullFace,
             this->getType().getFieldDesc(CullFaceFieldId),
             this));


    editSField(CullFaceFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleFrontFace       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfFrontFace,
             this->getType().getFieldDesc(FrontFaceFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleFrontFace      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfFrontFace,
             this->getType().getFieldDesc(FrontFaceFieldId),
             this));


    editSField(FrontFaceFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleFrontMode       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfFrontMode,
             this->getType().getFieldDesc(FrontModeFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleFrontMode      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfFrontMode,
             this->getType().getFieldDesc(FrontModeFieldId),
             this));


    editSField(FrontModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleBackMode        (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfBackMode,
             this->getType().getFieldDesc(BackModeFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleBackMode       (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfBackMode,
             this->getType().getFieldDesc(BackModeFieldId),
             this));


    editSField(BackModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleOffsetFactor    (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffsetFactor,
             this->getType().getFieldDesc(OffsetFactorFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleOffsetFactor   (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffsetFactor,
             this->getType().getFieldDesc(OffsetFactorFieldId),
             this));


    editSField(OffsetFactorFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleOffsetBias      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffsetBias,
             this->getType().getFieldDesc(OffsetBiasFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleOffsetBias     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffsetBias,
             this->getType().getFieldDesc(OffsetBiasFieldId),
             this));


    editSField(OffsetBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleTextureDesc     (void) const
{
    MFUnrecTextureDescPtr::GetHandlePtr returnValue(
        new  MFUnrecTextureDescPtr::GetHandle(
             &_mfTextureDesc,
             this->getType().getFieldDesc(TextureDescFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleTextureDesc    (void)
{
    MFUnrecTextureDescPtr::EditHandlePtr returnValue(
        new  MFUnrecTextureDescPtr::EditHandle(
             &_mfTextureDesc,
             this->getType().getFieldDesc(TextureDescFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&MaterialDesc::pushToTextureDesc,
                    static_cast<MaterialDesc *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&MaterialDesc::removeFromTextureDesc,
                    static_cast<MaterialDesc *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&MaterialDesc::removeObjFromTextureDesc,
                    static_cast<MaterialDesc *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&MaterialDesc::clearTextureDesc,
                    static_cast<MaterialDesc *>(this)));

    editMField(TextureDescFieldMask, _mfTextureDesc);

    return returnValue;
}

GetFieldHandlePtr MaterialDescBase::getHandleExcludeHashingMask (void) const
{
    SFBitVector::GetHandlePtr returnValue(
        new  SFBitVector::GetHandle(
             &_sfExcludeHashingMask,
             this->getType().getFieldDesc(ExcludeHashingMaskFieldId),
             const_cast<MaterialDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr MaterialDescBase::editHandleExcludeHashingMask(void)
{
    SFBitVector::EditHandlePtr returnValue(
        new  SFBitVector::EditHandle(
             &_sfExcludeHashingMask,
             this->getType().getFieldDesc(ExcludeHashingMaskFieldId),
             this));


    editSField(ExcludeHashingMaskFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void MaterialDescBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    MaterialDesc *pThis = static_cast<MaterialDesc *>(this);

    pThis->execSync(static_cast<MaterialDesc *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *MaterialDescBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    MaterialDesc *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const MaterialDesc *>(pRefAspect),
                  dynamic_cast<const MaterialDesc *>(this));

    return returnValue;
}
#endif

void MaterialDescBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<MaterialDesc *>(this)->clearTextureDesc();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfUVDimension.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
