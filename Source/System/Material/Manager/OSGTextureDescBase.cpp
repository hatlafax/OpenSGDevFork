/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureDesc!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"


#include "OSGGL.h"                        // WrapS default header
#include "OSGGL.h"                        // WrapT default header
#include "OSGGL.h"                        // WrapR default header
#include "OSGGL.h"                        // MinFilter default header
#include "OSGGL.h"                        // MagFilter default header
#include "OSGGL.h"                        // InternalFormat default header
#include "OSGGL.h"                        // ExternalFormat default header

#include "OSGImage.h"                   // TexImage Class
#include "OSGHashKeyToFieldContainerMap.h" // ImageMap Class

#include "OSGTextureDescBase.h"
#include "OSGTextureDesc.h"

#include <boost/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::TextureDesc
    This class generally describes material textures. The class has been 
    desigend among other things to be compatible with the Assimp library 
    material texture format.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var UInt32          TextureDescBase::_sfTextureType
    This value defines the type of the texture. Allowed values are
    defined in the header file: NONE_TEXTURE, UNKNOWN_TEXTURE,
    ALBEDO_TEXTURE, SPECULAR_TEXTURE,
    EMISSIVE_TEXTURE, SHININESS_TEXTURE, OPACITY_TEXTURE, NORMALS_TEXTURE, 
    HEIGHT_TEXTURE, DISPLACEMENT_TEXTURE, REFLECTION_TEXTURE,
    REFRACTION_TEXTURE, ANISOTROPY_U_TEXTURE, ANISOTROPY_V_TEXTURE,
    ANISOTROPY_UV_TEXTURE, AMBIENT_OCCLUSION_TEXTURE, ROUGH_TEXTURE,
    METAL_TEXTURE, ROUGH_METAL_TEXTURE, OCCL_ROUGH_METAL_TEXTURE,
    IRRADIANCE_TEXTURE, PRE_FILTER_TEXTURE, BRDF_LUT_TEXTURE,
    STANDARD_MATERIAL_TEXTURE
*/

/*! \var std::string     TextureDescBase::_sfSwizzle
    Some textures types use multiple channels. The swizzle string allows to
    define which channel is used for the specific information. Only combinations
    of the letters 'r', 'g', 'b' and 'a' are allowed.
    Example: A OCCL_ROUGH_METAL_TEXTURE texture does have three channles available.
    With the string 'rbg' the ambient occlusion is taken from the red channel,
    the metalness is taken from the blue channel and the roughness is taken
    from the green channel of the texture.
*/

/*! \var bool            TextureDescBase::_sfIsSRGBTexture
    Whether textures are handled as sRGB or linear images.
*/

/*! \var std::string     TextureDescBase::_mfFilename
    The file name of the image file of the texture. Six image file names can be provided for cube map textures
    (CUBEMAP_MAPPING). All other environment textures take only one image file name.
*/

/*! \var Int32           TextureDescBase::_sfTexUnit
    Defines the texture unit binding point for the texture. If the value is -1 (default)
    the texture unit will be automatically determined.
*/

/*! \var UInt32          TextureDescBase::_sfUVChannel
    Defines the UV channel to be used as input mapping coordinates for sampling this texture. 
    All meshes assigned to this material share the same UV channel setup. For environment
    textures this field does not make sense and it is ignored.
*/

/*! \var UInt32          TextureDescBase::_sfMappingMode
    Define the mapping mode for the texture. Allowed values are defined in the header file:
    UV_MAPPING, SPHERE_MAPPING, CYLINDER_MAPPING, BOX_MAPPING, PLANE_MAPPING, OTHER_MAPPING.
*/

/*! \var Vec3f           TextureDescBase::_sfMapAxis
    Defines the base axis to compute the mapping coordinates. This is not required for 
    UV-mapped textures. For instance, if mapping mode is SPHERE_MAPPING, U and V would map 
    to longitude and latitude of a sphere around the given axis. The axis is given in local 
    mesh space.
*/

/*! \var UInt32          TextureDescBase::_sfEnvironmentMapType
    For environment maps (REFLECTION_TEXTURE, REFRACTION_TEXTURE, IRRADIANCE_TEXTURE
    and PRE_FILTER_TEXTURE) this field defines two things. At first it defines how the
    image file is to be handled. E.g. for a HORIZONTAL_CROSS_CUBE_MAP map the six cube 
    map images are extracted from the provided single image file names automatically.
    For a CUBE_MAP on the other hand six image file names must be provided, whereas for
    a EQUIRECTANGULAR_MAP only one image file name needs to be provided. 
    Secondly, this field defines the texture access pattern in the material shader.
    All environment maps access the texture with by means of a direction vector of 
    some kind. However, the EQUIRECTANGULAR_MAP first translates this direction vector
    into a 2D UV coordinate in the lateral longitude EQUIRECTANGULAR_MAP.
    Allowed values and number of files that needs to be provided:

    OTHER_MAP                : default, not an environment map
    EQUIRECTANGULAR_MAP      : one lateral longitude file name expected
    CUBE_MAP                 : six image files for the six cube faces
    VERTICAL_CROSS_CUBE_MAP  : one image file for the six cube faces with verical cross ordering
    HORIZONTAL_CROSS_CUBE_MAP: one image file for the six cube faces with horizontal cross ordering
    VERTICAL_STRIP_CUBE_MAP  : one image file for the six cube faces with verical stripe ordering
    HORIZONTAL_STRIP_CUBE_MAP: one image file for the six cube faces with horizontal stripe ordering
*/

/*! \var Real32          TextureDescBase::_sfBlendFactor
    Defines the strength or blend factor. With the exception BLEND_OPERATION operation the
    texture rgb color components are premultiplied by this factor *before* any further processing
    is done. However, if the operation is BLEND_OPERATION true linear interpolation is performed 
    between the current color and the texture color with respect to the blendFactor.
*/

/*! \var UInt32          TextureDescBase::_sfOperation
    Defines the arithmetic operation to be used to combine the n'th texture on the stack with the n-1'th.
    The first texture is blended with the base color. Allowed values are defined in the header file:
    MULTIPLY_OPERATION, ADD_OPERATION, SUBTRACT_OPERATION, DIVIDE_OPERATION, SMOOTHADD_OPERATION,
    SIGNEDADD_OPERATION, REPLACE_OPERATION, DECAL_OPERATION, BLEND_OPERATION.
    Provided Co=(co,ao) is the original linearized texture color. Then the source color is 
    Cs=(cs,as)=(b*co,ao) and the previous color should be Cp=(cp,ap).
    Then the operations perform the following tasks yielding the resulting color Cr=(cr,ar):
*/

/*! \var GLenum          TextureDescBase::_sfWrapS
    Defines the texture mapping mode on the x axis for sampling the texture. Allowed values are
    GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.
*/

/*! \var GLenum          TextureDescBase::_sfWrapT
    Defines the texture mapping mode on the y axis for sampling the texture. Allowed values are
    GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.
*/

/*! \var GLenum          TextureDescBase::_sfWrapR
    Defines the texture mapping mode on the z axis for sampling the texture. Allowed values are
    GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.
*/

/*! \var UInt32          TextureDescBase::_sfTextureFlags
    Define additional texure flags. Allowed values are defined in the header file:
    EMPTY_FLAG, INVERT_FLAG, USE_ALPHA_FLAG, IGNORE_ALPHA_FLAG, NORMAL_DIRECTX_FLAG
*/

/*! \var GLenum          TextureDescBase::_sfMinFilter
    The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.
    Allowed values are GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_NEAREST,
    GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_LINEAR.
*/

/*! \var GLenum          TextureDescBase::_sfMagFilter
    The magnification filter, default GL_LINEAR.
    Allowed values are GL_NEAREST, GL_LINEAR.
*/

/*! \var GLenum          TextureDescBase::_sfInternalFormat
    The internal texture format. If none is provided, the internal format is determined from the image pixel format.
*/

/*! \var GLenum          TextureDescBase::_sfExternalFormat
    The external texture format - overwrites 
    external format of image when set to a value not equal to 
    GL_NONE (which is the default).
*/

/*! \var Real32          TextureDescBase::_sfAnisotropy
    Anisotropic filtering the default 1.0f means isotropic filtering.
*/

/*! \var UInt32          TextureDescBase::_sfMirrorFlags
    If possible, flip the texture image in width, height or depth direction.
    Allowed values is any combination of the following flags:
    MIRROR_HORIZONTAL_DIRECTION, MIRROR_VERTICAL_DIRECTION, MIRROR_DEPTH_DIRECTION and
    MIRROR_HORIZONTAL_DIRECTION_POS_X, MIRROR_HORIZONTAL_DIRECTION_POS_Y, MIRROR_HORIZONTAL_DIRECTION_POS_Z,
    MIRROR_VERTICAL_DIRECTION_POS_X, MIRROR_VERTICAL_DIRECTION_POS_Y, MIRROR_VERTICAL_DIRECTION_POS_Z,
    MIRROR_HORIZONTAL_DIRECTION_NEG_X, MIRROR_HORIZONTAL_DIRECTION_NEG_Y, MIRROR_HORIZONTAL_DIRECTION_NEG_Z,
    MIRROR_VERTICAL_DIRECTION_NEG_X, MIRROR_VERTICAL_DIRECTION_NEG_Y, MIRROR_VERTICAL_DIRECTION_NEG_Z.
*/

/*! \var Vec2f           TextureDescBase::_sfScale
    Defined the scale part of the UV transformation.
*/

/*! \var Vec2f           TextureDescBase::_sfTranslate
    Defined the translation part of the UV transformation.
*/

/*! \var Real32          TextureDescBase::_sfRotate
    Defined the rotation part specified in radians of the UV transformation.
    The rotation center is (0f,.0f)
*/

/*! \var bool            TextureDescBase::_sfHasUVTransform
    This flag is set to be true is a transformation of the texture coordinates
    is available.
*/

/*! \var Color4f         TextureDescBase::_sfBorderColor
    Texture border color
*/

/*! \var Image *         TextureDescBase::_mfTexImage
    The texture image for embedded textures.
*/

/*! \var HashKeyToFieldContainerMap * TextureDescBase::_sfImageMap
    A manager for image resources.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<TextureDesc *, nsOSG>::_type(
    "TextureDescPtr", 
    "FieldContainerPtr", 
    TextureDesc::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(TextureDesc *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           TextureDesc *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           TextureDesc *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void TextureDescBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "textureType",
        "This value defines the type of the texture. Allowed values are\n"
        "defined in the header file: NONE_TEXTURE, UNKNOWN_TEXTURE,\n"
        "ALBEDO_TEXTURE, SPECULAR_TEXTURE,\n"
        "EMISSIVE_TEXTURE, SHININESS_TEXTURE, OPACITY_TEXTURE, NORMALS_TEXTURE, \n"
        "HEIGHT_TEXTURE, DISPLACEMENT_TEXTURE, REFLECTION_TEXTURE,\n"
        "REFRACTION_TEXTURE, ANISOTROPY_U_TEXTURE, ANISOTROPY_V_TEXTURE,\n"
        "ANISOTROPY_UV_TEXTURE, AMBIENT_OCCLUSION_TEXTURE, ROUGH_TEXTURE,\n"
        "METAL_TEXTURE, ROUGH_METAL_TEXTURE, OCCL_ROUGH_METAL_TEXTURE,\n"
        "IRRADIANCE_TEXTURE, PRE_FILTER_TEXTURE, BRDF_LUT_TEXTURE,\n"
        "STANDARD_MATERIAL_TEXTURE\n",
        TextureTypeFieldId, TextureTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleTextureType),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleTextureType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "swizzle",
        "Some textures types use multiple channels. The swizzle string allows to\n"
        "define which channel is used for the specific information. Only combinations\n"
        "of the letters 'r', 'g', 'b' and 'a' are allowed.\n"
        "Example: A OCCL_ROUGH_METAL_TEXTURE texture does have three channles available.\n"
        "With the string 'rbg' the ambient occlusion is taken from the red channel,\n"
        "the metalness is taken from the blue channel and the roughness is taken\n"
        "from the green channel of the texture.\n",
        SwizzleFieldId, SwizzleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleSwizzle),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleSwizzle));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "isSRGBTexture",
        "Whether textures are handled as sRGB or linear images.\n",
        IsSRGBTextureFieldId, IsSRGBTextureFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleIsSRGBTexture),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleIsSRGBTexture));

    oType.addInitialDesc(pDesc);

    pDesc = new MFString::Description(
        MFString::getClassType(),
        "filename",
        "The file name of the image file of the texture. Six image file names can be provided for cube map textures\n"
        "(CUBEMAP_MAPPING). All other environment textures take only one image file name.\n",
        FilenameFieldId, FilenameFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleFilename),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleFilename));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "texUnit",
        "Defines the texture unit binding point for the texture. If the value is -1 (default)\n"
        "the texture unit will be automatically determined.\n",
        TexUnitFieldId, TexUnitFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleTexUnit),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleTexUnit));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "UVChannel",
        "Defines the UV channel to be used as input mapping coordinates for sampling this texture. \n"
        "All meshes assigned to this material share the same UV channel setup. For environment\n"
        "textures this field does not make sense and it is ignored.\n",
        UVChannelFieldId, UVChannelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleUVChannel),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleUVChannel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "mappingMode",
        "Define the mapping mode for the texture. Allowed values are defined in the header file:\n"
        "UV_MAPPING, SPHERE_MAPPING, CYLINDER_MAPPING, BOX_MAPPING, PLANE_MAPPING, OTHER_MAPPING.\n",
        MappingModeFieldId, MappingModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleMappingMode),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleMappingMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(),
        "mapAxis",
        "Defines the base axis to compute the mapping coordinates. This is not required for \n"
        "UV-mapped textures. For instance, if mapping mode is SPHERE_MAPPING, U and V would map \n"
        "to longitude and latitude of a sphere around the given axis. The axis is given in local \n"
        "mesh space.\n",
        MapAxisFieldId, MapAxisFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleMapAxis),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleMapAxis));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "environmentMapType",
        "For environment maps (REFLECTION_TEXTURE, REFRACTION_TEXTURE, IRRADIANCE_TEXTURE\n"
        "and PRE_FILTER_TEXTURE) this field defines two things. At first it defines how the\n"
        "image file is to be handled. E.g. for a HORIZONTAL_CROSS_CUBE_MAP map the six cube \n"
        "map images are extracted from the provided single image file names automatically.\n"
        "For a CUBE_MAP on the other hand six image file names must be provided, whereas for\n"
        "a EQUIRECTANGULAR_MAP only one image file name needs to be provided. \n"
        "Secondly, this field defines the texture access pattern in the material shader.\n"
        "All environment maps access the texture with by means of a direction vector of \n"
        "some kind. However, the EQUIRECTANGULAR_MAP first translates this direction vector\n"
        "into a 2D UV coordinate in the lateral longitude EQUIRECTANGULAR_MAP.\n"
        "Allowed values and number of files that needs to be provided:\n"
        "\n"
        "OTHER_MAP                : default, not an environment map\n"
        "EQUIRECTANGULAR_MAP      : one lateral longitude file name expected\n"
        "CUBE_MAP                 : six image files for the six cube faces\n"
        "VERTICAL_CROSS_CUBE_MAP  : one image file for the six cube faces with verical cross ordering\n"
        "HORIZONTAL_CROSS_CUBE_MAP: one image file for the six cube faces with horizontal cross ordering\n"
        "VERTICAL_STRIP_CUBE_MAP  : one image file for the six cube faces with verical stripe ordering\n"
        "HORIZONTAL_STRIP_CUBE_MAP: one image file for the six cube faces with horizontal stripe ordering\n"
        "\n"
        "Environment maps do not need an UV channel and they. They might use the provided blendFactor\n"
        "but do not perform an expicit texture operation, transformation or mirroring step.\n",
        EnvironmentMapTypeFieldId, EnvironmentMapTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleEnvironmentMapType),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleEnvironmentMapType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "blendFactor",
        "Defines the strength or blend factor. With the exception BLEND_OPERATION operation the\n"
        "texture rgb color components are premultiplied by this factor *before* any further processing\n"
        "is done. However, if the operation is BLEND_OPERATION true linear interpolation is performed \n"
        "between the current color and the texture color with respect to the blendFactor.\n",
        BlendFactorFieldId, BlendFactorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleBlendFactor),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleBlendFactor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "operation",
        "Defines the arithmetic operation to be used to combine the n'th texture on the stack with the n-1'th.\n"
        "The first texture is blended with the base color. Allowed values are defined in the header file:\n"
        "MULTIPLY_OPERATION, ADD_OPERATION, SUBTRACT_OPERATION, DIVIDE_OPERATION, SMOOTHADD_OPERATION,\n"
        "SIGNEDADD_OPERATION, REPLACE_OPERATION, DECAL_OPERATION, BLEND_OPERATION.\n"
        "Provided Co=(co,ao) is the original linearized texture color. Then the source color is \n"
        "Cs=(cs,as)=(b*co,ao) and the previous color should be Cp=(cp,ap).\n"
        "Then the operations perform the following tasks yielding the resulting color Cr=(cr,ar):\n"
        "\n"
        "MULTIPLY_OPERATION      : Cr = (cr,ar) = (cp*cs, ap*as)\n"
        "DIVIDE_OPERATION        : Cr = (cr,ar) = (cp/cs, ap*as)\n"
        "ADD_OPERATION           : Cr = (cr,ar) = (cp+cs, ap*as)\n"
        "SUBTRACT_OPERATION      : Cr = (cr,ar) = (cp-cs, ap*as)\n"
        "SMOOTHADD_OPERATION     : Cr = (cr,ar) = (cp+cs - cp*cs, ap*as)\n"
        "SIGNEDADD_OPERATION     : Cr = (cr,ar) = (cp+cs - 0.5, ap*as)\n"
        "REPLACE_OPERATION       : Cr = (cr,ar) = (cs,as)\n"
        "DECAL_OPERATION         : Cr = (cr,ar) = ((1-as)*cp + as*cs, ap)\n"
        "BLEND_OPERATION         : Cr = (cr,ar) = ((1-b)*cp + b*co, ap*as)\n",
        OperationFieldId, OperationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleOperation),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleOperation));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapS",
        "Defines the texture mapping mode on the x axis for sampling the texture. Allowed values are\n"
        "GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.\n",
        WrapSFieldId, WrapSFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleWrapS),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleWrapS));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapT",
        "Defines the texture mapping mode on the y axis for sampling the texture. Allowed values are\n"
        "GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.\n",
        WrapTFieldId, WrapTFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleWrapT),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleWrapT));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapR",
        "Defines the texture mapping mode on the z axis for sampling the texture. Allowed values are\n"
        "GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.\n",
        WrapRFieldId, WrapRFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleWrapR),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleWrapR));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "textureFlags",
        "Define additional texure flags. Allowed values are defined in the header file:\n"
        "EMPTY_FLAG, INVERT_FLAG, USE_ALPHA_FLAG, IGNORE_ALPHA_FLAG, NORMAL_DIRECTX_FLAG\n",
        TextureFlagsFieldId, TextureFlagsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleTextureFlags),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleTextureFlags));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "minFilter",
        "The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n"
        "Allowed values are GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_NEAREST,\n"
        "GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_LINEAR.\n",
        MinFilterFieldId, MinFilterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleMinFilter),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleMinFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "magFilter",
        "The magnification filter, default GL_LINEAR.\n"
        "Allowed values are GL_NEAREST, GL_LINEAR.\n",
        MagFilterFieldId, MagFilterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleMagFilter),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleMagFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "internalFormat",
        "The internal texture format. If none is provided, the internal format is determined from the image pixel format.\n",
        InternalFormatFieldId, InternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleInternalFormat),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "externalFormat",
        "The external texture format - overwrites \n"
        "external format of image when set to a value not equal to \n"
        "GL_NONE (which is the default).\n",
        ExternalFormatFieldId, ExternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleExternalFormat),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleExternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "anisotropy",
        "Anisotropic filtering the default 1.0f means isotropic filtering.\n",
        AnisotropyFieldId, AnisotropyFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleAnisotropy),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleAnisotropy));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "mirrorFlags",
        "If possible, flip the texture image in width, height or depth direction.\n"
        "Allowed values is any combination of the following flags:\n"
        "MIRROR_HORIZONTAL_DIRECTION, MIRROR_VERTICAL_DIRECTION, MIRROR_DEPTH_DIRECTION and\n"
        "MIRROR_HORIZONTAL_DIRECTION_POS_X, MIRROR_HORIZONTAL_DIRECTION_POS_Y, MIRROR_HORIZONTAL_DIRECTION_POS_Z,\n"
        "MIRROR_VERTICAL_DIRECTION_POS_X, MIRROR_VERTICAL_DIRECTION_POS_Y, MIRROR_VERTICAL_DIRECTION_POS_Z,\n"
        "MIRROR_HORIZONTAL_DIRECTION_NEG_X, MIRROR_HORIZONTAL_DIRECTION_NEG_Y, MIRROR_HORIZONTAL_DIRECTION_NEG_Z,\n"
        "MIRROR_VERTICAL_DIRECTION_NEG_X, MIRROR_VERTICAL_DIRECTION_NEG_Y, MIRROR_VERTICAL_DIRECTION_NEG_Z.\n",
        MirrorFlagsFieldId, MirrorFlagsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleMirrorFlags),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleMirrorFlags));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec2f::Description(
        SFVec2f::getClassType(),
        "scale",
        "Defined the scale part of the UV transformation.\n",
        ScaleFieldId, ScaleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleScale),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleScale));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec2f::Description(
        SFVec2f::getClassType(),
        "translate",
        "Defined the translation part of the UV transformation.\n",
        TranslateFieldId, TranslateFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleTranslate),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleTranslate));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "rotate",
        "Defined the rotation part specified in radians of the UV transformation.\n"
        "The rotation center is (0f,.0f)\n",
        RotateFieldId, RotateFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleRotate),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleRotate));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "hasUVTransform",
        "This flag is set to be true is a transformation of the texture coordinates\n"
        "is available.\n",
        HasUVTransformFieldId, HasUVTransformFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleHasUVTransform),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleHasUVTransform));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(),
        "borderColor",
        "Texture border color\n",
        BorderColorFieldId, BorderColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleBorderColor),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleBorderColor));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecImagePtr::Description(
        MFUnrecImagePtr::getClassType(),
        "texImage",
        "The texture image for embedded textures.\n",
        TexImageFieldId, TexImageFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleTexImage),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleTexImage));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecHashKeyToFieldContainerMapPtr::Description(
        SFUnrecHashKeyToFieldContainerMapPtr::getClassType(),
        "imageMap",
        "A manager for image resources.\n",
        ImageMapFieldId, ImageMapFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureDesc::editHandleImageMap),
        static_cast<FieldGetMethodSig >(&TextureDesc::getHandleImageMap));

    oType.addInitialDesc(pDesc);
}


TextureDescBase::TypeObject TextureDescBase::_type(
    TextureDescBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&TextureDescBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&TextureDesc::initMethod),
    reinterpret_cast<ExitContainerF>(&TextureDesc::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&TextureDesc::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"TextureDesc\"\n"
    "    parent=\"FieldContainer\"\n"
    "    library=\"System\"\n"
    "    structure=\"concrete\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    docGroupBase=\"GrpSystemMaterial\"\n"
    "    >\n"
    "    This class generally describes material textures. The class has been \n"
    "    desigend among other things to be compatible with the Assimp library \n"
    "    material texture format.\n"
    "    <Field\n"
    "        name=\"textureType\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        This value defines the type of the texture. Allowed values are\n"
    "        defined in the header file: NONE_TEXTURE, UNKNOWN_TEXTURE,\n"
    "        ALBEDO_TEXTURE, SPECULAR_TEXTURE,\n"
    "        EMISSIVE_TEXTURE, SHININESS_TEXTURE, OPACITY_TEXTURE, NORMALS_TEXTURE, \n"
    "        HEIGHT_TEXTURE, DISPLACEMENT_TEXTURE, REFLECTION_TEXTURE,\n"
    "        REFRACTION_TEXTURE, ANISOTROPY_U_TEXTURE, ANISOTROPY_V_TEXTURE,\n"
    "        ANISOTROPY_UV_TEXTURE, AMBIENT_OCCLUSION_TEXTURE, ROUGH_TEXTURE,\n"
    "        METAL_TEXTURE, ROUGH_METAL_TEXTURE, OCCL_ROUGH_METAL_TEXTURE,\n"
    "        IRRADIANCE_TEXTURE, PRE_FILTER_TEXTURE, BRDF_LUT_TEXTURE,\n"
    "        STANDARD_MATERIAL_TEXTURE\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"swizzle\"\n"
    "        type=\"std::string\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue='\"rgba\"'\n"
    "        >\n"
    "        Some textures types use multiple channels. The swizzle string allows to\n"
    "        define which channel is used for the specific information. Only combinations\n"
    "        of the letters 'r', 'g', 'b' and 'a' are allowed.\n"
    "        Example: A OCCL_ROUGH_METAL_TEXTURE texture does have three channles available.\n"
    "                 With the string 'rbg' the ambient occlusion is taken from the red channel,\n"
    "                 the metalness is taken from the blue channel and the roughness is taken\n"
    "                 from the green channel of the texture.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"isSRGBTexture\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"true\"\n"
    "        >\n"
    "        Whether textures are handled as sRGB or linear images.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"filename\"\n"
    "        type=\"std::string\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"\"\n"
    "        >\n"
    "        The file name of the image file of the texture. Six image file names can be provided for cube map textures\n"
    "        (CUBEMAP_MAPPING). All other environment textures take only one image file name.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"texUnit\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"-1\"\n"
    "        >\n"
    "        Defines the texture unit binding point for the texture. If the value is -1 (default)\n"
    "        the texture unit will be automatically determined.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"UVChannel\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Defines the UV channel to be used as input mapping coordinates for sampling this texture. \n"
    "        All meshes assigned to this material share the same UV channel setup. For environment\n"
    "        textures this field does not make sense and it is ignored.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"mappingMode\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Define the mapping mode for the texture. Allowed values are defined in the header file:\n"
    "        UV_MAPPING, SPHERE_MAPPING, CYLINDER_MAPPING, BOX_MAPPING, PLANE_MAPPING, OTHER_MAPPING.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"mapAxis\"\n"
    "        type=\"Vec3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"Vec3f(0.f,0.f,0.f)\"\n"
    "        >\n"
    "        Defines the base axis to compute the mapping coordinates. This is not required for \n"
    "        UV-mapped textures. For instance, if mapping mode is SPHERE_MAPPING, U and V would map \n"
    "        to longitude and latitude of a sphere around the given axis. The axis is given in local \n"
    "        mesh space.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"environmentMapType\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        For environment maps (REFLECTION_TEXTURE, REFRACTION_TEXTURE, IRRADIANCE_TEXTURE\n"
    "        and PRE_FILTER_TEXTURE) this field defines two things. At first it defines how the\n"
    "        image file is to be handled. E.g. for a HORIZONTAL_CROSS_CUBE_MAP map the six cube \n"
    "        map images are extracted from the provided single image file names automatically.\n"
    "        For a CUBE_MAP on the other hand six image file names must be provided, whereas for\n"
    "        a EQUIRECTANGULAR_MAP only one image file name needs to be provided. \n"
    "        Secondly, this field defines the texture access pattern in the material shader.\n"
    "        All environment maps access the texture with by means of a direction vector of \n"
    "        some kind. However, the EQUIRECTANGULAR_MAP first translates this direction vector\n"
    "        into a 2D UV coordinate in the lateral longitude EQUIRECTANGULAR_MAP.\n"
    "        Allowed values and number of files that needs to be provided:\n"
    "\n"
    "        OTHER_MAP                : default, not an environment map\n"
    "        EQUIRECTANGULAR_MAP      : one lateral longitude file name expected\n"
    "        CUBE_MAP                 : six image files for the six cube faces\n"
    "        VERTICAL_CROSS_CUBE_MAP  : one image file for the six cube faces with verical cross ordering\n"
    "        HORIZONTAL_CROSS_CUBE_MAP: one image file for the six cube faces with horizontal cross ordering\n"
    "        VERTICAL_STRIP_CUBE_MAP  : one image file for the six cube faces with verical stripe ordering\n"
    "        HORIZONTAL_STRIP_CUBE_MAP: one image file for the six cube faces with horizontal stripe ordering\n"
    "\n"
    "        Environment maps do not need an UV channel and they. They might use the provided blendFactor\n"
    "        but do not perform an expicit texture operation, transformation or mirroring step.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"blendFactor\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        Defines the strength or blend factor. With the exception BLEND_OPERATION operation the\n"
    "        texture rgb color components are premultiplied by this factor *before* any further processing\n"
    "        is done. However, if the operation is BLEND_OPERATION true linear interpolation is performed \n"
    "        between the current color and the texture color with respect to the blendFactor.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"operation\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Defines the arithmetic operation to be used to combine the n'th texture on the stack with the n-1'th.\n"
    "        The first texture is blended with the base color. Allowed values are defined in the header file:\n"
    "        MULTIPLY_OPERATION, ADD_OPERATION, SUBTRACT_OPERATION, DIVIDE_OPERATION, SMOOTHADD_OPERATION,\n"
    "        SIGNEDADD_OPERATION, REPLACE_OPERATION, DECAL_OPERATION, BLEND_OPERATION.\n"
    "        Provided Co=(co,ao) is the original linearized texture color. Then the source color is \n"
    "        Cs=(cs,as)=(b*co,ao) and the previous color should be Cp=(cp,ap).\n"
    "        Then the operations perform the following tasks yielding the resulting color Cr=(cr,ar):\n"
    "\n"
    "        MULTIPLY_OPERATION      : Cr = (cr,ar) = (cp*cs, ap*as)\n"
    "        DIVIDE_OPERATION        : Cr = (cr,ar) = (cp/cs, ap*as)\n"
    "        ADD_OPERATION           : Cr = (cr,ar) = (cp+cs, ap*as)\n"
    "        SUBTRACT_OPERATION      : Cr = (cr,ar) = (cp-cs, ap*as)\n"
    "        SMOOTHADD_OPERATION     : Cr = (cr,ar) = (cp+cs - cp*cs, ap*as)\n"
    "        SIGNEDADD_OPERATION     : Cr = (cr,ar) = (cp+cs - 0.5, ap*as)\n"
    "        REPLACE_OPERATION       : Cr = (cr,ar) = (cs,as)\n"
    "        DECAL_OPERATION         : Cr = (cr,ar) = ((1-as)*cp + as*cs, ap)\n"
    "        BLEND_OPERATION         : Cr = (cr,ar) = ((1-b)*cp + b*co, ap*as)\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"wrapS\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"GL_REPEAT\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        >\n"
    "        Defines the texture mapping mode on the x axis for sampling the texture. Allowed values are\n"
    "        GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"wrapT\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"GL_REPEAT\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        >\n"
    "        Defines the texture mapping mode on the y axis for sampling the texture. Allowed values are\n"
    "        GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"wrapR\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"GL_REPEAT\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        >\n"
    "        Defines the texture mapping mode on the z axis for sampling the texture. Allowed values are\n"
    "        GL_CLAMP, GL_CLAMP_TO_BORDER, GL_CLAMP_TO_EDGE, GL_MIRRORED_REPEAT, or GL_REPEAT.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"textureFlags\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        Define additional texure flags. Allowed values are defined in the header file:\n"
    "        EMPTY_FLAG, INVERT_FLAG, USE_ALPHA_FLAG, IGNORE_ALPHA_FLAG, NORMAL_DIRECTX_FLAG\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"minFilter\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_LINEAR_MIPMAP_LINEAR\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "        The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n"
    "        Allowed values are GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_NEAREST,\n"
    "        GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_LINEAR.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"magFilter\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_LINEAR\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "        The magnification filter, default GL_LINEAR.\n"
    "        Allowed values are GL_NEAREST, GL_LINEAR.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"internalFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_NONE\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "\tThe internal texture format. If none is provided, the internal format is determined from the image pixel format.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"externalFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_NONE\"\n"
    "        defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "        The external texture format - overwrites \n"
    "        external format of image when set to a value not equal to \n"
    "        GL_NONE (which is the default).\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"anisotropy\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.0f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Anisotropic filtering the default 1.0f means isotropic filtering.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"mirrorFlags\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0\"\n"
    "        >\n"
    "        If possible, flip the texture image in width, height or depth direction.\n"
    "        Allowed values is any combination of the following flags:\n"
    "            MIRROR_HORIZONTAL_DIRECTION, MIRROR_VERTICAL_DIRECTION, MIRROR_DEPTH_DIRECTION and\n"
    "            MIRROR_HORIZONTAL_DIRECTION_POS_X, MIRROR_HORIZONTAL_DIRECTION_POS_Y, MIRROR_HORIZONTAL_DIRECTION_POS_Z,\n"
    "            MIRROR_VERTICAL_DIRECTION_POS_X, MIRROR_VERTICAL_DIRECTION_POS_Y, MIRROR_VERTICAL_DIRECTION_POS_Z,\n"
    "            MIRROR_HORIZONTAL_DIRECTION_NEG_X, MIRROR_HORIZONTAL_DIRECTION_NEG_Y, MIRROR_HORIZONTAL_DIRECTION_NEG_Z,\n"
    "            MIRROR_VERTICAL_DIRECTION_NEG_X, MIRROR_VERTICAL_DIRECTION_NEG_Y, MIRROR_VERTICAL_DIRECTION_NEG_Z.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"scale\"\n"
    "        type=\"Vec2f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"Vec2f(1.f,1.f)\"\n"
    "        >\n"
    "        Defined the scale part of the UV transformation.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"translate\"\n"
    "        type=\"Vec2f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"Vec2f(0.f,0.f)\"\n"
    "        >\n"
    "        Defined the translation part of the UV transformation.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"rotate\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"0.f\"\n"
    "        >\n"
    "        Defined the rotation part specified in radians of the UV transformation.\n"
    "        The rotation center is (0f,.0f)\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"hasUVTransform\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"false\"\n"
    "        >\n"
    "        This flag is set to be true is a transformation of the texture coordinates\n"
    "        is available.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"borderColor\"\n"
    "        type=\"Color4f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0,0,0,0\"\n"
    "        access=\"public\"\n"
    "\t>\n"
    "\tTexture border color\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"texImage\"\n"
    "        type=\"ImagePtr\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "\taccess=\"public\"\n"
    "        defaultValue=\"\"\n"
    "        >\n"
    "        The texture image for embedded textures.\n"
    "    </Field>\n"
    "    <Field\n"
    "         name=\"imageMap\"\n"
    "         type=\"HashKeyToFieldContainerMap\"\n"
    "         category=\"pointer\"\n"
    "         cardinality=\"single\"\n"
    "         visibility=\"internal\"\n"
    "         defaultValue=\"NULL\"\n"
    "         access=\"public\"\n"
    "         >\n"
    "        A manager for image resources.\n"
    "      </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "This class generally describes material textures. The class has been \n"
    "desigend among other things to be compatible with the Assimp library \n"
    "material texture format.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureDescBase::getType(void)
{
    return _type;
}

const FieldContainerType &TextureDescBase::getType(void) const
{
    return _type;
}

UInt32 TextureDescBase::getContainerSize(void) const
{
    return sizeof(TextureDesc);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *TextureDescBase::editSFTextureType(void)
{
    editSField(TextureTypeFieldMask);

    return &_sfTextureType;
}

const SFUInt32 *TextureDescBase::getSFTextureType(void) const
{
    return &_sfTextureType;
}


SFString *TextureDescBase::editSFSwizzle(void)
{
    editSField(SwizzleFieldMask);

    return &_sfSwizzle;
}

const SFString *TextureDescBase::getSFSwizzle(void) const
{
    return &_sfSwizzle;
}


SFBool *TextureDescBase::editSFIsSRGBTexture(void)
{
    editSField(IsSRGBTextureFieldMask);

    return &_sfIsSRGBTexture;
}

const SFBool *TextureDescBase::getSFIsSRGBTexture(void) const
{
    return &_sfIsSRGBTexture;
}


MFString *TextureDescBase::editMFFilename(void)
{
    editMField(FilenameFieldMask, _mfFilename);

    return &_mfFilename;
}

const MFString *TextureDescBase::getMFFilename(void) const
{
    return &_mfFilename;
}


SFInt32 *TextureDescBase::editSFTexUnit(void)
{
    editSField(TexUnitFieldMask);

    return &_sfTexUnit;
}

const SFInt32 *TextureDescBase::getSFTexUnit(void) const
{
    return &_sfTexUnit;
}


SFUInt32 *TextureDescBase::editSFUVChannel(void)
{
    editSField(UVChannelFieldMask);

    return &_sfUVChannel;
}

const SFUInt32 *TextureDescBase::getSFUVChannel(void) const
{
    return &_sfUVChannel;
}


SFUInt32 *TextureDescBase::editSFMappingMode(void)
{
    editSField(MappingModeFieldMask);

    return &_sfMappingMode;
}

const SFUInt32 *TextureDescBase::getSFMappingMode(void) const
{
    return &_sfMappingMode;
}


SFVec3f *TextureDescBase::editSFMapAxis(void)
{
    editSField(MapAxisFieldMask);

    return &_sfMapAxis;
}

const SFVec3f *TextureDescBase::getSFMapAxis(void) const
{
    return &_sfMapAxis;
}


SFUInt32 *TextureDescBase::editSFEnvironmentMapType(void)
{
    editSField(EnvironmentMapTypeFieldMask);

    return &_sfEnvironmentMapType;
}

const SFUInt32 *TextureDescBase::getSFEnvironmentMapType(void) const
{
    return &_sfEnvironmentMapType;
}


SFReal32 *TextureDescBase::editSFBlendFactor(void)
{
    editSField(BlendFactorFieldMask);

    return &_sfBlendFactor;
}

const SFReal32 *TextureDescBase::getSFBlendFactor(void) const
{
    return &_sfBlendFactor;
}


SFUInt32 *TextureDescBase::editSFOperation(void)
{
    editSField(OperationFieldMask);

    return &_sfOperation;
}

const SFUInt32 *TextureDescBase::getSFOperation(void) const
{
    return &_sfOperation;
}


SFGLenum *TextureDescBase::editSFWrapS(void)
{
    editSField(WrapSFieldMask);

    return &_sfWrapS;
}

const SFGLenum *TextureDescBase::getSFWrapS(void) const
{
    return &_sfWrapS;
}


SFGLenum *TextureDescBase::editSFWrapT(void)
{
    editSField(WrapTFieldMask);

    return &_sfWrapT;
}

const SFGLenum *TextureDescBase::getSFWrapT(void) const
{
    return &_sfWrapT;
}


SFGLenum *TextureDescBase::editSFWrapR(void)
{
    editSField(WrapRFieldMask);

    return &_sfWrapR;
}

const SFGLenum *TextureDescBase::getSFWrapR(void) const
{
    return &_sfWrapR;
}


SFUInt32 *TextureDescBase::editSFTextureFlags(void)
{
    editSField(TextureFlagsFieldMask);

    return &_sfTextureFlags;
}

const SFUInt32 *TextureDescBase::getSFTextureFlags(void) const
{
    return &_sfTextureFlags;
}


SFGLenum *TextureDescBase::editSFMinFilter(void)
{
    editSField(MinFilterFieldMask);

    return &_sfMinFilter;
}

const SFGLenum *TextureDescBase::getSFMinFilter(void) const
{
    return &_sfMinFilter;
}


SFGLenum *TextureDescBase::editSFMagFilter(void)
{
    editSField(MagFilterFieldMask);

    return &_sfMagFilter;
}

const SFGLenum *TextureDescBase::getSFMagFilter(void) const
{
    return &_sfMagFilter;
}


SFGLenum *TextureDescBase::editSFInternalFormat(void)
{
    editSField(InternalFormatFieldMask);

    return &_sfInternalFormat;
}

const SFGLenum *TextureDescBase::getSFInternalFormat(void) const
{
    return &_sfInternalFormat;
}


SFGLenum *TextureDescBase::editSFExternalFormat(void)
{
    editSField(ExternalFormatFieldMask);

    return &_sfExternalFormat;
}

const SFGLenum *TextureDescBase::getSFExternalFormat(void) const
{
    return &_sfExternalFormat;
}


SFReal32 *TextureDescBase::editSFAnisotropy(void)
{
    editSField(AnisotropyFieldMask);

    return &_sfAnisotropy;
}

const SFReal32 *TextureDescBase::getSFAnisotropy(void) const
{
    return &_sfAnisotropy;
}


SFUInt32 *TextureDescBase::editSFMirrorFlags(void)
{
    editSField(MirrorFlagsFieldMask);

    return &_sfMirrorFlags;
}

const SFUInt32 *TextureDescBase::getSFMirrorFlags(void) const
{
    return &_sfMirrorFlags;
}


SFVec2f *TextureDescBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFVec2f *TextureDescBase::getSFScale(void) const
{
    return &_sfScale;
}


SFVec2f *TextureDescBase::editSFTranslate(void)
{
    editSField(TranslateFieldMask);

    return &_sfTranslate;
}

const SFVec2f *TextureDescBase::getSFTranslate(void) const
{
    return &_sfTranslate;
}


SFReal32 *TextureDescBase::editSFRotate(void)
{
    editSField(RotateFieldMask);

    return &_sfRotate;
}

const SFReal32 *TextureDescBase::getSFRotate(void) const
{
    return &_sfRotate;
}


SFBool *TextureDescBase::editSFHasUVTransform(void)
{
    editSField(HasUVTransformFieldMask);

    return &_sfHasUVTransform;
}

const SFBool *TextureDescBase::getSFHasUVTransform(void) const
{
    return &_sfHasUVTransform;
}


SFColor4f *TextureDescBase::editSFBorderColor(void)
{
    editSField(BorderColorFieldMask);

    return &_sfBorderColor;
}

const SFColor4f *TextureDescBase::getSFBorderColor(void) const
{
    return &_sfBorderColor;
}


//! Get the TextureDesc::_mfTexImage field.
const MFUnrecImagePtr *TextureDescBase::getMFTexImage(void) const
{
    return &_mfTexImage;
}

MFUnrecImagePtr     *TextureDescBase::editMFTexImage       (void)
{
    editMField(TexImageFieldMask, _mfTexImage);

    return &_mfTexImage;
}
Image * TextureDescBase::getTexImage(const UInt32 index) const
{
    return _mfTexImage[index];
}

//! Get the TextureDesc::_sfImageMap field.
const SFUnrecHashKeyToFieldContainerMapPtr *TextureDescBase::getSFImageMap(void) const
{
    return &_sfImageMap;
}

SFUnrecHashKeyToFieldContainerMapPtr *TextureDescBase::editSFImageMap       (void)
{
    editSField(ImageMapFieldMask);

    return &_sfImageMap;
}

//! Get the value of the TextureDesc::_sfImageMap field.
HashKeyToFieldContainerMap * TextureDescBase::getImageMap(void) const
{
    return _sfImageMap.getValue();
}

//! Set the value of the TextureDesc::_sfImageMap field.
void TextureDescBase::setImageMap(HashKeyToFieldContainerMap * const value)
{
    editSField(ImageMapFieldMask);

    _sfImageMap.setValue(value);
}




void TextureDescBase::pushToTexImage(Image * const value)
{
    editMField(TexImageFieldMask, _mfTexImage);

    _mfTexImage.push_back(value);
}

void TextureDescBase::assignTexImage (const MFUnrecImagePtr   &value)
{
    MFUnrecImagePtr  ::const_iterator elemIt  =
        value.begin();
    MFUnrecImagePtr  ::const_iterator elemEnd =
        value.end  ();

    static_cast<TextureDesc *>(this)->clearTexImage();

    while(elemIt != elemEnd)
    {
        this->pushToTexImage(*elemIt);

        ++elemIt;
    }
}

void TextureDescBase::removeFromTexImage(UInt32 uiIndex)
{
    if(uiIndex < _mfTexImage.size())
    {
        editMField(TexImageFieldMask, _mfTexImage);

        _mfTexImage.erase(uiIndex);
    }
}

void TextureDescBase::removeObjFromTexImage(Image * const value)
{
    Int32 iElemIdx = _mfTexImage.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TexImageFieldMask, _mfTexImage);

        _mfTexImage.erase(iElemIdx);
    }
}
void TextureDescBase::clearTexImage(void)
{
    editMField(TexImageFieldMask, _mfTexImage);


    _mfTexImage.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT TextureDescBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (TextureTypeFieldMask & whichField))
    {
        returnValue += _sfTextureType.getBinSize();
    }
    if(FieldBits::NoField != (SwizzleFieldMask & whichField))
    {
        returnValue += _sfSwizzle.getBinSize();
    }
    if(FieldBits::NoField != (IsSRGBTextureFieldMask & whichField))
    {
        returnValue += _sfIsSRGBTexture.getBinSize();
    }
    if(FieldBits::NoField != (FilenameFieldMask & whichField))
    {
        returnValue += _mfFilename.getBinSize();
    }
    if(FieldBits::NoField != (TexUnitFieldMask & whichField))
    {
        returnValue += _sfTexUnit.getBinSize();
    }
    if(FieldBits::NoField != (UVChannelFieldMask & whichField))
    {
        returnValue += _sfUVChannel.getBinSize();
    }
    if(FieldBits::NoField != (MappingModeFieldMask & whichField))
    {
        returnValue += _sfMappingMode.getBinSize();
    }
    if(FieldBits::NoField != (MapAxisFieldMask & whichField))
    {
        returnValue += _sfMapAxis.getBinSize();
    }
    if(FieldBits::NoField != (EnvironmentMapTypeFieldMask & whichField))
    {
        returnValue += _sfEnvironmentMapType.getBinSize();
    }
    if(FieldBits::NoField != (BlendFactorFieldMask & whichField))
    {
        returnValue += _sfBlendFactor.getBinSize();
    }
    if(FieldBits::NoField != (OperationFieldMask & whichField))
    {
        returnValue += _sfOperation.getBinSize();
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }
    if(FieldBits::NoField != (TextureFlagsFieldMask & whichField))
    {
        returnValue += _sfTextureFlags.getBinSize();
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        returnValue += _sfInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        returnValue += _sfExternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        returnValue += _sfAnisotropy.getBinSize();
    }
    if(FieldBits::NoField != (MirrorFlagsFieldMask & whichField))
    {
        returnValue += _sfMirrorFlags.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (TranslateFieldMask & whichField))
    {
        returnValue += _sfTranslate.getBinSize();
    }
    if(FieldBits::NoField != (RotateFieldMask & whichField))
    {
        returnValue += _sfRotate.getBinSize();
    }
    if(FieldBits::NoField != (HasUVTransformFieldMask & whichField))
    {
        returnValue += _sfHasUVTransform.getBinSize();
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        returnValue += _sfBorderColor.getBinSize();
    }
    if(FieldBits::NoField != (TexImageFieldMask & whichField))
    {
        returnValue += _mfTexImage.getBinSize();
    }
    if(FieldBits::NoField != (ImageMapFieldMask & whichField))
    {
        returnValue += _sfImageMap.getBinSize();
    }

    return returnValue;
}

void TextureDescBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (TextureTypeFieldMask & whichField))
    {
        _sfTextureType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SwizzleFieldMask & whichField))
    {
        _sfSwizzle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IsSRGBTextureFieldMask & whichField))
    {
        _sfIsSRGBTexture.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilenameFieldMask & whichField))
    {
        _mfFilename.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TexUnitFieldMask & whichField))
    {
        _sfTexUnit.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UVChannelFieldMask & whichField))
    {
        _sfUVChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MappingModeFieldMask & whichField))
    {
        _sfMappingMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MapAxisFieldMask & whichField))
    {
        _sfMapAxis.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvironmentMapTypeFieldMask & whichField))
    {
        _sfEnvironmentMapType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BlendFactorFieldMask & whichField))
    {
        _sfBlendFactor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OperationFieldMask & whichField))
    {
        _sfOperation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureFlagsFieldMask & whichField))
    {
        _sfTextureFlags.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MirrorFlagsFieldMask & whichField))
    {
        _sfMirrorFlags.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TranslateFieldMask & whichField))
    {
        _sfTranslate.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RotateFieldMask & whichField))
    {
        _sfRotate.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HasUVTransformFieldMask & whichField))
    {
        _sfHasUVTransform.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TexImageFieldMask & whichField))
    {
        _mfTexImage.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ImageMapFieldMask & whichField))
    {
        _sfImageMap.copyToBin(pMem);
    }
}

void TextureDescBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (TextureTypeFieldMask & whichField))
    {
        editSField(TextureTypeFieldMask);
        _sfTextureType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SwizzleFieldMask & whichField))
    {
        editSField(SwizzleFieldMask);
        _sfSwizzle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IsSRGBTextureFieldMask & whichField))
    {
        editSField(IsSRGBTextureFieldMask);
        _sfIsSRGBTexture.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilenameFieldMask & whichField))
    {
        editMField(FilenameFieldMask, _mfFilename);
        _mfFilename.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TexUnitFieldMask & whichField))
    {
        editSField(TexUnitFieldMask);
        _sfTexUnit.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UVChannelFieldMask & whichField))
    {
        editSField(UVChannelFieldMask);
        _sfUVChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MappingModeFieldMask & whichField))
    {
        editSField(MappingModeFieldMask);
        _sfMappingMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MapAxisFieldMask & whichField))
    {
        editSField(MapAxisFieldMask);
        _sfMapAxis.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvironmentMapTypeFieldMask & whichField))
    {
        editSField(EnvironmentMapTypeFieldMask);
        _sfEnvironmentMapType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BlendFactorFieldMask & whichField))
    {
        editSField(BlendFactorFieldMask);
        _sfBlendFactor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OperationFieldMask & whichField))
    {
        editSField(OperationFieldMask);
        _sfOperation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        editSField(WrapSFieldMask);
        _sfWrapS.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        editSField(WrapTFieldMask);
        _sfWrapT.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        editSField(WrapRFieldMask);
        _sfWrapR.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureFlagsFieldMask & whichField))
    {
        editSField(TextureFlagsFieldMask);
        _sfTextureFlags.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        editSField(MinFilterFieldMask);
        _sfMinFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        editSField(MagFilterFieldMask);
        _sfMagFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        editSField(InternalFormatFieldMask);
        _sfInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        editSField(ExternalFormatFieldMask);
        _sfExternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        editSField(AnisotropyFieldMask);
        _sfAnisotropy.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MirrorFlagsFieldMask & whichField))
    {
        editSField(MirrorFlagsFieldMask);
        _sfMirrorFlags.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        editSField(ScaleFieldMask);
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TranslateFieldMask & whichField))
    {
        editSField(TranslateFieldMask);
        _sfTranslate.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RotateFieldMask & whichField))
    {
        editSField(RotateFieldMask);
        _sfRotate.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HasUVTransformFieldMask & whichField))
    {
        editSField(HasUVTransformFieldMask);
        _sfHasUVTransform.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        editSField(BorderColorFieldMask);
        _sfBorderColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TexImageFieldMask & whichField))
    {
        editMField(TexImageFieldMask, _mfTexImage);
        _mfTexImage.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ImageMapFieldMask & whichField))
    {
        editSField(ImageMapFieldMask);
        _sfImageMap.copyFromBin(pMem);
    }
}

//! create a new instance of the class
TextureDescTransitPtr TextureDescBase::createLocal(BitVector bFlags)
{
    TextureDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<TextureDesc>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
TextureDescTransitPtr TextureDescBase::createDependent(BitVector bFlags)
{
    TextureDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<TextureDesc>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
TextureDescTransitPtr TextureDescBase::create(void)
{
    TextureDescTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<TextureDesc>(tmpPtr);
    }

    return fc;
}

TextureDesc *TextureDescBase::createEmptyLocal(BitVector bFlags)
{
    TextureDesc *returnValue;

    newPtr<TextureDesc>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
TextureDesc *TextureDescBase::createEmpty(void)
{
    TextureDesc *returnValue;

    newPtr<TextureDesc>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr TextureDescBase::shallowCopyLocal(
    BitVector bFlags) const
{
    TextureDesc *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const TextureDesc *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr TextureDescBase::shallowCopyDependent(
    BitVector bFlags) const
{
    TextureDesc *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const TextureDesc *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr TextureDescBase::shallowCopy(void) const
{
    TextureDesc *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const TextureDesc *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

TextureDescBase::TextureDescBase(void) :
    Inherited(),
    _sfTextureType            (UInt32(0)),
    _sfSwizzle                (std::string("rgba")),
    _sfIsSRGBTexture          (bool(true)),
    _mfFilename               (),
    _sfTexUnit                (Int32(-1)),
    _sfUVChannel              (UInt32(0)),
    _sfMappingMode            (UInt32(0)),
    _sfMapAxis                (Vec3f(Vec3f(0.f,0.f,0.f))),
    _sfEnvironmentMapType     (UInt32(0)),
    _sfBlendFactor            (Real32(0.f)),
    _sfOperation              (UInt32(0)),
    _sfWrapS                  (GLenum(GL_REPEAT)),
    _sfWrapT                  (GLenum(GL_REPEAT)),
    _sfWrapR                  (GLenum(GL_REPEAT)),
    _sfTextureFlags           (UInt32(0)),
    _sfMinFilter              (GLenum(GL_LINEAR_MIPMAP_LINEAR)),
    _sfMagFilter              (GLenum(GL_LINEAR)),
    _sfInternalFormat         (GLenum(GL_NONE)),
    _sfExternalFormat         (GLenum(GL_NONE)),
    _sfAnisotropy             (Real32(1.0f)),
    _sfMirrorFlags            (UInt32(0)),
    _sfScale                  (Vec2f(Vec2f(1.f,1.f))),
    _sfTranslate              (Vec2f(Vec2f(0.f,0.f))),
    _sfRotate                 (Real32(0.f)),
    _sfHasUVTransform         (bool(false)),
    _sfBorderColor            (Color4f(0,0,0,0)),
    _mfTexImage               (),
    _sfImageMap               (NULL)
{
}

TextureDescBase::TextureDescBase(const TextureDescBase &source) :
    Inherited(source),
    _sfTextureType            (source._sfTextureType            ),
    _sfSwizzle                (source._sfSwizzle                ),
    _sfIsSRGBTexture          (source._sfIsSRGBTexture          ),
    _mfFilename               (source._mfFilename               ),
    _sfTexUnit                (source._sfTexUnit                ),
    _sfUVChannel              (source._sfUVChannel              ),
    _sfMappingMode            (source._sfMappingMode            ),
    _sfMapAxis                (source._sfMapAxis                ),
    _sfEnvironmentMapType     (source._sfEnvironmentMapType     ),
    _sfBlendFactor            (source._sfBlendFactor            ),
    _sfOperation              (source._sfOperation              ),
    _sfWrapS                  (source._sfWrapS                  ),
    _sfWrapT                  (source._sfWrapT                  ),
    _sfWrapR                  (source._sfWrapR                  ),
    _sfTextureFlags           (source._sfTextureFlags           ),
    _sfMinFilter              (source._sfMinFilter              ),
    _sfMagFilter              (source._sfMagFilter              ),
    _sfInternalFormat         (source._sfInternalFormat         ),
    _sfExternalFormat         (source._sfExternalFormat         ),
    _sfAnisotropy             (source._sfAnisotropy             ),
    _sfMirrorFlags            (source._sfMirrorFlags            ),
    _sfScale                  (source._sfScale                  ),
    _sfTranslate              (source._sfTranslate              ),
    _sfRotate                 (source._sfRotate                 ),
    _sfHasUVTransform         (source._sfHasUVTransform         ),
    _sfBorderColor            (source._sfBorderColor            ),
    _mfTexImage               (),
    _sfImageMap               (NULL)
{
}


/*-------------------------- destructors ----------------------------------*/

TextureDescBase::~TextureDescBase(void)
{
}

void TextureDescBase::onCreate(const TextureDesc *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        TextureDesc *pThis = static_cast<TextureDesc *>(this);

        MFUnrecImagePtr::const_iterator TexImageIt  =
            source->_mfTexImage.begin();
        MFUnrecImagePtr::const_iterator TexImageEnd =
            source->_mfTexImage.end  ();

        while(TexImageIt != TexImageEnd)
        {
            pThis->pushToTexImage(*TexImageIt);

            ++TexImageIt;
        }

        pThis->setImageMap(source->getImageMap());
    }
}

GetFieldHandlePtr TextureDescBase::getHandleTextureType     (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfTextureType,
             this->getType().getFieldDesc(TextureTypeFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleTextureType    (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfTextureType,
             this->getType().getFieldDesc(TextureTypeFieldId),
             this));


    editSField(TextureTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleSwizzle         (void) const
{
    SFString::GetHandlePtr returnValue(
        new  SFString::GetHandle(
             &_sfSwizzle,
             this->getType().getFieldDesc(SwizzleFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleSwizzle        (void)
{
    SFString::EditHandlePtr returnValue(
        new  SFString::EditHandle(
             &_sfSwizzle,
             this->getType().getFieldDesc(SwizzleFieldId),
             this));


    editSField(SwizzleFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleIsSRGBTexture   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfIsSRGBTexture,
             this->getType().getFieldDesc(IsSRGBTextureFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleIsSRGBTexture  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfIsSRGBTexture,
             this->getType().getFieldDesc(IsSRGBTextureFieldId),
             this));


    editSField(IsSRGBTextureFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleFilename        (void) const
{
    MFString::GetHandlePtr returnValue(
        new  MFString::GetHandle(
             &_mfFilename,
             this->getType().getFieldDesc(FilenameFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleFilename       (void)
{
    MFString::EditHandlePtr returnValue(
        new  MFString::EditHandle(
             &_mfFilename,
             this->getType().getFieldDesc(FilenameFieldId),
             this));


    editMField(FilenameFieldMask, _mfFilename);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleTexUnit         (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfTexUnit,
             this->getType().getFieldDesc(TexUnitFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleTexUnit        (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfTexUnit,
             this->getType().getFieldDesc(TexUnitFieldId),
             this));


    editSField(TexUnitFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleUVChannel       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfUVChannel,
             this->getType().getFieldDesc(UVChannelFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleUVChannel      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfUVChannel,
             this->getType().getFieldDesc(UVChannelFieldId),
             this));


    editSField(UVChannelFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleMappingMode     (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfMappingMode,
             this->getType().getFieldDesc(MappingModeFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleMappingMode    (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfMappingMode,
             this->getType().getFieldDesc(MappingModeFieldId),
             this));


    editSField(MappingModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleMapAxis         (void) const
{
    SFVec3f::GetHandlePtr returnValue(
        new  SFVec3f::GetHandle(
             &_sfMapAxis,
             this->getType().getFieldDesc(MapAxisFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleMapAxis        (void)
{
    SFVec3f::EditHandlePtr returnValue(
        new  SFVec3f::EditHandle(
             &_sfMapAxis,
             this->getType().getFieldDesc(MapAxisFieldId),
             this));


    editSField(MapAxisFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleEnvironmentMapType (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfEnvironmentMapType,
             this->getType().getFieldDesc(EnvironmentMapTypeFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleEnvironmentMapType(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfEnvironmentMapType,
             this->getType().getFieldDesc(EnvironmentMapTypeFieldId),
             this));


    editSField(EnvironmentMapTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleBlendFactor     (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBlendFactor,
             this->getType().getFieldDesc(BlendFactorFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleBlendFactor    (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBlendFactor,
             this->getType().getFieldDesc(BlendFactorFieldId),
             this));


    editSField(BlendFactorFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleOperation       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfOperation,
             this->getType().getFieldDesc(OperationFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleOperation      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfOperation,
             this->getType().getFieldDesc(OperationFieldId),
             this));


    editSField(OperationFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleWrapS           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapS,
             this->getType().getFieldDesc(WrapSFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleWrapS          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapS,
             this->getType().getFieldDesc(WrapSFieldId),
             this));


    editSField(WrapSFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleWrapT           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapT,
             this->getType().getFieldDesc(WrapTFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleWrapT          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapT,
             this->getType().getFieldDesc(WrapTFieldId),
             this));


    editSField(WrapTFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleWrapR           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapR,
             this->getType().getFieldDesc(WrapRFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleWrapR          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapR,
             this->getType().getFieldDesc(WrapRFieldId),
             this));


    editSField(WrapRFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleTextureFlags    (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfTextureFlags,
             this->getType().getFieldDesc(TextureFlagsFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleTextureFlags   (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfTextureFlags,
             this->getType().getFieldDesc(TextureFlagsFieldId),
             this));


    editSField(TextureFlagsFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleMinFilter       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfMinFilter,
             this->getType().getFieldDesc(MinFilterFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleMinFilter      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfMinFilter,
             this->getType().getFieldDesc(MinFilterFieldId),
             this));


    editSField(MinFilterFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleMagFilter       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfMagFilter,
             this->getType().getFieldDesc(MagFilterFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleMagFilter      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfMagFilter,
             this->getType().getFieldDesc(MagFilterFieldId),
             this));


    editSField(MagFilterFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleInternalFormat  (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfInternalFormat,
             this->getType().getFieldDesc(InternalFormatFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleInternalFormat (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfInternalFormat,
             this->getType().getFieldDesc(InternalFormatFieldId),
             this));


    editSField(InternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleExternalFormat  (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfExternalFormat,
             this->getType().getFieldDesc(ExternalFormatFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleExternalFormat (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfExternalFormat,
             this->getType().getFieldDesc(ExternalFormatFieldId),
             this));


    editSField(ExternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleAnisotropy      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfAnisotropy,
             this->getType().getFieldDesc(AnisotropyFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleAnisotropy     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfAnisotropy,
             this->getType().getFieldDesc(AnisotropyFieldId),
             this));


    editSField(AnisotropyFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleMirrorFlags     (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfMirrorFlags,
             this->getType().getFieldDesc(MirrorFlagsFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleMirrorFlags    (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfMirrorFlags,
             this->getType().getFieldDesc(MirrorFlagsFieldId),
             this));


    editSField(MirrorFlagsFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleScale           (void) const
{
    SFVec2f::GetHandlePtr returnValue(
        new  SFVec2f::GetHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleScale          (void)
{
    SFVec2f::EditHandlePtr returnValue(
        new  SFVec2f::EditHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             this));


    editSField(ScaleFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleTranslate       (void) const
{
    SFVec2f::GetHandlePtr returnValue(
        new  SFVec2f::GetHandle(
             &_sfTranslate,
             this->getType().getFieldDesc(TranslateFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleTranslate      (void)
{
    SFVec2f::EditHandlePtr returnValue(
        new  SFVec2f::EditHandle(
             &_sfTranslate,
             this->getType().getFieldDesc(TranslateFieldId),
             this));


    editSField(TranslateFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleRotate          (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfRotate,
             this->getType().getFieldDesc(RotateFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleRotate         (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfRotate,
             this->getType().getFieldDesc(RotateFieldId),
             this));


    editSField(RotateFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleHasUVTransform  (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfHasUVTransform,
             this->getType().getFieldDesc(HasUVTransformFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleHasUVTransform (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfHasUVTransform,
             this->getType().getFieldDesc(HasUVTransformFieldId),
             this));


    editSField(HasUVTransformFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleBorderColor     (void) const
{
    SFColor4f::GetHandlePtr returnValue(
        new  SFColor4f::GetHandle(
             &_sfBorderColor,
             this->getType().getFieldDesc(BorderColorFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleBorderColor    (void)
{
    SFColor4f::EditHandlePtr returnValue(
        new  SFColor4f::EditHandle(
             &_sfBorderColor,
             this->getType().getFieldDesc(BorderColorFieldId),
             this));


    editSField(BorderColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleTexImage        (void) const
{
    MFUnrecImagePtr::GetHandlePtr returnValue(
        new  MFUnrecImagePtr::GetHandle(
             &_mfTexImage,
             this->getType().getFieldDesc(TexImageFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleTexImage       (void)
{
    MFUnrecImagePtr::EditHandlePtr returnValue(
        new  MFUnrecImagePtr::EditHandle(
             &_mfTexImage,
             this->getType().getFieldDesc(TexImageFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&TextureDesc::pushToTexImage,
                    static_cast<TextureDesc *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&TextureDesc::removeFromTexImage,
                    static_cast<TextureDesc *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&TextureDesc::removeObjFromTexImage,
                    static_cast<TextureDesc *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&TextureDesc::clearTexImage,
                    static_cast<TextureDesc *>(this)));

    editMField(TexImageFieldMask, _mfTexImage);

    return returnValue;
}

GetFieldHandlePtr TextureDescBase::getHandleImageMap        (void) const
{
    SFUnrecHashKeyToFieldContainerMapPtr::GetHandlePtr returnValue(
        new  SFUnrecHashKeyToFieldContainerMapPtr::GetHandle(
             &_sfImageMap,
             this->getType().getFieldDesc(ImageMapFieldId),
             const_cast<TextureDescBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureDescBase::editHandleImageMap       (void)
{
    SFUnrecHashKeyToFieldContainerMapPtr::EditHandlePtr returnValue(
        new  SFUnrecHashKeyToFieldContainerMapPtr::EditHandle(
             &_sfImageMap,
             this->getType().getFieldDesc(ImageMapFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&TextureDesc::setImageMap,
                    static_cast<TextureDesc *>(this), _1));

    editSField(ImageMapFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void TextureDescBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    TextureDesc *pThis = static_cast<TextureDesc *>(this);

    pThis->execSync(static_cast<TextureDesc *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *TextureDescBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    TextureDesc *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const TextureDesc *>(pRefAspect),
                  dynamic_cast<const TextureDesc *>(this));

    return returnValue;
}
#endif

void TextureDescBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<TextureDesc *>(this)->clearTexImage();

    static_cast<TextureDesc *>(this)->setImageMap(NULL);

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfFilename.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
