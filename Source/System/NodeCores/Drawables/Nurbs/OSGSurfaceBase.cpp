/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Surface!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"



#include "OSGGeoVectorProperty.h"       // ControlPoints Class

#include "OSGSurfaceBase.h"
#include "OSGSurface.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Surface
    This is the OpenSG NURBS surface node. It supports an arbitrary number of
    trimming curves. The interface lets you define both rational and nonrational
    surfaces, and you can also vary rational and nonrational trimming curves.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var UInt32          SurfaceBase::_sfDimU
    The surface dimension in U
*/

/*! \var UInt32          SurfaceBase::_sfDimV
    The surface dimension in V
*/

/*! \var Real32          SurfaceBase::_mfKnotsU
    The surface knots in U direction
*/

/*! \var Real32          SurfaceBase::_mfKnotsV
    The surface knots in V direction
*/

/*! \var GeoVectorProperty * SurfaceBase::_sfControlPoints
    The control points for the surface
*/

/*! \var Real32          SurfaceBase::_sfError
    The approximation error for the tessellation
*/

/*! \var UInt32          SurfaceBase::_sfNumCurves
    The number of trimming curves
*/

/*! \var UInt32          SurfaceBase::_mfKnotLengths
    The knotlengths for the trimming curves
*/

/*! \var UInt32          SurfaceBase::_mfDimensions
    The dimensions for the trimming curves
*/

/*! \var Pnt3f           SurfaceBase::_mfCurveControlPoints
    The control points for the trimming curves
*/

/*! \var Real32          SurfaceBase::_mfKnots
    The knotvectors for the trimming curves
*/

/*! \var UInt32          SurfaceBase::_mfCurvesPerLoop
    Specifies the number of trimming curves in each trimming curve loop
*/

/*! \var bool            SurfaceBase::_sfIsDelaunay
    Whether to use Delaunay triangulation. Default is no, because it's faster
    and slightly more robust numerically, but produces a somewhat less "nice"
    triangulation. Set to true, if you want Delaunay triangulation. The number
    of triangles generated is the same in both modes.
*/

/*! \var GeoVectorProperty * SurfaceBase::_sfTextureControlPoints
    The control points for textures (always 2D)
*/

/*! \var UInt32          SurfaceBase::_sfDirtyMask
    
*/

/*! \var Int32           SurfaceBase::_sfSurfaceGLId
    Surface GL Id, internal use.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<Surface *, nsOSG>::_type(
    "SurfacePtr", 
    "GeometryPtr", 
    Surface::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(Surface *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Surface *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Surface *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void SurfaceBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "dimU",
        "The surface dimension in U\n",
        DimUFieldId, DimUFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleDimU),
        static_cast<FieldGetMethodSig >(&Surface::getHandleDimU));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "dimV",
        "The surface dimension in V\n",
        DimVFieldId, DimVFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleDimV),
        static_cast<FieldGetMethodSig >(&Surface::getHandleDimV));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "knotsU",
        "The surface knots in U direction\n",
        KnotsUFieldId, KnotsUFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleKnotsU),
        static_cast<FieldGetMethodSig >(&Surface::getHandleKnotsU));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "knotsV",
        "The surface knots in V direction\n",
        KnotsVFieldId, KnotsVFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleKnotsV),
        static_cast<FieldGetMethodSig >(&Surface::getHandleKnotsV));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoVectorPropertyPtr::Description(
        SFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "controlPoints",
        "The control points for the surface\n",
        ControlPointsFieldId, ControlPointsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleControlPoints),
        static_cast<FieldGetMethodSig >(&Surface::getHandleControlPoints));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "error",
        "The approximation error for the tessellation\n",
        ErrorFieldId, ErrorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleError),
        static_cast<FieldGetMethodSig >(&Surface::getHandleError));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "numCurves",
        "The number of trimming curves\n",
        NumCurvesFieldId, NumCurvesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleNumCurves),
        static_cast<FieldGetMethodSig >(&Surface::getHandleNumCurves));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt32::Description(
        MFUInt32::getClassType(),
        "knotLengths",
        "The knotlengths for the trimming curves\n",
        KnotLengthsFieldId, KnotLengthsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleKnotLengths),
        static_cast<FieldGetMethodSig >(&Surface::getHandleKnotLengths));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt32::Description(
        MFUInt32::getClassType(),
        "dimensions",
        "The dimensions for the trimming curves\n",
        DimensionsFieldId, DimensionsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleDimensions),
        static_cast<FieldGetMethodSig >(&Surface::getHandleDimensions));

    oType.addInitialDesc(pDesc);

    pDesc = new MFPnt3f::Description(
        MFPnt3f::getClassType(),
        "curveControlPoints",
        "The control points for the trimming curves\n",
        CurveControlPointsFieldId, CurveControlPointsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleCurveControlPoints),
        static_cast<FieldGetMethodSig >(&Surface::getHandleCurveControlPoints));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "knots",
        "The knotvectors for the trimming curves\n",
        KnotsFieldId, KnotsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleKnots),
        static_cast<FieldGetMethodSig >(&Surface::getHandleKnots));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUInt32::Description(
        MFUInt32::getClassType(),
        "curvesPerLoop",
        "Specifies the number of trimming curves in each trimming curve loop\n",
        CurvesPerLoopFieldId, CurvesPerLoopFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleCurvesPerLoop),
        static_cast<FieldGetMethodSig >(&Surface::getHandleCurvesPerLoop));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "isDelaunay",
        "Whether to use Delaunay triangulation. Default is no, because it's faster\n"
        "and slightly more robust numerically, but produces a somewhat less \"nice\"\n"
        "triangulation. Set to true, if you want Delaunay triangulation. The number\n"
        "of triangles generated is the same in both modes.\n",
        IsDelaunayFieldId, IsDelaunayFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleIsDelaunay),
        static_cast<FieldGetMethodSig >(&Surface::getHandleIsDelaunay));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoVectorPropertyPtr::Description(
        SFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "textureControlPoints",
        "The control points for textures (always 2D)\n",
        TextureControlPointsFieldId, TextureControlPointsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleTextureControlPoints),
        static_cast<FieldGetMethodSig >(&Surface::getHandleTextureControlPoints));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "dirtyMask",
        "",
        DirtyMaskFieldId, DirtyMaskFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Surface::editHandleDirtyMask),
        static_cast<FieldGetMethodSig >(&Surface::getHandleDirtyMask));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "surfaceGLId",
        "Surface GL Id, internal use.\n",
        SurfaceGLIdFieldId, SurfaceGLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&Surface::editHandleSurfaceGLId),
        static_cast<FieldGetMethodSig >(&Surface::getHandleSurfaceGLId));

    oType.addInitialDesc(pDesc);
}


SurfaceBase::TypeObject SurfaceBase::_type(
    SurfaceBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&SurfaceBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&Surface::initMethod),
    reinterpret_cast<ExitContainerF>(&Surface::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&Surface::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"Surface\"\n"
    "    parent=\"Geometry\"\n"
    "    library=\"Drawable\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    isNodeCore=\"true\"\n"
    "    docGroupBase=\"GrpDrawablesNurbs\"\n"
    "    >\n"
    "    This is the OpenSG NURBS surface node. It supports an arbitrary number of\n"
    "    trimming curves. The interface lets you define both rational and nonrational\n"
    "    surfaces, and you can also vary rational and nonrational trimming curves.\n"
    "    <Field\n"
    "        name=\"dimU\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The surface dimension in U\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dimV\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The surface dimension in V\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"knotsU\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The surface knots in U direction\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"knotsV\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The surface knots in V direction\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"controlPoints\"\n"
    "        type=\"GeoVectorProperty\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "        >\n"
    "        The control points for the surface\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"error\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.5\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The approximation error for the tessellation\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"numCurves\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        The number of trimming curves\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"knotLengths\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        The knotlengths for the trimming curves\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dimensions\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        The dimensions for the trimming curves\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"curveControlPoints\"\n"
    "        type=\"Pnt3f\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        The control points for the trimming curves\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"knots\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        The knotvectors for the trimming curves\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"curvesPerLoop\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        Specifies the number of trimming curves in each trimming curve loop\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"isDelaunay\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Whether to use Delaunay triangulation. Default is no, because it's faster\n"
    "        and slightly more robust numerically, but produces a somewhat less \"nice\"\n"
    "        triangulation. Set to true, if you want Delaunay triangulation. The number\n"
    "        of triangles generated is the same in both modes.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"textureControlPoints\"\n"
    "        type=\"GeoVectorProperty\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        access=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "        >\n"
    "        The control points for textures (always 2D)\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMask\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"surfaceGLId\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"internal\"\n"
    "        defaultValue=\"0\"\n"
    "        access=\"protected\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "        >\n"
    "        Surface GL Id, internal use.\n"
    "    </Field>\n"
    "</FieldContainer>\n",
    "This is the OpenSG NURBS surface node. It supports an arbitrary number of\n"
    "trimming curves. The interface lets you define both rational and nonrational\n"
    "surfaces, and you can also vary rational and nonrational trimming curves.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &SurfaceBase::getType(void)
{
    return _type;
}

const FieldContainerType &SurfaceBase::getType(void) const
{
    return _type;
}

UInt32 SurfaceBase::getContainerSize(void) const
{
    return sizeof(Surface);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *SurfaceBase::editSFDimU(void)
{
    editSField(DimUFieldMask);

    return &_sfDimU;
}

const SFUInt32 *SurfaceBase::getSFDimU(void) const
{
    return &_sfDimU;
}


SFUInt32 *SurfaceBase::editSFDimV(void)
{
    editSField(DimVFieldMask);

    return &_sfDimV;
}

const SFUInt32 *SurfaceBase::getSFDimV(void) const
{
    return &_sfDimV;
}


MFReal32 *SurfaceBase::editMFKnotsU(void)
{
    editMField(KnotsUFieldMask, _mfKnotsU);

    return &_mfKnotsU;
}

const MFReal32 *SurfaceBase::getMFKnotsU(void) const
{
    return &_mfKnotsU;
}


MFReal32 *SurfaceBase::editMFKnotsV(void)
{
    editMField(KnotsVFieldMask, _mfKnotsV);

    return &_mfKnotsV;
}

const MFReal32 *SurfaceBase::getMFKnotsV(void) const
{
    return &_mfKnotsV;
}


//! Get the Surface::_sfControlPoints field.
const SFUnrecChildGeoVectorPropertyPtr *SurfaceBase::getSFControlPoints(void) const
{
    return &_sfControlPoints;
}

SFUnrecChildGeoVectorPropertyPtr *SurfaceBase::editSFControlPoints  (void)
{
    editSField(ControlPointsFieldMask);

    return &_sfControlPoints;
}

//! Get the value of the Surface::_sfControlPoints field.
GeoVectorProperty * SurfaceBase::getControlPoints(void) const
{
    return _sfControlPoints.getValue();
}

//! Set the value of the Surface::_sfControlPoints field.
void SurfaceBase::setControlPoints(GeoVectorProperty * const value)
{
    editSField(ControlPointsFieldMask);

    _sfControlPoints.setValue(value);
}


SFReal32 *SurfaceBase::editSFError(void)
{
    editSField(ErrorFieldMask);

    return &_sfError;
}

const SFReal32 *SurfaceBase::getSFError(void) const
{
    return &_sfError;
}


SFUInt32 *SurfaceBase::editSFNumCurves(void)
{
    editSField(NumCurvesFieldMask);

    return &_sfNumCurves;
}

const SFUInt32 *SurfaceBase::getSFNumCurves(void) const
{
    return &_sfNumCurves;
}


MFUInt32 *SurfaceBase::editMFKnotLengths(void)
{
    editMField(KnotLengthsFieldMask, _mfKnotLengths);

    return &_mfKnotLengths;
}

const MFUInt32 *SurfaceBase::getMFKnotLengths(void) const
{
    return &_mfKnotLengths;
}


MFUInt32 *SurfaceBase::editMFDimensions(void)
{
    editMField(DimensionsFieldMask, _mfDimensions);

    return &_mfDimensions;
}

const MFUInt32 *SurfaceBase::getMFDimensions(void) const
{
    return &_mfDimensions;
}


MFPnt3f *SurfaceBase::editMFCurveControlPoints(void)
{
    editMField(CurveControlPointsFieldMask, _mfCurveControlPoints);

    return &_mfCurveControlPoints;
}

const MFPnt3f *SurfaceBase::getMFCurveControlPoints(void) const
{
    return &_mfCurveControlPoints;
}


MFReal32 *SurfaceBase::editMFKnots(void)
{
    editMField(KnotsFieldMask, _mfKnots);

    return &_mfKnots;
}

const MFReal32 *SurfaceBase::getMFKnots(void) const
{
    return &_mfKnots;
}


MFUInt32 *SurfaceBase::editMFCurvesPerLoop(void)
{
    editMField(CurvesPerLoopFieldMask, _mfCurvesPerLoop);

    return &_mfCurvesPerLoop;
}

const MFUInt32 *SurfaceBase::getMFCurvesPerLoop(void) const
{
    return &_mfCurvesPerLoop;
}


SFBool *SurfaceBase::editSFIsDelaunay(void)
{
    editSField(IsDelaunayFieldMask);

    return &_sfIsDelaunay;
}

const SFBool *SurfaceBase::getSFIsDelaunay(void) const
{
    return &_sfIsDelaunay;
}


//! Get the Surface::_sfTextureControlPoints field.
const SFUnrecChildGeoVectorPropertyPtr *SurfaceBase::getSFTextureControlPoints(void) const
{
    return &_sfTextureControlPoints;
}

SFUnrecChildGeoVectorPropertyPtr *SurfaceBase::editSFTextureControlPoints(void)
{
    editSField(TextureControlPointsFieldMask);

    return &_sfTextureControlPoints;
}

//! Get the value of the Surface::_sfTextureControlPoints field.
GeoVectorProperty * SurfaceBase::getTextureControlPoints(void) const
{
    return _sfTextureControlPoints.getValue();
}

//! Set the value of the Surface::_sfTextureControlPoints field.
void SurfaceBase::setTextureControlPoints(GeoVectorProperty * const value)
{
    editSField(TextureControlPointsFieldMask);

    _sfTextureControlPoints.setValue(value);
}


SFUInt32 *SurfaceBase::editSFDirtyMask(void)
{
    editSField(DirtyMaskFieldMask);

    return &_sfDirtyMask;
}

const SFUInt32 *SurfaceBase::getSFDirtyMask(void) const
{
    return &_sfDirtyMask;
}


SFInt32 *SurfaceBase::editSFSurfaceGLId(void)
{
    editSField(SurfaceGLIdFieldMask);

    return &_sfSurfaceGLId;
}

const SFInt32 *SurfaceBase::getSFSurfaceGLId(void) const
{
    return &_sfSurfaceGLId;
}






/*------------------------------ access -----------------------------------*/

SizeT SurfaceBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (DimUFieldMask & whichField))
    {
        returnValue += _sfDimU.getBinSize();
    }
    if(FieldBits::NoField != (DimVFieldMask & whichField))
    {
        returnValue += _sfDimV.getBinSize();
    }
    if(FieldBits::NoField != (KnotsUFieldMask & whichField))
    {
        returnValue += _mfKnotsU.getBinSize();
    }
    if(FieldBits::NoField != (KnotsVFieldMask & whichField))
    {
        returnValue += _mfKnotsV.getBinSize();
    }
    if(FieldBits::NoField != (ControlPointsFieldMask & whichField))
    {
        returnValue += _sfControlPoints.getBinSize();
    }
    if(FieldBits::NoField != (ErrorFieldMask & whichField))
    {
        returnValue += _sfError.getBinSize();
    }
    if(FieldBits::NoField != (NumCurvesFieldMask & whichField))
    {
        returnValue += _sfNumCurves.getBinSize();
    }
    if(FieldBits::NoField != (KnotLengthsFieldMask & whichField))
    {
        returnValue += _mfKnotLengths.getBinSize();
    }
    if(FieldBits::NoField != (DimensionsFieldMask & whichField))
    {
        returnValue += _mfDimensions.getBinSize();
    }
    if(FieldBits::NoField != (CurveControlPointsFieldMask & whichField))
    {
        returnValue += _mfCurveControlPoints.getBinSize();
    }
    if(FieldBits::NoField != (KnotsFieldMask & whichField))
    {
        returnValue += _mfKnots.getBinSize();
    }
    if(FieldBits::NoField != (CurvesPerLoopFieldMask & whichField))
    {
        returnValue += _mfCurvesPerLoop.getBinSize();
    }
    if(FieldBits::NoField != (IsDelaunayFieldMask & whichField))
    {
        returnValue += _sfIsDelaunay.getBinSize();
    }
    if(FieldBits::NoField != (TextureControlPointsFieldMask & whichField))
    {
        returnValue += _sfTextureControlPoints.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaskFieldMask & whichField))
    {
        returnValue += _sfDirtyMask.getBinSize();
    }
    if(FieldBits::NoField != (SurfaceGLIdFieldMask & whichField))
    {
        returnValue += _sfSurfaceGLId.getBinSize();
    }

    return returnValue;
}

void SurfaceBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (DimUFieldMask & whichField))
    {
        _sfDimU.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DimVFieldMask & whichField))
    {
        _sfDimV.copyToBin(pMem);
    }
    if(FieldBits::NoField != (KnotsUFieldMask & whichField))
    {
        _mfKnotsU.copyToBin(pMem);
    }
    if(FieldBits::NoField != (KnotsVFieldMask & whichField))
    {
        _mfKnotsV.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ControlPointsFieldMask & whichField))
    {
        _sfControlPoints.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ErrorFieldMask & whichField))
    {
        _sfError.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumCurvesFieldMask & whichField))
    {
        _sfNumCurves.copyToBin(pMem);
    }
    if(FieldBits::NoField != (KnotLengthsFieldMask & whichField))
    {
        _mfKnotLengths.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DimensionsFieldMask & whichField))
    {
        _mfDimensions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CurveControlPointsFieldMask & whichField))
    {
        _mfCurveControlPoints.copyToBin(pMem);
    }
    if(FieldBits::NoField != (KnotsFieldMask & whichField))
    {
        _mfKnots.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CurvesPerLoopFieldMask & whichField))
    {
        _mfCurvesPerLoop.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IsDelaunayFieldMask & whichField))
    {
        _sfIsDelaunay.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureControlPointsFieldMask & whichField))
    {
        _sfTextureControlPoints.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaskFieldMask & whichField))
    {
        _sfDirtyMask.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SurfaceGLIdFieldMask & whichField))
    {
        _sfSurfaceGLId.copyToBin(pMem);
    }
}

void SurfaceBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (DimUFieldMask & whichField))
    {
        editSField(DimUFieldMask);
        _sfDimU.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DimVFieldMask & whichField))
    {
        editSField(DimVFieldMask);
        _sfDimV.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (KnotsUFieldMask & whichField))
    {
        editMField(KnotsUFieldMask, _mfKnotsU);
        _mfKnotsU.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (KnotsVFieldMask & whichField))
    {
        editMField(KnotsVFieldMask, _mfKnotsV);
        _mfKnotsV.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ControlPointsFieldMask & whichField))
    {
        editSField(ControlPointsFieldMask);
        _sfControlPoints.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ErrorFieldMask & whichField))
    {
        editSField(ErrorFieldMask);
        _sfError.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumCurvesFieldMask & whichField))
    {
        editSField(NumCurvesFieldMask);
        _sfNumCurves.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (KnotLengthsFieldMask & whichField))
    {
        editMField(KnotLengthsFieldMask, _mfKnotLengths);
        _mfKnotLengths.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DimensionsFieldMask & whichField))
    {
        editMField(DimensionsFieldMask, _mfDimensions);
        _mfDimensions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CurveControlPointsFieldMask & whichField))
    {
        editMField(CurveControlPointsFieldMask, _mfCurveControlPoints);
        _mfCurveControlPoints.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (KnotsFieldMask & whichField))
    {
        editMField(KnotsFieldMask, _mfKnots);
        _mfKnots.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CurvesPerLoopFieldMask & whichField))
    {
        editMField(CurvesPerLoopFieldMask, _mfCurvesPerLoop);
        _mfCurvesPerLoop.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IsDelaunayFieldMask & whichField))
    {
        editSField(IsDelaunayFieldMask);
        _sfIsDelaunay.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureControlPointsFieldMask & whichField))
    {
        editSField(TextureControlPointsFieldMask);
        _sfTextureControlPoints.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaskFieldMask & whichField))
    {
        editSField(DirtyMaskFieldMask);
        _sfDirtyMask.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SurfaceGLIdFieldMask & whichField))
    {
        editSField(SurfaceGLIdFieldMask);
        _sfSurfaceGLId.copyFromBin(pMem);
    }
}

//! create a new instance of the class
SurfaceTransitPtr SurfaceBase::createLocal(BitVector bFlags)
{
    SurfaceTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Surface>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
SurfaceTransitPtr SurfaceBase::createDependent(BitVector bFlags)
{
    SurfaceTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<Surface>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
SurfaceTransitPtr SurfaceBase::create(void)
{
    SurfaceTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Surface>(tmpPtr);
    }

    return fc;
}

Surface *SurfaceBase::createEmptyLocal(BitVector bFlags)
{
    Surface *returnValue;

    newPtr<Surface>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
Surface *SurfaceBase::createEmpty(void)
{
    Surface *returnValue;

    newPtr<Surface>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr SurfaceBase::shallowCopyLocal(
    BitVector bFlags) const
{
    Surface *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Surface *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr SurfaceBase::shallowCopyDependent(
    BitVector bFlags) const
{
    Surface *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Surface *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr SurfaceBase::shallowCopy(void) const
{
    Surface *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const Surface *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

SurfaceBase::SurfaceBase(void) :
    Inherited(),
    _sfDimU                   (UInt32(0)),
    _sfDimV                   (UInt32(0)),
    _mfKnotsU                 (),
    _mfKnotsV                 (),
    _sfControlPoints          (this,
                          ControlPointsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfError                  (Real32(0.5)),
    _sfNumCurves              (UInt32(0)),
    _mfKnotLengths            (),
    _mfDimensions             (),
    _mfCurveControlPoints     (),
    _mfKnots                  (),
    _mfCurvesPerLoop          (),
    _sfIsDelaunay             (bool(false)),
    _sfTextureControlPoints   (this,
                          TextureControlPointsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfDirtyMask              (UInt32(0)),
    _sfSurfaceGLId            (Int32(0))
{
}

SurfaceBase::SurfaceBase(const SurfaceBase &source) :
    Inherited(source),
    _sfDimU                   (source._sfDimU                   ),
    _sfDimV                   (source._sfDimV                   ),
    _mfKnotsU                 (source._mfKnotsU                 ),
    _mfKnotsV                 (source._mfKnotsV                 ),
    _sfControlPoints          (this,
                          ControlPointsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfError                  (source._sfError                  ),
    _sfNumCurves              (source._sfNumCurves              ),
    _mfKnotLengths            (source._mfKnotLengths            ),
    _mfDimensions             (source._mfDimensions             ),
    _mfCurveControlPoints     (source._mfCurveControlPoints     ),
    _mfKnots                  (source._mfKnots                  ),
    _mfCurvesPerLoop          (source._mfCurvesPerLoop          ),
    _sfIsDelaunay             (source._sfIsDelaunay             ),
    _sfTextureControlPoints   (this,
                          TextureControlPointsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfDirtyMask              (source._sfDirtyMask              ),
    _sfSurfaceGLId            (source._sfSurfaceGLId            )
{
}


/*-------------------------- destructors ----------------------------------*/

SurfaceBase::~SurfaceBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool SurfaceBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == ControlPointsFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(_sfControlPoints.getValue() == pTypedChild)
            {
                editSField(ControlPointsFieldMask);

                _sfControlPoints.setValue(NULL);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }

    if(childFieldId == TextureControlPointsFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(_sfTextureControlPoints.getValue() == pTypedChild)
            {
                editSField(TextureControlPointsFieldMask);

                _sfTextureControlPoints.setValue(NULL);

                return true;
            }

            SWARNING << "Parent (["        << this
                     << "] id ["           << this->getId()
                     << "] type ["         << this->getType().getCName()
                     << "] childFieldId [" << childFieldId
                     << "]) - Child (["    << pChild
                     << "] id ["           << pChild->getId()
                     << "] type ["         << pChild->getType().getCName()
                     << "]): link inconsistent!"
                     << std::endl;

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void SurfaceBase::onCreate(const Surface *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Surface *pThis = static_cast<Surface *>(this);

        pThis->setControlPoints(source->getControlPoints());

        pThis->setTextureControlPoints(source->getTextureControlPoints());
    }
}

GetFieldHandlePtr SurfaceBase::getHandleDimU            (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfDimU,
             this->getType().getFieldDesc(DimUFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleDimU           (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfDimU,
             this->getType().getFieldDesc(DimUFieldId),
             this));


    editSField(DimUFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleDimV            (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfDimV,
             this->getType().getFieldDesc(DimVFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleDimV           (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfDimV,
             this->getType().getFieldDesc(DimVFieldId),
             this));


    editSField(DimVFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleKnotsU          (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfKnotsU,
             this->getType().getFieldDesc(KnotsUFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleKnotsU         (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfKnotsU,
             this->getType().getFieldDesc(KnotsUFieldId),
             this));


    editMField(KnotsUFieldMask, _mfKnotsU);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleKnotsV          (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfKnotsV,
             this->getType().getFieldDesc(KnotsVFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleKnotsV         (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfKnotsV,
             this->getType().getFieldDesc(KnotsVFieldId),
             this));


    editMField(KnotsVFieldMask, _mfKnotsV);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleControlPoints   (void) const
{
    SFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_sfControlPoints,
             this->getType().getFieldDesc(ControlPointsFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleControlPoints  (void)
{
    SFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_sfControlPoints,
             this->getType().getFieldDesc(ControlPointsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Surface::setControlPoints,
                    static_cast<Surface *>(this), ::boost::placeholders::_1));

    editSField(ControlPointsFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleError           (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfError,
             this->getType().getFieldDesc(ErrorFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleError          (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfError,
             this->getType().getFieldDesc(ErrorFieldId),
             this));


    editSField(ErrorFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleNumCurves       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfNumCurves,
             this->getType().getFieldDesc(NumCurvesFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleNumCurves      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfNumCurves,
             this->getType().getFieldDesc(NumCurvesFieldId),
             this));


    editSField(NumCurvesFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleKnotLengths     (void) const
{
    MFUInt32::GetHandlePtr returnValue(
        new  MFUInt32::GetHandle(
             &_mfKnotLengths,
             this->getType().getFieldDesc(KnotLengthsFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleKnotLengths    (void)
{
    MFUInt32::EditHandlePtr returnValue(
        new  MFUInt32::EditHandle(
             &_mfKnotLengths,
             this->getType().getFieldDesc(KnotLengthsFieldId),
             this));


    editMField(KnotLengthsFieldMask, _mfKnotLengths);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleDimensions      (void) const
{
    MFUInt32::GetHandlePtr returnValue(
        new  MFUInt32::GetHandle(
             &_mfDimensions,
             this->getType().getFieldDesc(DimensionsFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleDimensions     (void)
{
    MFUInt32::EditHandlePtr returnValue(
        new  MFUInt32::EditHandle(
             &_mfDimensions,
             this->getType().getFieldDesc(DimensionsFieldId),
             this));


    editMField(DimensionsFieldMask, _mfDimensions);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleCurveControlPoints (void) const
{
    MFPnt3f::GetHandlePtr returnValue(
        new  MFPnt3f::GetHandle(
             &_mfCurveControlPoints,
             this->getType().getFieldDesc(CurveControlPointsFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleCurveControlPoints(void)
{
    MFPnt3f::EditHandlePtr returnValue(
        new  MFPnt3f::EditHandle(
             &_mfCurveControlPoints,
             this->getType().getFieldDesc(CurveControlPointsFieldId),
             this));


    editMField(CurveControlPointsFieldMask, _mfCurveControlPoints);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleKnots           (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfKnots,
             this->getType().getFieldDesc(KnotsFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleKnots          (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfKnots,
             this->getType().getFieldDesc(KnotsFieldId),
             this));


    editMField(KnotsFieldMask, _mfKnots);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleCurvesPerLoop   (void) const
{
    MFUInt32::GetHandlePtr returnValue(
        new  MFUInt32::GetHandle(
             &_mfCurvesPerLoop,
             this->getType().getFieldDesc(CurvesPerLoopFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleCurvesPerLoop  (void)
{
    MFUInt32::EditHandlePtr returnValue(
        new  MFUInt32::EditHandle(
             &_mfCurvesPerLoop,
             this->getType().getFieldDesc(CurvesPerLoopFieldId),
             this));


    editMField(CurvesPerLoopFieldMask, _mfCurvesPerLoop);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleIsDelaunay      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfIsDelaunay,
             this->getType().getFieldDesc(IsDelaunayFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleIsDelaunay     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfIsDelaunay,
             this->getType().getFieldDesc(IsDelaunayFieldId),
             this));


    editSField(IsDelaunayFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleTextureControlPoints (void) const
{
    SFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_sfTextureControlPoints,
             this->getType().getFieldDesc(TextureControlPointsFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleTextureControlPoints(void)
{
    SFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_sfTextureControlPoints,
             this->getType().getFieldDesc(TextureControlPointsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Surface::setTextureControlPoints,
                    static_cast<Surface *>(this), ::boost::placeholders::_1));

    editSField(TextureControlPointsFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleDirtyMask       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfDirtyMask,
             this->getType().getFieldDesc(DirtyMaskFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleDirtyMask      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfDirtyMask,
             this->getType().getFieldDesc(DirtyMaskFieldId),
             this));


    editSField(DirtyMaskFieldMask);

    return returnValue;
}

GetFieldHandlePtr SurfaceBase::getHandleSurfaceGLId     (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfSurfaceGLId,
             this->getType().getFieldDesc(SurfaceGLIdFieldId),
             const_cast<SurfaceBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SurfaceBase::editHandleSurfaceGLId    (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfSurfaceGLId,
             this->getType().getFieldDesc(SurfaceGLIdFieldId),
             this));


    editSField(SurfaceGLIdFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void SurfaceBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Surface *pThis = static_cast<Surface *>(this);

    pThis->execSync(static_cast<Surface *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *SurfaceBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    Surface *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Surface *>(pRefAspect),
                  dynamic_cast<const Surface *>(this));

    return returnValue;
}
#endif

void SurfaceBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Surface *>(this)->setControlPoints(NULL);

    static_cast<Surface *>(this)->setTextureControlPoints(NULL);

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfKnotsU.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfKnotsV.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfKnotLengths.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfDimensions.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfCurveControlPoints.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfKnots.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfCurvesPerLoop.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
