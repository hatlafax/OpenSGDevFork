/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class ShadowStage!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"


#include "OSGGLEXT.h"                     // BufferFormat default header
#include "OSGGL.h"                        // Red default header
#include "OSGGL.h"                        // Blue default header
#include "OSGGL.h"                        // Green default header
#include "OSGGL.h"                        // Alpha default header

#include "OSGNode.h"                    // LightNodes Class

#include "OSGShadowStageBase.h"
#include "OSGShadowStage.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::ShadowStage
    First Release of ShadowMap-Viewport. Viewport is capable to handle multiple
    Lights and produces ambient Shadows. Viewport uses On-Screen-rendering, so
    Window must not be occulled. 
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var GLenum          ShadowStageBase::_sfBufferFormat
    
*/

/*! \var Real32          ShadowStageBase::_sfOffBias
    Offset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk
*/

/*! \var Real32          ShadowStageBase::_sfOffFactor
    Offset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk
*/

/*! \var UInt32          ShadowStageBase::_sfMapSize
    
*/

/*! \var Node *          ShadowStageBase::_mfLightNodes
    
*/

/*! \var Node *          ShadowStageBase::_mfExcludeNodes
    
*/

/*! \var bool            ShadowStageBase::_sfMapAutoUpdate
    
*/

/*! \var UInt32          ShadowStageBase::_sfShadowMode
    
*/

/*! \var Real32          ShadowStageBase::_sfShadowSmoothness
    
*/

/*! \var bool            ShadowStageBase::_sfShadowOn
    
*/

/*! \var bool            ShadowStageBase::_sfAutoSearchForLights
    if enabled, all lights in the scenegraph are added to the ShadowViewport
*/

/*! \var Real32          ShadowStageBase::_sfGlobalShadowIntensity
    Used for every Light if set != 1.0
*/

/*! \var bool            ShadowStageBase::_sfFboOn
    Sometimes rendering directly into framebuffer is needed instead of using
    textures. 
*/

/*! \var bool            ShadowStageBase::_sfAutoExcludeTransparentNodes
    Usually transparent objects do not throw shadows.
*/

/*! \var bool            ShadowStageBase::_sfDisableOccludedLights
    Check lights occlusion to disable occluded lights.
*/

/*! \var bool            ShadowStageBase::_sfRed
    Define whether the red color channel is written to.
*/

/*! \var bool            ShadowStageBase::_sfBlue
    Define whether the green color channel is written to.
*/

/*! \var bool            ShadowStageBase::_sfGreen
    Define whether the blue color channel is written to.
*/

/*! \var bool            ShadowStageBase::_sfAlpha
    Define whether the alpha color channel is written to.
*/

/*! \var bool            ShadowStageBase::_sfBlitZBuffer
    leave a correct Z-Buffer on the way out.
*/

/*! \var bool            ShadowStageBase::_sfCombineBlend
    Use blending when writing the combined scene and shadow images to the
    target framebuffer.
*/

/*! \var RenderPropBitVector ShadowStageBase::_sfRenderPropertyMask
    Use blending when writing the combined scene and shadow images to the
    target framebuffer.
*/

/*! \var bool            ShadowStageBase::_sfEnableMultiSample
    Use multisampling when rendering color map and shadow factor map.
*/

/*! \var UInt32          ShadowStageBase::_sfColorSamples
    
*/

/*! \var UInt32          ShadowStageBase::_sfCoverageSamples
    
*/

/*! \var bool            ShadowStageBase::_sfFixedSampleLocation
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<ShadowStage *, nsOSG>::_type(
    "ShadowStagePtr", 
    "StagePtr", 
    ShadowStage::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(ShadowStage *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           ShadowStage *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           ShadowStage *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void ShadowStageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "bufferFormat",
        "",
        BufferFormatFieldId, BufferFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleBufferFormat),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleBufferFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offBias",
        "Offset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk\n",
        OffBiasFieldId, OffBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleOffBias),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleOffBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offFactor",
        "Offset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk\n",
        OffFactorFieldId, OffFactorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleOffFactor),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleOffFactor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "mapSize",
        "",
        MapSizeFieldId, MapSizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleMapSize),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleMapSize));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "lightNodes",
        "",
        LightNodesFieldId, LightNodesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleLightNodes),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleLightNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "excludeNodes",
        "",
        ExcludeNodesFieldId, ExcludeNodesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleExcludeNodes),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleExcludeNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "mapAutoUpdate",
        "",
        MapAutoUpdateFieldId, MapAutoUpdateFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleMapAutoUpdate),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleMapAutoUpdate));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "shadowMode",
        "",
        ShadowModeFieldId, ShadowModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleShadowMode),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleShadowMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shadowSmoothness",
        "",
        ShadowSmoothnessFieldId, ShadowSmoothnessFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleShadowSmoothness),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleShadowSmoothness));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "shadowOn",
        "",
        ShadowOnFieldId, ShadowOnFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleShadowOn),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleShadowOn));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "autoSearchForLights",
        "if enabled, all lights in the scenegraph are added to the ShadowViewport\n",
        AutoSearchForLightsFieldId, AutoSearchForLightsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleAutoSearchForLights),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleAutoSearchForLights));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "globalShadowIntensity",
        "Used for every Light if set != 1.0\n",
        GlobalShadowIntensityFieldId, GlobalShadowIntensityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleGlobalShadowIntensity),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleGlobalShadowIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "fboOn",
        "Sometimes rendering directly into framebuffer is needed instead of using\n"
        "textures. \n",
        FboOnFieldId, FboOnFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleFboOn),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleFboOn));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "autoExcludeTransparentNodes",
        "Usually transparent objects do not throw shadows.\n",
        AutoExcludeTransparentNodesFieldId, AutoExcludeTransparentNodesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleAutoExcludeTransparentNodes),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleAutoExcludeTransparentNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "disableOccludedLights",
        "Check lights occlusion to disable occluded lights.\n",
        DisableOccludedLightsFieldId, DisableOccludedLightsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleDisableOccludedLights),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleDisableOccludedLights));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "red",
        "Define whether the red color channel is written to.\n",
        RedFieldId, RedFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleRed),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleRed));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "blue",
        "Define whether the green color channel is written to.\n",
        BlueFieldId, BlueFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleBlue),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleBlue));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "green",
        "Define whether the blue color channel is written to.\n",
        GreenFieldId, GreenFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleGreen),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleGreen));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "alpha",
        "Define whether the alpha color channel is written to.\n",
        AlphaFieldId, AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleAlpha),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleAlpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "blitZBuffer",
        "leave a correct Z-Buffer on the way out.\n",
        BlitZBufferFieldId, BlitZBufferFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleBlitZBuffer),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleBlitZBuffer));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "combineBlend",
        "Use blending when writing the combined scene and shadow images to the\n"
        "target framebuffer.\n",
        CombineBlendFieldId, CombineBlendFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleCombineBlend),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleCombineBlend));

    oType.addInitialDesc(pDesc);

    pDesc = new SFRenderPropBitVector::Description(
        SFRenderPropBitVector::getClassType(),
        "renderPropertyMask",
        "Use blending when writing the combined scene and shadow images to the\n"
        "target framebuffer.\n",
        RenderPropertyMaskFieldId, RenderPropertyMaskFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleRenderPropertyMask),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleRenderPropertyMask));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "enableMultiSample",
        "Use multisampling when rendering color map and shadow factor map.\n",
        EnableMultiSampleFieldId, EnableMultiSampleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleEnableMultiSample),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleEnableMultiSample));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "colorSamples",
        "",
        ColorSamplesFieldId, ColorSamplesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleColorSamples),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleColorSamples));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "coverageSamples",
        "",
        CoverageSamplesFieldId, CoverageSamplesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleCoverageSamples),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleCoverageSamples));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "fixedSampleLocation",
        "",
        FixedSampleLocationFieldId, FixedSampleLocationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleFixedSampleLocation),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleFixedSampleLocation));

    oType.addInitialDesc(pDesc);
}


ShadowStageBase::TypeObject ShadowStageBase::_type(
    ShadowStageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&ShadowStageBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&ShadowStage::initMethod),
    reinterpret_cast<ExitContainerF>(&ShadowStage::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&ShadowStage::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"ShadowStage\"\n"
    "   parent=\"Stage\"\n"
    "   library=\"EffectGroups\"\n"
    "   pointerfieldtypes=\"both\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   useLocalIncludes=\"false\"\n"
    "   docGroupBase=\"GrpEffectsGroupsDeferredShading\"\n"
    "   >\n"
    "  First Release of ShadowMap-Viewport. Viewport is capable to handle multiple\n"
    "  Lights and produces ambient Shadows. Viewport uses On-Screen-rendering, so\n"
    "  Window must not be occulled. \n"
    "  <Field\n"
    "\t name=\"bufferFormat\"\n"
    "\t type=\"GLenum\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_NONE\"\n"
    "\t defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "\t access=\"public\"\n"
    "     >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"offBias\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"6\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tOffset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"offFactor\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"4\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tOffset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"mapSize\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"512\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"lightNodes\"\n"
    "\t type=\"NodePtr\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"excludeNodes\"\n"
    "\t type=\"NodePtr\"\n"
    "\t cardinality=\"multi\"\n"
    "\t visibility=\"external\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"mapAutoUpdate\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowMode\"\n"
    "\t type=\"UInt32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowSmoothness\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.5\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"shadowOn\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"autoSearchForLights\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tif enabled, all lights in the scenegraph are added to the ShadowViewport\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"globalShadowIntensity\"\n"
    "\t type=\"Real32\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"0.0\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tUsed for every Light if set != 1.0\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"fboOn\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tSometimes rendering directly into framebuffer is needed instead of using\n"
    "\ttextures. \n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"autoExcludeTransparentNodes\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"true\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tUsually transparent objects do not throw shadows.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"disableOccludedLights\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tCheck lights occlusion to disable occluded lights.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"red\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_TRUE\"\n"
    "\t defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tDefine whether the red color channel is written to.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"blue\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_TRUE\"\n"
    "\t defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tDefine whether the green color channel is written to.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"green\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_TRUE\"\n"
    "\t defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tDefine whether the blue color channel is written to.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"alpha\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"GL_TRUE\"\n"
    "\t defaultHeader=\"&quot;OSGGL.h&quot;\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tDefine whether the alpha color channel is written to.\n"
    "  </Field>\n"
    "  <Field\n"
    "\t name=\"blitZBuffer\"\n"
    "\t type=\"bool\"\n"
    "\t cardinality=\"single\"\n"
    "\t visibility=\"external\"\n"
    "\t defaultValue=\"false\"\n"
    "\t access=\"public\"\n"
    "\t >\n"
    "\tleave a correct Z-Buffer on the way out.\n"
    "  </Field>\n"
    "  <Field\n"
    "    name=\"combineBlend\"\n"
    "    type=\"bool\"\n"
    "    cardinality=\"single\"\n"
    "    visibility=\"external\"\n"
    "    defaultValue=\"false\"\n"
    "    access=\"public\"\n"
    "    >\n"
    "    Use blending when writing the combined scene and shadow images to the\n"
    "    target framebuffer.\n"
    "    </Field>\n"
    "  <Field\n"
    "    name=\"renderPropertyMask\"\n"
    "    type=\"RenderPropBitVector\"\n"
    "    cardinality=\"single\"\n"
    "    visibility=\"external\"\n"
    "    defaultValue=\"SystemRenderProperties.ColorBuffer\"\n"
    "    access=\"public\"\n"
    "    >\n"
    "    Use blending when writing the combined scene and shadow images to the\n"
    "    target framebuffer.\n"
    "    </Field>\n"
    "  <Field\n"
    "    name=\"enableMultiSample\"\n"
    "    type=\"bool\"\n"
    "    cardinality=\"single\"\n"
    "    visibility=\"external\"\n"
    "    access=\"public\"\n"
    "    defaultValue=\"false\"\n"
    "    >\n"
    "    Use multisampling when rendering color map and shadow factor map.\n"
    "    </Field>\n"
    "  <Field\n"
    "    name=\"colorSamples\"\n"
    "    type=\"UInt32\"\n"
    "    cardinality=\"single\"\n"
    "    visibility=\"external\"\n"
    "    access=\"public\"\n"
    "    defaultValue=\"4\"\n"
    "    >\n"
    "    </Field>\n"
    "  <Field\n"
    "    name=\"coverageSamples\"\n"
    "    type=\"UInt32\"\n"
    "    cardinality=\"single\"\n"
    "    visibility=\"external\"\n"
    "    access=\"public\"\n"
    "    defaultValue=\"4\"\n"
    "    >\n"
    "    </Field>\n"
    "  <Field\n"
    "    name=\"fixedSampleLocation\"\n"
    "    type=\"bool\"\n"
    "    cardinality=\"single\"\n"
    "    visibility=\"external\"\n"
    "    access=\"public\"\n"
    "    defaultValue=\"true\"\n"
    "    >\n"
    "    </Field>\n"
    "</FieldContainer>\n",
    "First Release of ShadowMap-Viewport. Viewport is capable to handle multiple\n"
    "Lights and produces ambient Shadows. Viewport uses On-Screen-rendering, so\n"
    "Window must not be occulled. \n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ShadowStageBase::getType(void)
{
    return _type;
}

const FieldContainerType &ShadowStageBase::getType(void) const
{
    return _type;
}

UInt32 ShadowStageBase::getContainerSize(void) const
{
    return sizeof(ShadowStage);
}

/*------------------------- decorator get ------------------------------*/


SFGLenum *ShadowStageBase::editSFBufferFormat(void)
{
    editSField(BufferFormatFieldMask);

    return &_sfBufferFormat;
}

const SFGLenum *ShadowStageBase::getSFBufferFormat(void) const
{
    return &_sfBufferFormat;
}


SFReal32 *ShadowStageBase::editSFOffBias(void)
{
    editSField(OffBiasFieldMask);

    return &_sfOffBias;
}

const SFReal32 *ShadowStageBase::getSFOffBias(void) const
{
    return &_sfOffBias;
}


SFReal32 *ShadowStageBase::editSFOffFactor(void)
{
    editSField(OffFactorFieldMask);

    return &_sfOffFactor;
}

const SFReal32 *ShadowStageBase::getSFOffFactor(void) const
{
    return &_sfOffFactor;
}


SFUInt32 *ShadowStageBase::editSFMapSize(void)
{
    editSField(MapSizeFieldMask);

    return &_sfMapSize;
}

const SFUInt32 *ShadowStageBase::getSFMapSize(void) const
{
    return &_sfMapSize;
}


//! Get the ShadowStage::_mfLightNodes field.
const MFUnrecNodePtr *ShadowStageBase::getMFLightNodes(void) const
{
    return &_mfLightNodes;
}

MFUnrecNodePtr      *ShadowStageBase::editMFLightNodes     (void)
{
    editMField(LightNodesFieldMask, _mfLightNodes);

    return &_mfLightNodes;
}
Node * ShadowStageBase::getLightNodes(const UInt32 index) const
{
    return _mfLightNodes[index];
}

//! Get the ShadowStage::_mfExcludeNodes field.
const MFUnrecNodePtr *ShadowStageBase::getMFExcludeNodes(void) const
{
    return &_mfExcludeNodes;
}

MFUnrecNodePtr      *ShadowStageBase::editMFExcludeNodes   (void)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    return &_mfExcludeNodes;
}
Node * ShadowStageBase::getExcludeNodes(const UInt32 index) const
{
    return _mfExcludeNodes[index];
}

SFBool *ShadowStageBase::editSFMapAutoUpdate(void)
{
    editSField(MapAutoUpdateFieldMask);

    return &_sfMapAutoUpdate;
}

const SFBool *ShadowStageBase::getSFMapAutoUpdate(void) const
{
    return &_sfMapAutoUpdate;
}


SFUInt32 *ShadowStageBase::editSFShadowMode(void)
{
    editSField(ShadowModeFieldMask);

    return &_sfShadowMode;
}

const SFUInt32 *ShadowStageBase::getSFShadowMode(void) const
{
    return &_sfShadowMode;
}


SFReal32 *ShadowStageBase::editSFShadowSmoothness(void)
{
    editSField(ShadowSmoothnessFieldMask);

    return &_sfShadowSmoothness;
}

const SFReal32 *ShadowStageBase::getSFShadowSmoothness(void) const
{
    return &_sfShadowSmoothness;
}


SFBool *ShadowStageBase::editSFShadowOn(void)
{
    editSField(ShadowOnFieldMask);

    return &_sfShadowOn;
}

const SFBool *ShadowStageBase::getSFShadowOn(void) const
{
    return &_sfShadowOn;
}


SFBool *ShadowStageBase::editSFAutoSearchForLights(void)
{
    editSField(AutoSearchForLightsFieldMask);

    return &_sfAutoSearchForLights;
}

const SFBool *ShadowStageBase::getSFAutoSearchForLights(void) const
{
    return &_sfAutoSearchForLights;
}


SFReal32 *ShadowStageBase::editSFGlobalShadowIntensity(void)
{
    editSField(GlobalShadowIntensityFieldMask);

    return &_sfGlobalShadowIntensity;
}

const SFReal32 *ShadowStageBase::getSFGlobalShadowIntensity(void) const
{
    return &_sfGlobalShadowIntensity;
}


SFBool *ShadowStageBase::editSFFboOn(void)
{
    editSField(FboOnFieldMask);

    return &_sfFboOn;
}

const SFBool *ShadowStageBase::getSFFboOn(void) const
{
    return &_sfFboOn;
}


SFBool *ShadowStageBase::editSFAutoExcludeTransparentNodes(void)
{
    editSField(AutoExcludeTransparentNodesFieldMask);

    return &_sfAutoExcludeTransparentNodes;
}

const SFBool *ShadowStageBase::getSFAutoExcludeTransparentNodes(void) const
{
    return &_sfAutoExcludeTransparentNodes;
}


SFBool *ShadowStageBase::editSFDisableOccludedLights(void)
{
    editSField(DisableOccludedLightsFieldMask);

    return &_sfDisableOccludedLights;
}

const SFBool *ShadowStageBase::getSFDisableOccludedLights(void) const
{
    return &_sfDisableOccludedLights;
}


SFBool *ShadowStageBase::editSFRed(void)
{
    editSField(RedFieldMask);

    return &_sfRed;
}

const SFBool *ShadowStageBase::getSFRed(void) const
{
    return &_sfRed;
}


SFBool *ShadowStageBase::editSFBlue(void)
{
    editSField(BlueFieldMask);

    return &_sfBlue;
}

const SFBool *ShadowStageBase::getSFBlue(void) const
{
    return &_sfBlue;
}


SFBool *ShadowStageBase::editSFGreen(void)
{
    editSField(GreenFieldMask);

    return &_sfGreen;
}

const SFBool *ShadowStageBase::getSFGreen(void) const
{
    return &_sfGreen;
}


SFBool *ShadowStageBase::editSFAlpha(void)
{
    editSField(AlphaFieldMask);

    return &_sfAlpha;
}

const SFBool *ShadowStageBase::getSFAlpha(void) const
{
    return &_sfAlpha;
}


SFBool *ShadowStageBase::editSFBlitZBuffer(void)
{
    editSField(BlitZBufferFieldMask);

    return &_sfBlitZBuffer;
}

const SFBool *ShadowStageBase::getSFBlitZBuffer(void) const
{
    return &_sfBlitZBuffer;
}


SFBool *ShadowStageBase::editSFCombineBlend(void)
{
    editSField(CombineBlendFieldMask);

    return &_sfCombineBlend;
}

const SFBool *ShadowStageBase::getSFCombineBlend(void) const
{
    return &_sfCombineBlend;
}


SFRenderPropBitVector *ShadowStageBase::editSFRenderPropertyMask(void)
{
    editSField(RenderPropertyMaskFieldMask);

    return &_sfRenderPropertyMask;
}

const SFRenderPropBitVector *ShadowStageBase::getSFRenderPropertyMask(void) const
{
    return &_sfRenderPropertyMask;
}


SFBool *ShadowStageBase::editSFEnableMultiSample(void)
{
    editSField(EnableMultiSampleFieldMask);

    return &_sfEnableMultiSample;
}

const SFBool *ShadowStageBase::getSFEnableMultiSample(void) const
{
    return &_sfEnableMultiSample;
}


SFUInt32 *ShadowStageBase::editSFColorSamples(void)
{
    editSField(ColorSamplesFieldMask);

    return &_sfColorSamples;
}

const SFUInt32 *ShadowStageBase::getSFColorSamples(void) const
{
    return &_sfColorSamples;
}


SFUInt32 *ShadowStageBase::editSFCoverageSamples(void)
{
    editSField(CoverageSamplesFieldMask);

    return &_sfCoverageSamples;
}

const SFUInt32 *ShadowStageBase::getSFCoverageSamples(void) const
{
    return &_sfCoverageSamples;
}


SFBool *ShadowStageBase::editSFFixedSampleLocation(void)
{
    editSField(FixedSampleLocationFieldMask);

    return &_sfFixedSampleLocation;
}

const SFBool *ShadowStageBase::getSFFixedSampleLocation(void) const
{
    return &_sfFixedSampleLocation;
}




void ShadowStageBase::pushToLightNodes(Node * const value)
{
    editMField(LightNodesFieldMask, _mfLightNodes);

    _mfLightNodes.push_back(value);
}

void ShadowStageBase::assignLightNodes(const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<ShadowStage *>(this)->clearLightNodes();

    while(elemIt != elemEnd)
    {
        this->pushToLightNodes(*elemIt);

        ++elemIt;
    }
}

void ShadowStageBase::removeFromLightNodes(UInt32 uiIndex)
{
    if(uiIndex < _mfLightNodes.size())
    {
        editMField(LightNodesFieldMask, _mfLightNodes);

        _mfLightNodes.erase(uiIndex);
    }
}

void ShadowStageBase::removeObjFromLightNodes(Node * const value)
{
    Int32 iElemIdx = _mfLightNodes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(LightNodesFieldMask, _mfLightNodes);

        _mfLightNodes.erase(iElemIdx);
    }
}
void ShadowStageBase::clearLightNodes(void)
{
    editMField(LightNodesFieldMask, _mfLightNodes);


    _mfLightNodes.clear();
}

void ShadowStageBase::pushToExcludeNodes(Node * const value)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    _mfExcludeNodes.push_back(value);
}

void ShadowStageBase::assignExcludeNodes(const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<ShadowStage *>(this)->clearExcludeNodes();

    while(elemIt != elemEnd)
    {
        this->pushToExcludeNodes(*elemIt);

        ++elemIt;
    }
}

void ShadowStageBase::removeFromExcludeNodes(UInt32 uiIndex)
{
    if(uiIndex < _mfExcludeNodes.size())
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

        _mfExcludeNodes.erase(uiIndex);
    }
}

void ShadowStageBase::removeObjFromExcludeNodes(Node * const value)
{
    Int32 iElemIdx = _mfExcludeNodes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

        _mfExcludeNodes.erase(iElemIdx);
    }
}
void ShadowStageBase::clearExcludeNodes(void)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);


    _mfExcludeNodes.clear();
}



/*------------------------------ access -----------------------------------*/

SizeT ShadowStageBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (BufferFormatFieldMask & whichField))
    {
        returnValue += _sfBufferFormat.getBinSize();
    }
    if(FieldBits::NoField != (OffBiasFieldMask & whichField))
    {
        returnValue += _sfOffBias.getBinSize();
    }
    if(FieldBits::NoField != (OffFactorFieldMask & whichField))
    {
        returnValue += _sfOffFactor.getBinSize();
    }
    if(FieldBits::NoField != (MapSizeFieldMask & whichField))
    {
        returnValue += _sfMapSize.getBinSize();
    }
    if(FieldBits::NoField != (LightNodesFieldMask & whichField))
    {
        returnValue += _mfLightNodes.getBinSize();
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        returnValue += _mfExcludeNodes.getBinSize();
    }
    if(FieldBits::NoField != (MapAutoUpdateFieldMask & whichField))
    {
        returnValue += _sfMapAutoUpdate.getBinSize();
    }
    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        returnValue += _sfShadowMode.getBinSize();
    }
    if(FieldBits::NoField != (ShadowSmoothnessFieldMask & whichField))
    {
        returnValue += _sfShadowSmoothness.getBinSize();
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        returnValue += _sfShadowOn.getBinSize();
    }
    if(FieldBits::NoField != (AutoSearchForLightsFieldMask & whichField))
    {
        returnValue += _sfAutoSearchForLights.getBinSize();
    }
    if(FieldBits::NoField != (GlobalShadowIntensityFieldMask & whichField))
    {
        returnValue += _sfGlobalShadowIntensity.getBinSize();
    }
    if(FieldBits::NoField != (FboOnFieldMask & whichField))
    {
        returnValue += _sfFboOn.getBinSize();
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        returnValue += _sfAutoExcludeTransparentNodes.getBinSize();
    }
    if(FieldBits::NoField != (DisableOccludedLightsFieldMask & whichField))
    {
        returnValue += _sfDisableOccludedLights.getBinSize();
    }
    if(FieldBits::NoField != (RedFieldMask & whichField))
    {
        returnValue += _sfRed.getBinSize();
    }
    if(FieldBits::NoField != (BlueFieldMask & whichField))
    {
        returnValue += _sfBlue.getBinSize();
    }
    if(FieldBits::NoField != (GreenFieldMask & whichField))
    {
        returnValue += _sfGreen.getBinSize();
    }
    if(FieldBits::NoField != (AlphaFieldMask & whichField))
    {
        returnValue += _sfAlpha.getBinSize();
    }
    if(FieldBits::NoField != (BlitZBufferFieldMask & whichField))
    {
        returnValue += _sfBlitZBuffer.getBinSize();
    }
    if(FieldBits::NoField != (CombineBlendFieldMask & whichField))
    {
        returnValue += _sfCombineBlend.getBinSize();
    }
    if(FieldBits::NoField != (RenderPropertyMaskFieldMask & whichField))
    {
        returnValue += _sfRenderPropertyMask.getBinSize();
    }
    if(FieldBits::NoField != (EnableMultiSampleFieldMask & whichField))
    {
        returnValue += _sfEnableMultiSample.getBinSize();
    }
    if(FieldBits::NoField != (ColorSamplesFieldMask & whichField))
    {
        returnValue += _sfColorSamples.getBinSize();
    }
    if(FieldBits::NoField != (CoverageSamplesFieldMask & whichField))
    {
        returnValue += _sfCoverageSamples.getBinSize();
    }
    if(FieldBits::NoField != (FixedSampleLocationFieldMask & whichField))
    {
        returnValue += _sfFixedSampleLocation.getBinSize();
    }

    return returnValue;
}

void ShadowStageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (BufferFormatFieldMask & whichField))
    {
        _sfBufferFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffBiasFieldMask & whichField))
    {
        _sfOffBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffFactorFieldMask & whichField))
    {
        _sfOffFactor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MapSizeFieldMask & whichField))
    {
        _sfMapSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LightNodesFieldMask & whichField))
    {
        _mfLightNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        _mfExcludeNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MapAutoUpdateFieldMask & whichField))
    {
        _sfMapAutoUpdate.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        _sfShadowMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowSmoothnessFieldMask & whichField))
    {
        _sfShadowSmoothness.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        _sfShadowOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoSearchForLightsFieldMask & whichField))
    {
        _sfAutoSearchForLights.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GlobalShadowIntensityFieldMask & whichField))
    {
        _sfGlobalShadowIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FboOnFieldMask & whichField))
    {
        _sfFboOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        _sfAutoExcludeTransparentNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DisableOccludedLightsFieldMask & whichField))
    {
        _sfDisableOccludedLights.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RedFieldMask & whichField))
    {
        _sfRed.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BlueFieldMask & whichField))
    {
        _sfBlue.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GreenFieldMask & whichField))
    {
        _sfGreen.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AlphaFieldMask & whichField))
    {
        _sfAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BlitZBufferFieldMask & whichField))
    {
        _sfBlitZBuffer.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CombineBlendFieldMask & whichField))
    {
        _sfCombineBlend.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RenderPropertyMaskFieldMask & whichField))
    {
        _sfRenderPropertyMask.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnableMultiSampleFieldMask & whichField))
    {
        _sfEnableMultiSample.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorSamplesFieldMask & whichField))
    {
        _sfColorSamples.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CoverageSamplesFieldMask & whichField))
    {
        _sfCoverageSamples.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FixedSampleLocationFieldMask & whichField))
    {
        _sfFixedSampleLocation.copyToBin(pMem);
    }
}

void ShadowStageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (BufferFormatFieldMask & whichField))
    {
        editSField(BufferFormatFieldMask);
        _sfBufferFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffBiasFieldMask & whichField))
    {
        editSField(OffBiasFieldMask);
        _sfOffBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffFactorFieldMask & whichField))
    {
        editSField(OffFactorFieldMask);
        _sfOffFactor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MapSizeFieldMask & whichField))
    {
        editSField(MapSizeFieldMask);
        _sfMapSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LightNodesFieldMask & whichField))
    {
        editMField(LightNodesFieldMask, _mfLightNodes);
        _mfLightNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);
        _mfExcludeNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MapAutoUpdateFieldMask & whichField))
    {
        editSField(MapAutoUpdateFieldMask);
        _sfMapAutoUpdate.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        editSField(ShadowModeFieldMask);
        _sfShadowMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowSmoothnessFieldMask & whichField))
    {
        editSField(ShadowSmoothnessFieldMask);
        _sfShadowSmoothness.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        editSField(ShadowOnFieldMask);
        _sfShadowOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoSearchForLightsFieldMask & whichField))
    {
        editSField(AutoSearchForLightsFieldMask);
        _sfAutoSearchForLights.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GlobalShadowIntensityFieldMask & whichField))
    {
        editSField(GlobalShadowIntensityFieldMask);
        _sfGlobalShadowIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FboOnFieldMask & whichField))
    {
        editSField(FboOnFieldMask);
        _sfFboOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        editSField(AutoExcludeTransparentNodesFieldMask);
        _sfAutoExcludeTransparentNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DisableOccludedLightsFieldMask & whichField))
    {
        editSField(DisableOccludedLightsFieldMask);
        _sfDisableOccludedLights.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RedFieldMask & whichField))
    {
        editSField(RedFieldMask);
        _sfRed.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BlueFieldMask & whichField))
    {
        editSField(BlueFieldMask);
        _sfBlue.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GreenFieldMask & whichField))
    {
        editSField(GreenFieldMask);
        _sfGreen.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AlphaFieldMask & whichField))
    {
        editSField(AlphaFieldMask);
        _sfAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BlitZBufferFieldMask & whichField))
    {
        editSField(BlitZBufferFieldMask);
        _sfBlitZBuffer.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CombineBlendFieldMask & whichField))
    {
        editSField(CombineBlendFieldMask);
        _sfCombineBlend.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RenderPropertyMaskFieldMask & whichField))
    {
        editSField(RenderPropertyMaskFieldMask);
        _sfRenderPropertyMask.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnableMultiSampleFieldMask & whichField))
    {
        editSField(EnableMultiSampleFieldMask);
        _sfEnableMultiSample.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorSamplesFieldMask & whichField))
    {
        editSField(ColorSamplesFieldMask);
        _sfColorSamples.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CoverageSamplesFieldMask & whichField))
    {
        editSField(CoverageSamplesFieldMask);
        _sfCoverageSamples.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FixedSampleLocationFieldMask & whichField))
    {
        editSField(FixedSampleLocationFieldMask);
        _sfFixedSampleLocation.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ShadowStageTransitPtr ShadowStageBase::createLocal(BitVector bFlags)
{
    ShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<ShadowStage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
ShadowStageTransitPtr ShadowStageBase::createDependent(BitVector bFlags)
{
    ShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<ShadowStage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ShadowStageTransitPtr ShadowStageBase::create(void)
{
    ShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<ShadowStage>(tmpPtr);
    }

    return fc;
}

ShadowStage *ShadowStageBase::createEmptyLocal(BitVector bFlags)
{
    ShadowStage *returnValue;

    newPtr<ShadowStage>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
ShadowStage *ShadowStageBase::createEmpty(void)
{
    ShadowStage *returnValue;

    newPtr<ShadowStage>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr ShadowStageBase::shallowCopyLocal(
    BitVector bFlags) const
{
    ShadowStage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const ShadowStage *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ShadowStageBase::shallowCopyDependent(
    BitVector bFlags) const
{
    ShadowStage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const ShadowStage *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr ShadowStageBase::shallowCopy(void) const
{
    ShadowStage *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const ShadowStage *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

ShadowStageBase::ShadowStageBase(void) :
    Inherited(),
    _sfBufferFormat           (GLenum(GL_NONE)),
    _sfOffBias                (Real32(6)),
    _sfOffFactor              (Real32(4)),
    _sfMapSize                (UInt32(512)),
    _mfLightNodes             (),
    _mfExcludeNodes           (),
    _sfMapAutoUpdate          (bool(true)),
    _sfShadowMode             (UInt32(0)),
    _sfShadowSmoothness       (Real32(0.5)),
    _sfShadowOn               (bool(true)),
    _sfAutoSearchForLights    (bool(false)),
    _sfGlobalShadowIntensity  (Real32(0.0)),
    _sfFboOn                  (bool(true)),
    _sfAutoExcludeTransparentNodes(bool(true)),
    _sfDisableOccludedLights  (bool(false)),
    _sfRed                    (bool(GL_TRUE)),
    _sfBlue                   (bool(GL_TRUE)),
    _sfGreen                  (bool(GL_TRUE)),
    _sfAlpha                  (bool(GL_TRUE)),
    _sfBlitZBuffer            (bool(false)),
    _sfCombineBlend           (bool(false)),
    _sfRenderPropertyMask     (RenderPropBitVector(SystemRenderProperties.ColorBuffer)),
    _sfEnableMultiSample      (bool(false)),
    _sfColorSamples           (UInt32(4)),
    _sfCoverageSamples        (UInt32(4)),
    _sfFixedSampleLocation    (bool(true))
{
}

ShadowStageBase::ShadowStageBase(const ShadowStageBase &source) :
    Inherited(source),
    _sfBufferFormat           (source._sfBufferFormat           ),
    _sfOffBias                (source._sfOffBias                ),
    _sfOffFactor              (source._sfOffFactor              ),
    _sfMapSize                (source._sfMapSize                ),
    _mfLightNodes             (),
    _mfExcludeNodes           (),
    _sfMapAutoUpdate          (source._sfMapAutoUpdate          ),
    _sfShadowMode             (source._sfShadowMode             ),
    _sfShadowSmoothness       (source._sfShadowSmoothness       ),
    _sfShadowOn               (source._sfShadowOn               ),
    _sfAutoSearchForLights    (source._sfAutoSearchForLights    ),
    _sfGlobalShadowIntensity  (source._sfGlobalShadowIntensity  ),
    _sfFboOn                  (source._sfFboOn                  ),
    _sfAutoExcludeTransparentNodes(source._sfAutoExcludeTransparentNodes),
    _sfDisableOccludedLights  (source._sfDisableOccludedLights  ),
    _sfRed                    (source._sfRed                    ),
    _sfBlue                   (source._sfBlue                   ),
    _sfGreen                  (source._sfGreen                  ),
    _sfAlpha                  (source._sfAlpha                  ),
    _sfBlitZBuffer            (source._sfBlitZBuffer            ),
    _sfCombineBlend           (source._sfCombineBlend           ),
    _sfRenderPropertyMask     (source._sfRenderPropertyMask     ),
    _sfEnableMultiSample      (source._sfEnableMultiSample      ),
    _sfColorSamples           (source._sfColorSamples           ),
    _sfCoverageSamples        (source._sfCoverageSamples        ),
    _sfFixedSampleLocation    (source._sfFixedSampleLocation    )
{
}


/*-------------------------- destructors ----------------------------------*/

ShadowStageBase::~ShadowStageBase(void)
{
}

void ShadowStageBase::onCreate(const ShadowStage *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        ShadowStage *pThis = static_cast<ShadowStage *>(this);

        MFUnrecNodePtr::const_iterator LightNodesIt  =
            source->_mfLightNodes.begin();
        MFUnrecNodePtr::const_iterator LightNodesEnd =
            source->_mfLightNodes.end  ();

        while(LightNodesIt != LightNodesEnd)
        {
            pThis->pushToLightNodes(*LightNodesIt);

            ++LightNodesIt;
        }

        MFUnrecNodePtr::const_iterator ExcludeNodesIt  =
            source->_mfExcludeNodes.begin();
        MFUnrecNodePtr::const_iterator ExcludeNodesEnd =
            source->_mfExcludeNodes.end  ();

        while(ExcludeNodesIt != ExcludeNodesEnd)
        {
            pThis->pushToExcludeNodes(*ExcludeNodesIt);

            ++ExcludeNodesIt;
        }
    }
}

GetFieldHandlePtr ShadowStageBase::getHandleBufferFormat    (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfBufferFormat,
             this->getType().getFieldDesc(BufferFormatFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleBufferFormat   (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfBufferFormat,
             this->getType().getFieldDesc(BufferFormatFieldId),
             this));


    editSField(BufferFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleOffBias         (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffBias,
             this->getType().getFieldDesc(OffBiasFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleOffBias        (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffBias,
             this->getType().getFieldDesc(OffBiasFieldId),
             this));


    editSField(OffBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleOffFactor       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffFactor,
             this->getType().getFieldDesc(OffFactorFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleOffFactor      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffFactor,
             this->getType().getFieldDesc(OffFactorFieldId),
             this));


    editSField(OffFactorFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleMapSize         (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfMapSize,
             this->getType().getFieldDesc(MapSizeFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleMapSize        (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfMapSize,
             this->getType().getFieldDesc(MapSizeFieldId),
             this));


    editSField(MapSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleLightNodes      (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfLightNodes,
             this->getType().getFieldDesc(LightNodesFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleLightNodes     (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfLightNodes,
             this->getType().getFieldDesc(LightNodesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&ShadowStage::pushToLightNodes,
                    static_cast<ShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveMethod(
        boost::bind(&ShadowStage::removeFromLightNodes,
                    static_cast<ShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveObjMethod(
        boost::bind(&ShadowStage::removeObjFromLightNodes,
                    static_cast<ShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setClearMethod(
        boost::bind(&ShadowStage::clearLightNodes,
                    static_cast<ShadowStage *>(this)));

    editMField(LightNodesFieldMask, _mfLightNodes);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleExcludeNodes    (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfExcludeNodes,
             this->getType().getFieldDesc(ExcludeNodesFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleExcludeNodes   (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfExcludeNodes,
             this->getType().getFieldDesc(ExcludeNodesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&ShadowStage::pushToExcludeNodes,
                    static_cast<ShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveMethod(
        boost::bind(&ShadowStage::removeFromExcludeNodes,
                    static_cast<ShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setRemoveObjMethod(
        boost::bind(&ShadowStage::removeObjFromExcludeNodes,
                    static_cast<ShadowStage *>(this), ::boost::placeholders::_1));
    returnValue->setClearMethod(
        boost::bind(&ShadowStage::clearExcludeNodes,
                    static_cast<ShadowStage *>(this)));

    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleMapAutoUpdate   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfMapAutoUpdate,
             this->getType().getFieldDesc(MapAutoUpdateFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleMapAutoUpdate  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfMapAutoUpdate,
             this->getType().getFieldDesc(MapAutoUpdateFieldId),
             this));


    editSField(MapAutoUpdateFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleShadowMode      (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfShadowMode,
             this->getType().getFieldDesc(ShadowModeFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleShadowMode     (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfShadowMode,
             this->getType().getFieldDesc(ShadowModeFieldId),
             this));


    editSField(ShadowModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleShadowSmoothness (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfShadowSmoothness,
             this->getType().getFieldDesc(ShadowSmoothnessFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleShadowSmoothness(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfShadowSmoothness,
             this->getType().getFieldDesc(ShadowSmoothnessFieldId),
             this));


    editSField(ShadowSmoothnessFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleShadowOn        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfShadowOn,
             this->getType().getFieldDesc(ShadowOnFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleShadowOn       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfShadowOn,
             this->getType().getFieldDesc(ShadowOnFieldId),
             this));


    editSField(ShadowOnFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleAutoSearchForLights (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAutoSearchForLights,
             this->getType().getFieldDesc(AutoSearchForLightsFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleAutoSearchForLights(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAutoSearchForLights,
             this->getType().getFieldDesc(AutoSearchForLightsFieldId),
             this));


    editSField(AutoSearchForLightsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleGlobalShadowIntensity (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfGlobalShadowIntensity,
             this->getType().getFieldDesc(GlobalShadowIntensityFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleGlobalShadowIntensity(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfGlobalShadowIntensity,
             this->getType().getFieldDesc(GlobalShadowIntensityFieldId),
             this));


    editSField(GlobalShadowIntensityFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleFboOn           (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfFboOn,
             this->getType().getFieldDesc(FboOnFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleFboOn          (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfFboOn,
             this->getType().getFieldDesc(FboOnFieldId),
             this));


    editSField(FboOnFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleAutoExcludeTransparentNodes (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAutoExcludeTransparentNodes,
             this->getType().getFieldDesc(AutoExcludeTransparentNodesFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleAutoExcludeTransparentNodes(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAutoExcludeTransparentNodes,
             this->getType().getFieldDesc(AutoExcludeTransparentNodesFieldId),
             this));


    editSField(AutoExcludeTransparentNodesFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleDisableOccludedLights (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDisableOccludedLights,
             this->getType().getFieldDesc(DisableOccludedLightsFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleDisableOccludedLights(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDisableOccludedLights,
             this->getType().getFieldDesc(DisableOccludedLightsFieldId),
             this));


    editSField(DisableOccludedLightsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleRed             (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfRed,
             this->getType().getFieldDesc(RedFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleRed            (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfRed,
             this->getType().getFieldDesc(RedFieldId),
             this));


    editSField(RedFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleBlue            (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfBlue,
             this->getType().getFieldDesc(BlueFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleBlue           (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfBlue,
             this->getType().getFieldDesc(BlueFieldId),
             this));


    editSField(BlueFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleGreen           (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfGreen,
             this->getType().getFieldDesc(GreenFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleGreen          (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfGreen,
             this->getType().getFieldDesc(GreenFieldId),
             this));


    editSField(GreenFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleAlpha           (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAlpha,
             this->getType().getFieldDesc(AlphaFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleAlpha          (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAlpha,
             this->getType().getFieldDesc(AlphaFieldId),
             this));


    editSField(AlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleBlitZBuffer     (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfBlitZBuffer,
             this->getType().getFieldDesc(BlitZBufferFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleBlitZBuffer    (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfBlitZBuffer,
             this->getType().getFieldDesc(BlitZBufferFieldId),
             this));


    editSField(BlitZBufferFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleCombineBlend    (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfCombineBlend,
             this->getType().getFieldDesc(CombineBlendFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleCombineBlend   (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfCombineBlend,
             this->getType().getFieldDesc(CombineBlendFieldId),
             this));


    editSField(CombineBlendFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleRenderPropertyMask (void) const
{
    SFRenderPropBitVector::GetHandlePtr returnValue(
        new  SFRenderPropBitVector::GetHandle(
             &_sfRenderPropertyMask,
             this->getType().getFieldDesc(RenderPropertyMaskFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleRenderPropertyMask(void)
{
    SFRenderPropBitVector::EditHandlePtr returnValue(
        new  SFRenderPropBitVector::EditHandle(
             &_sfRenderPropertyMask,
             this->getType().getFieldDesc(RenderPropertyMaskFieldId),
             this));


    editSField(RenderPropertyMaskFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleEnableMultiSample (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfEnableMultiSample,
             this->getType().getFieldDesc(EnableMultiSampleFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleEnableMultiSample(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfEnableMultiSample,
             this->getType().getFieldDesc(EnableMultiSampleFieldId),
             this));


    editSField(EnableMultiSampleFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleColorSamples    (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfColorSamples,
             this->getType().getFieldDesc(ColorSamplesFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleColorSamples   (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfColorSamples,
             this->getType().getFieldDesc(ColorSamplesFieldId),
             this));


    editSField(ColorSamplesFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleCoverageSamples (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfCoverageSamples,
             this->getType().getFieldDesc(CoverageSamplesFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleCoverageSamples(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfCoverageSamples,
             this->getType().getFieldDesc(CoverageSamplesFieldId),
             this));


    editSField(CoverageSamplesFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleFixedSampleLocation (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfFixedSampleLocation,
             this->getType().getFieldDesc(FixedSampleLocationFieldId),
             const_cast<ShadowStageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleFixedSampleLocation(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfFixedSampleLocation,
             this->getType().getFieldDesc(FixedSampleLocationFieldId),
             this));


    editSField(FixedSampleLocationFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ShadowStageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    ShadowStage *pThis = static_cast<ShadowStage *>(this);

    pThis->execSync(static_cast<ShadowStage *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *ShadowStageBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    ShadowStage *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const ShadowStage *>(pRefAspect),
                  dynamic_cast<const ShadowStage *>(this));

    return returnValue;
}
#endif

void ShadowStageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<ShadowStage *>(this)->clearLightNodes();

    static_cast<ShadowStage *>(this)->clearExcludeNodes();


}


OSG_END_NAMESPACE
