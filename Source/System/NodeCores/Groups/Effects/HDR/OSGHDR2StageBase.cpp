/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2013 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 * contact: dirk@opensg.org, gerrit.voss@vossg.org, carsten_neumann@gmx.net  *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class HDR2Stage!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>

#ifdef WIN32 
#pragma warning(disable: 4355) // turn off 'this' : used in base member initializer list warning
#pragma warning(disable: 4290) // disable exception specification warning
#endif

#include "OSGConfig.h"


#include "OSGGLEXT.h"                     // ColorBufferInternalFormat default header
#include "OSGGLEXT.h"                     // ColorBufferPixelFormat default header
#include "OSGGLEXT.h"                     // ColorBufferType default header
#include "OSGGLEXT.h"                     // DepthBufferInternalFormat default header
#include "OSGGLEXT.h"                     // DepthBufferPixelFormat default header
#include "OSGGLEXT.h"                     // DepthBufferType default header
#include "OSGGLEXT.h"                     // LumBufferInternalFormat default header
#include "OSGGLEXT.h"                     // LumBufferPixelFormat default header
#include "OSGGLEXT.h"                     // LumBufferType default header
#include "OSGGLEXT.h"                     // ImageBufferInternalFormat default header
#include "OSGGLEXT.h"                     // ImageBufferPixelFormat default header
#include "OSGGLEXT.h"                     // ImageBufferType default header


#include "OSGHDR2StageBase.h"
#include "OSGHDR2Stage.h"

#include <boost/bind/bind.hpp>

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::HDR2Stage
    This HDR stage performs the complete post processing task from rendering into a HDR render buffer, calculating the
    average luminance of the scene, time adapting of the average luminance, tone mapping and blooming. Especially, it
    implements various tone mapping operators allowing to get comfortable with the different techniques available.

    Currently, only global average (geometric mean) of the luminace is implemented. Future version might implement
    local averaging methods (histogram).
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var bool            HDR2StageBase::_sfActivate
    If the stage is deactivated it does not perform any action on its own but act as a simple Group core.
*/

/*! \var bool            HDR2StageBase::_sfApplyGamma
    If set gamma correction is performed just before writing to the final
    draw buffer at the end of the pipeline.
*/

/*! \var bool            HDR2StageBase::_sfAccurateGamma
    If set correct gamma calculation is performed, i.e. respect linear near black.
    This parameter is only in use if parameter applyGamma is set to true.
    See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html 
    https://en.wikipedia.org/wiki/Gamma_correction
    http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/
    for reference.
*/

/*! \var Real32          HDR2StageBase::_sfGamma
    The gamma value used for the GAMMA correction calculation.
*/

/*! \var bool            HDR2StageBase::_sfAdjustLuminance
    Enable or disable time dependent luminance adaptation.
*/

/*! \var Real32          HDR2StageBase::_sfTau
    Adjusted luminance adaptation time parameter.
    Reasonable values are in the interval [0.f, 4.f].
    See http://www.cs.ucf.edu/~sumant/publications/sig00.pdf,
    http://www.cs.bris.ac.uk/Publications/Papers/2000126.pdf,
    and http://www.gamedev.net/topic/659990-adapting-luminance-map-no-adaptation-according-to-my-eye/
    for reference.
*/

/*! \var bool            HDR2StageBase::_sfPerformBloom
    If true a bloom / blur pass is performed, which can have a performance impact.
*/

/*! \var Real32          HDR2StageBase::_sfBloomThreshold
    The bloom threshold used in the brightness filter pass. Reasonable values are in the interval
    [0.f, 10.f].
*/

/*! \var bool            HDR2StageBase::_sfBloomBackground
    If set to true the background, i.e. fragments with depth value 1.0 are also bloomed. If render
    background is a solid background it might be preferable to exclude it from the blooming in order
    to avoid background color bleeding into the rendered geometry.
*/

/*! \var Real32          HDR2StageBase::_sfBloomMagnitude
    This value determines how much of the blooming is mixed into the final image. Reasonable values
    are in the interval [0.f, 2.f].
*/

/*! \var Int32           HDR2StageBase::_sfNumTaps
    Number if tap iterations used in the Bloom Blur shader. Reasonable values are in the interval [2, 10].
*/

/*! \var Real32          HDR2StageBase::_sfBlurGaussSigma
    The standard deviation of the gaussian normal distribution used in the blur pass. Reasonable values
    are in the interval [0.5f, 1.5f].
*/

/*! \var UInt32          HDR2StageBase::_sfToneMappingMode
    Tonemapping technique to use. Valid values are 
    NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, 
    REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTED2_TONE_MAPPING,
    FILMIC_ACES_TONE_MAPPING, FILMIC_HEJ2015_TONE_MAPPING

    For details about the different tone mapping techniques lookup the following references:
    Adaptive Logarithmic Mapping for Displaying High Contrast Scenes
    F. Drago, K. Myszkowski, T. Annen, and N. Chiba
    In Eurographics 2003 
    http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf

    Photographic Tone Reproduction for Digital Images
    Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda
    http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf

    http://filmicgames.com/archives/75
    http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff
*/

/*! \var bool            HDR2StageBase::_sfForceBackground
    If a normal color background is used it might be desirable to let the background not be paritcipating
    in the tone mapping procedure.
*/

/*! \var bool            HDR2StageBase::_sfUse_ITU_R_BT_709
    Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance
    according to the American NTSC coding system.
    See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.
*/

/*! \var UInt32          HDR2StageBase::_sfAutoExposureMode
    Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC, SATURATION_BASED and
    STANDARD_OUTPUT_BASED
*/

/*! \var Real32          HDR2StageBase::_sfExposure
    Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying 
    how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.
    Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.
    Reasonable values are in the interval [-10.f, 10.f]. 
*/

/*! \var Real32          HDR2StageBase::_sfKeyValue
    This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the 
    scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used
    for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.
    Reasonable values are in the interval [0.f, 1.f]. 
    See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.
*/

/*! \var Real32          HDR2StageBase::_sfApertureFNumber
    The f-number of an optical system such as a camera lens is the ratio of the system's focal length to 
    the diameter of the entrance pupil. N = f/D, with focal length of the lens f and diameter of the pupil
    (effective aperture) D. This value is used only for the autoExposureMode modes SATURATION_BASED and
    STANDARD_OUTPUT_BASED.
*/

/*! \var Real32          HDR2StageBase::_sfShutterSpeed
    A measure of the film exposure time given in reciprocal seconds.
    This value is used only for the autoExposureMode modes SATURATION_BASED and
    STANDARD_OUTPUT_BASED.
*/

/*! \var Real32          HDR2StageBase::_sfISO
    Film speed is the measure of a photographic film's sensitivity to light.
    This value is used only for the autoExposureMode modes SATURATION_BASED and
    STANDARD_OUTPUT_BASED.
*/

/*! \var Real32          HDR2StageBase::_sfWhiteLevel
    This parameter is the smallest luminance that will be mapped to pure white. It is used in the
    following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.
    Reasonable values are in the interval [0.f, 25.f]. 
    See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.
*/

/*! \var Real32          HDR2StageBase::_sfSaturation
    This parameter allows to control the satuarion of the tone mapped scene. It allows color
    correction applied after tone mapping.
    Reasonable values are in the interval [0.f, 4.f]. 
    See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.
*/

/*! \var bool            HDR2StageBase::_sfUseLinChromCorrection
    Use a linear chromatic correction function. This works with parameter 'saturation'.
    See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.
*/

/*! \var Color3f         HDR2StageBase::_sfFilterColor
    The filter color is multiplied to the scene after exposure correction but before to the
    tone mapping operation.
    See http://filmicworlds.com/blog/minimal-color-grading-tools/
*/

/*! \var Real32          HDR2StageBase::_sfContrast
    The standard contrast operation simply pushes colors away from grey. The operation is
    performed before tone mapping in sRGB space.
    See http://filmicworlds.com/blog/minimal-color-grading-tools/
*/

/*! \var Color3f         HDR2StageBase::_sfShadowLiftColor
    This color allows the adjustment of dark scene colors.
    The lift color is calculated from this color and the corresponding
    offset value.
    See http://filmicworlds.com/blog/minimal-color-grading-tools/
*/

/*! \var Color3f         HDR2StageBase::_sfMidToneGammaColor
    This color allows the adjustment of the mid tone scene colors.
    The mid tone color is calculated from this color and the corresponding
    offset value.
    See http://filmicworlds.com/blog/minimal-color-grading-tools/
*/

/*! \var Color3f         HDR2StageBase::_sfHighlightGainColor
    This color allows the adjustment of highlight scene colors.
    The gain color is calculated from this color and the corresponding
    offset value.
    See http://filmicworlds.com/blog/minimal-color-grading-tools/
*/

/*! \var Real32          HDR2StageBase::_mfFilmicCurveParameters
    This multi real field does contain special parameters for the filmic curve
    introduced by John Hable which are based on the Kodak film curve. 
    These parameters are used for the FILMIC_UNCHARTED2_TONE_MAPPING
    mode. Please do get not to be confused with the FILMIC_HABLE_TONE_MAPPING
    mode that does not have any external parameters in this implementation.

    See:
    http://filmicgames.com/archives/75
    http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff

    It is expected that this multi real field does contain the following Real32 entries
    in the given order with the given default values and reasonable intervals:
    filmicShoulderStrenght       0.15f  [0.f, 2.f]
    filmicLinearStrength         0.5f   [0.f, 5.f]
    filmicLinearAngle            0.1f   [0.f, 1.f]
    filmicToeStrength            0.2f   [0.f, 2.f]
    filmicToeNumerator           0.02f  [0.f, 0.5f]
    filmicToeDenominator         0.3f   [0.f, 2.f]
    filmicLinearWhite           11.2f   [0.f, 20.f]
*/

/*! \var Real32          HDR2StageBase::_sfDragoBias
    The bias function is a power function defined over the unit interval, 
    an intuitive parameter dragoBias remaps an input value to a higher or lower value.
    This parameter is only used by the drago_logarithmic tone mapping technique.
    Reasonable values are in the interval [0.f, 1.f]. 
    See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.
*/

/*! \var UInt32          HDR2StageBase::_sfTarget
    This convenience parameter allows to redirect the intermediate texture image results
    to the final screen instead of the default COMPOSITE_TEXTURE which represents the
    final rendering result of this stage. This is useful for debugging purpose.
    Reasonable values are SCENE_TEXTURE, BACKGROUND_TEXTURE, INITIAL_LUMINANCE_TEXTURE,
    ADAPTED_LUMINANCE_TEXTURE, BLOOM_TEXTURE, BLURRED_TEXTURE, COMPOSITE_TEXTURE, 
    EXPOSURE_TEXTURE, DEPTH_TEXTURE, LINEARIZED_DEPTH_TEXTURE
*/

/*! \var bool            HDR2StageBase::_sfPerformDithering
    If true the final color will be dithered.
*/

/*! \var bool            HDR2StageBase::_sfCarryDepth
    If set the scene depth values are carried to the final render target. Useful if post rendering operations are necessary.
*/

/*! \var GLenum          HDR2StageBase::_sfColorBufferInternalFormat
    Internal format used for hdr color buffer. Defaults to GL_RGBA16F.
*/

/*! \var GLenum          HDR2StageBase::_sfColorBufferPixelFormat
    Pixel format used for hdr color buffer. Defaults to GL_RGBA.
*/

/*! \var GLenum          HDR2StageBase::_sfColorBufferType
    Type used for hdr color buffer. Defaults to GL_FLOAT.
*/

/*! \var GLenum          HDR2StageBase::_sfDepthBufferInternalFormat
    Internal format used for depth buffer. Defaults to GL_DEPTH24_STENCIL8.
*/

/*! \var GLenum          HDR2StageBase::_sfDepthBufferPixelFormat
    Pixel format used for hdr depth buffer. Defaults to GL_DEPTH_STENCIL.
*/

/*! \var GLenum          HDR2StageBase::_sfDepthBufferType
    Type used for hdr depth buffer. Defaults to GL_UNSIGNED_INT_24_8.
*/

/*! \var GLenum          HDR2StageBase::_sfLumBufferInternalFormat
    Internal format used for luminance calculation. Defaults to GL_R32F.
*/

/*! \var GLenum          HDR2StageBase::_sfLumBufferPixelFormat
    Pixel format used for hdr lum buffer. Defaults to GL_RED.
*/

/*! \var GLenum          HDR2StageBase::_sfLumBufferType
    Type used for hdr lum buffer. Defaults to GL_FLOAT.
*/

/*! \var GLenum          HDR2StageBase::_sfImageBufferInternalFormat
    Internal format used for hdr image color buffer. Defaults to GL_RGBA16F.
*/

/*! \var GLenum          HDR2StageBase::_sfImageBufferPixelFormat
    Pixel format used for hdr image color buffer. Defaults to GL_RGB.
*/

/*! \var GLenum          HDR2StageBase::_sfImageBufferType
    Type used for hdr image color buffer. Defaults to GL_FLOAT.
*/

/*! \var Int32           HDR2StageBase::_sfNumSamples
    Number of multi samples to use. If 0 no multisampling is performed. which does save the resolve pass.
*/

/*! \var Int32           HDR2StageBase::_sfMipmapLevel
    The mipmap Level to use for accessing the average luminance map. Normally, this value is set to -1 which
    means that the highest mipmap level is used. This corresponds to the 1 pixel mipmap texture lookup. Other
    values are meant for testing purposes only.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
PointerType FieldTraits<HDR2Stage *, nsOSG>::_type(
    "HDR2StagePtr", 
    "StagePtr", 
    HDR2Stage::getClassType(),
    nsOSG);
#endif

OSG_FIELDTRAITS_GETTYPE_NS(HDR2Stage *, nsOSG)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           HDR2Stage *,
                           nsOSG)

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           HDR2Stage *,
                           nsOSG)

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void HDR2StageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "activate",
        "If the stage is deactivated it does not perform any action on its own but act as a simple Group core.\n",
        ActivateFieldId, ActivateFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleActivate),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleActivate));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "applyGamma",
        "If set gamma correction is performed just before writing to the final\n"
        "draw buffer at the end of the pipeline.\n",
        ApplyGammaFieldId, ApplyGammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleApplyGamma),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleApplyGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "accurateGamma",
        "If set correct gamma calculation is performed, i.e. respect linear near black.\n"
        "This parameter is only in use if parameter applyGamma is set to true.\n"
        "See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html \n"
        "https://en.wikipedia.org/wiki/Gamma_correction\n"
        "http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/\n"
        "for reference.\n",
        AccurateGammaFieldId, AccurateGammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleAccurateGamma),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleAccurateGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "gamma",
        "The gamma value used for the GAMMA correction calculation.\n",
        GammaFieldId, GammaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleGamma),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleGamma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "adjustLuminance",
        "Enable or disable time dependent luminance adaptation.\n",
        AdjustLuminanceFieldId, AdjustLuminanceFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleAdjustLuminance),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleAdjustLuminance));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "tau",
        "Adjusted luminance adaptation time parameter.\n"
        "Reasonable values are in the interval [0.f, 4.f].\n"
        "See http://www.cs.ucf.edu/~sumant/publications/sig00.pdf,\n"
        "http://www.cs.bris.ac.uk/Publications/Papers/2000126.pdf,\n"
        "and http://www.gamedev.net/topic/659990-adapting-luminance-map-no-adaptation-according-to-my-eye/\n"
        "for reference.\n",
        TauFieldId, TauFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleTau),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleTau));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "performBloom",
        "If true a bloom / blur pass is performed, which can have a performance impact.\n",
        PerformBloomFieldId, PerformBloomFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandlePerformBloom),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandlePerformBloom));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "bloomThreshold",
        "The bloom threshold used in the brightness filter pass. Reasonable values are in the interval\n"
        "[0.f, 10.f].\n",
        BloomThresholdFieldId, BloomThresholdFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBloomThreshold),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBloomThreshold));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "bloomBackground",
        "If set to true the background, i.e. fragments with depth value 1.0 are also bloomed. If render\n"
        "background is a solid background it might be preferable to exclude it from the blooming in order\n"
        "to avoid background color bleeding into the rendered geometry.\n",
        BloomBackgroundFieldId, BloomBackgroundFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBloomBackground),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBloomBackground));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "bloomMagnitude",
        "This value determines how much of the blooming is mixed into the final image. Reasonable values\n"
        "are in the interval [0.f, 2.f].\n",
        BloomMagnitudeFieldId, BloomMagnitudeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBloomMagnitude),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBloomMagnitude));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numTaps",
        "Number if tap iterations used in the Bloom Blur shader. Reasonable values are in the interval [2, 10].\n",
        NumTapsFieldId, NumTapsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleNumTaps),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleNumTaps));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "blurGaussSigma",
        "The standard deviation of the gaussian normal distribution used in the blur pass. Reasonable values\n"
        "are in the interval [0.5f, 1.5f].\n",
        BlurGaussSigmaFieldId, BlurGaussSigmaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleBlurGaussSigma),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleBlurGaussSigma));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "toneMappingMode",
        "Tonemapping technique to use. Valid values are \n"
        "NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, \n"
        "REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTED2_TONE_MAPPING,\n"
        "FILMIC_ACES_TONE_MAPPING, FILMIC_HEJ2015_TONE_MAPPING\n"
        "\n"
        "For details about the different tone mapping techniques lookup the following references:\n"
        "Adaptive Logarithmic Mapping for Displaying High Contrast Scenes\n"
        "F. Drago, K. Myszkowski, T. Annen, and N. Chiba\n"
        "In Eurographics 2003 \n"
        "http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\n"
        "\n"
        "Photographic Tone Reproduction for Digital Images\n"
        "Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda\n"
        "http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\n"
        "\n"
        "http://filmicgames.com/archives/75\n"
        "http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
        "\n"
        "High Dynamic Range Imaging\n"
        "Aquisition, Display, and Image-Based Lighing\n"
        "Erik Reinhard et al.\n"
        "Second Edition 2010\n"
        "ISBN 978-0-12-374914-7\n",
        ToneMappingModeFieldId, ToneMappingModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleToneMappingMode),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleToneMappingMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceBackground",
        "If a normal color background is used it might be desirable to let the background not be paritcipating\n"
        "in the tone mapping procedure.\n",
        ForceBackgroundFieldId, ForceBackgroundFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleForceBackground),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleForceBackground));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "use_ITU_R_BT_709",
        "Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance\n"
        "according to the American NTSC coding system.\n"
        "See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.\n",
        Use_ITU_R_BT_709FieldId, Use_ITU_R_BT_709FieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleUse_ITU_R_BT_709),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleUse_ITU_R_BT_709));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "autoExposureMode",
        "Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC, SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED\n"
        "\n"
        "If set to manual mode the Exposure parameter is used directly. If key value mode is set the KeyValue is\n"
        "used for calculation of the used exposure value. If mode is set to automatic, then the KeyValue is also\n"
        "automatically calculated from the average luminance of the scene. The key value is a scalar that controls \n"
        "how brightly or darkly the algorithm will expose your scene. The remaining modes are based on\n"
        "the article \n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
        "and calculate the exposure value from ApertureFNumber, ShutterSpeedValue and ISO film value.\n",
        AutoExposureModeFieldId, AutoExposureModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleAutoExposureMode),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleAutoExposureMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "exposure",
        "Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying \n"
        "how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.\n"
        "Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.\n"
        "Reasonable values are in the interval [-10.f, 10.f]. \n",
        ExposureFieldId, ExposureFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleExposure),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleExposure));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "keyValue",
        "This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the \n"
        "scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used\n"
        "for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.\n"
        "Reasonable values are in the interval [0.f, 1.f]. \n"
        "See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n",
        KeyValueFieldId, KeyValueFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleKeyValue),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleKeyValue));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "apertureFNumber",
        "The f-number of an optical system such as a camera lens is the ratio of the system's focal length to \n"
        "the diameter of the entrance pupil. N = f/D, with focal length of the lens f and diameter of the pupil\n"
        "(effective aperture) D. This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED.\n"
        "\n"
        "See also: https://en.wikipedia.org/wiki/F-number\n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n",
        ApertureFNumberFieldId, ApertureFNumberFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleApertureFNumber),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleApertureFNumber));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shutterSpeed",
        "A measure of the film exposure time given in reciprocal seconds.\n"
        "This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED.\n"
        "\n"
        "See also: https://en.wikipedia.org/wiki/F-number\n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n",
        ShutterSpeedFieldId, ShutterSpeedFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleShutterSpeed),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleShutterSpeed));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "ISO",
        "Film speed is the measure of a photographic film's sensitivity to light.\n"
        "This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
        "STANDARD_OUTPUT_BASED.\n"
        "\n"
        "See also: https://en.wikipedia.org/wiki/Film_speed\n"
        "https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n",
        ISOFieldId, ISOFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleISO),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleISO));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "whiteLevel",
        "This parameter is the smallest luminance that will be mapped to pure white. It is used in the\n"
        "following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.\n"
        "Reasonable values are in the interval [0.f, 25.f]. \n"
        "See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n",
        WhiteLevelFieldId, WhiteLevelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleWhiteLevel),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleWhiteLevel));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "saturation",
        "This parameter allows to control the satuarion of the tone mapped scene. It allows color\n"
        "correction applied after tone mapping.\n"
        "Reasonable values are in the interval [0.f, 4.f]. \n"
        "See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n",
        SaturationFieldId, SaturationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleSaturation),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleSaturation));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "useLinChromCorrection",
        "Use a linear chromatic correction function. This works with parameter 'saturation'.\n"
        "See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n",
        UseLinChromCorrectionFieldId, UseLinChromCorrectionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleUseLinChromCorrection),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleUseLinChromCorrection));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "filterColor",
        "The filter color is multiplied to the scene after exposure correction but before to the\n"
        "tone mapping operation.\n"
        "See http://filmicworlds.com/blog/minimal-color-grading-tools/\n",
        FilterColorFieldId, FilterColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilterColor),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilterColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "contrast",
        "The standard contrast operation simply pushes colors away from grey. The operation is\n"
        "performed before tone mapping in sRGB space.\n"
        "See http://filmicworlds.com/blog/minimal-color-grading-tools/\n",
        ContrastFieldId, ContrastFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleContrast),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleContrast));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "ShadowLiftColor",
        "This color allows the adjustment of dark scene colors.\n"
        "The lift color is calculated from this color and the corresponding\n"
        "offset value.\n"
        "See http://filmicworlds.com/blog/minimal-color-grading-tools/\n",
        ShadowLiftColorFieldId, ShadowLiftColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleShadowLiftColor),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleShadowLiftColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "MidToneGammaColor",
        "This color allows the adjustment of the mid tone scene colors.\n"
        "The mid tone color is calculated from this color and the corresponding\n"
        "offset value.\n"
        "See http://filmicworlds.com/blog/minimal-color-grading-tools/\n",
        MidToneGammaColorFieldId, MidToneGammaColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleMidToneGammaColor),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleMidToneGammaColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor3f::Description(
        SFColor3f::getClassType(),
        "HighlightGainColor",
        "This color allows the adjustment of highlight scene colors.\n"
        "The gain color is calculated from this color and the corresponding\n"
        "offset value.\n"
        "See http://filmicworlds.com/blog/minimal-color-grading-tools/\n",
        HighlightGainColorFieldId, HighlightGainColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleHighlightGainColor),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleHighlightGainColor));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "filmicCurveParameters",
        "This multi real field does contain special parameters for the filmic curve\n"
        "introduced by John Hable which are based on the Kodak film curve. \n"
        "These parameters are used for the FILMIC_UNCHARTED2_TONE_MAPPING\n"
        "mode. Please do get not to be confused with the FILMIC_HABLE_TONE_MAPPING\n"
        "mode that does not have any external parameters in this implementation.\n"
        "\n"
        "See:\n"
        "http://filmicgames.com/archives/75\n"
        "http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
        "\n"
        "It is expected that this multi real field does contain the following Real32 entries\n"
        "in the given order with the given default values and reasonable intervals:\n"
        "filmicShoulderStrenght       0.15f  [0.f, 2.f]\n"
        "filmicLinearStrength         0.5f   [0.f, 5.f]\n"
        "filmicLinearAngle            0.1f   [0.f, 1.f]\n"
        "filmicToeStrength            0.2f   [0.f, 2.f]\n"
        "filmicToeNumerator           0.02f  [0.f, 0.5f]\n"
        "filmicToeDenominator         0.3f   [0.f, 2.f]\n"
        "filmicLinearWhite           11.2f   [0.f, 20.f]\n"
        "\n"
        "If the multi field is only partial filled the default values are taken for the remaing\n"
        "parameters. The implementation does provide interfaces to set the parameters separately.\n",
        FilmicCurveParametersFieldId, FilmicCurveParametersFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleFilmicCurveParameters),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleFilmicCurveParameters));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "dragoBias",
        "The bias function is a power function defined over the unit interval, \n"
        "an intuitive parameter dragoBias remaps an input value to a higher or lower value.\n"
        "This parameter is only used by the drago_logarithmic tone mapping technique.\n"
        "Reasonable values are in the interval [0.f, 1.f]. \n"
        "See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.\n",
        DragoBiasFieldId, DragoBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDragoBias),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDragoBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "target",
        "This convenience parameter allows to redirect the intermediate texture image results\n"
        "to the final screen instead of the default COMPOSITE_TEXTURE which represents the\n"
        "final rendering result of this stage. This is useful for debugging purpose.\n"
        "Reasonable values are SCENE_TEXTURE, BACKGROUND_TEXTURE, INITIAL_LUMINANCE_TEXTURE,\n"
        "ADAPTED_LUMINANCE_TEXTURE, BLOOM_TEXTURE, BLURRED_TEXTURE, COMPOSITE_TEXTURE, \n"
        "EXPOSURE_TEXTURE, DEPTH_TEXTURE, LINEARIZED_DEPTH_TEXTURE\n",
        TargetFieldId, TargetFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleTarget),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleTarget));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "performDithering",
        "If true the final color will be dithered.\n",
        PerformDitheringFieldId, PerformDitheringFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandlePerformDithering),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandlePerformDithering));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "carryDepth",
        "If set the scene depth values are carried to the final render target. Useful if post rendering operations are necessary.\n",
        CarryDepthFieldId, CarryDepthFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleCarryDepth),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleCarryDepth));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "colorBufferInternalFormat",
        "Internal format used for hdr color buffer. Defaults to GL_RGBA16F.\n",
        ColorBufferInternalFormatFieldId, ColorBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleColorBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleColorBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "colorBufferPixelFormat",
        "Pixel format used for hdr color buffer. Defaults to GL_RGBA.\n",
        ColorBufferPixelFormatFieldId, ColorBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleColorBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleColorBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "colorBufferType",
        "Type used for hdr color buffer. Defaults to GL_FLOAT.\n",
        ColorBufferTypeFieldId, ColorBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleColorBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleColorBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthBufferInternalFormat",
        "Internal format used for depth buffer. Defaults to GL_DEPTH24_STENCIL8.\n",
        DepthBufferInternalFormatFieldId, DepthBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDepthBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDepthBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthBufferPixelFormat",
        "Pixel format used for hdr depth buffer. Defaults to GL_DEPTH_STENCIL.\n",
        DepthBufferPixelFormatFieldId, DepthBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDepthBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDepthBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthBufferType",
        "Type used for hdr depth buffer. Defaults to GL_UNSIGNED_INT_24_8.\n",
        DepthBufferTypeFieldId, DepthBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleDepthBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleDepthBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "lumBufferInternalFormat",
        "Internal format used for luminance calculation. Defaults to GL_R32F.\n",
        LumBufferInternalFormatFieldId, LumBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleLumBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleLumBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "lumBufferPixelFormat",
        "Pixel format used for hdr lum buffer. Defaults to GL_RED.\n",
        LumBufferPixelFormatFieldId, LumBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleLumBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleLumBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "lumBufferType",
        "Type used for hdr lum buffer. Defaults to GL_FLOAT.\n",
        LumBufferTypeFieldId, LumBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleLumBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleLumBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "imageBufferInternalFormat",
        "Internal format used for hdr image color buffer. Defaults to GL_RGBA16F.\n",
        ImageBufferInternalFormatFieldId, ImageBufferInternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleImageBufferInternalFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleImageBufferInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "imageBufferPixelFormat",
        "Pixel format used for hdr image color buffer. Defaults to GL_RGB.\n",
        ImageBufferPixelFormatFieldId, ImageBufferPixelFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleImageBufferPixelFormat),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleImageBufferPixelFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "imageBufferType",
        "Type used for hdr image color buffer. Defaults to GL_FLOAT.\n",
        ImageBufferTypeFieldId, ImageBufferTypeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleImageBufferType),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleImageBufferType));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numSamples",
        "Number of multi samples to use. If 0 no multisampling is performed. which does save the resolve pass.\n",
        NumSamplesFieldId, NumSamplesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleNumSamples),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleNumSamples));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "mipmapLevel",
        "The mipmap Level to use for accessing the average luminance map. Normally, this value is set to -1 which\n"
        "means that the highest mipmap level is used. This corresponds to the 1 pixel mipmap texture lookup. Other\n"
        "values are meant for testing purposes only.\n",
        MipmapLevelFieldId, MipmapLevelFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&HDR2Stage::editHandleMipmapLevel),
        static_cast<FieldGetMethodSig >(&HDR2Stage::getHandleMipmapLevel));

    oType.addInitialDesc(pDesc);
}


HDR2StageBase::TypeObject HDR2StageBase::_type(
    HDR2StageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    nsOSG, //Namespace
    reinterpret_cast<PrototypeCreateF>(&HDR2StageBase::createEmptyLocal),
    reinterpret_cast<InitContainerF>(&HDR2Stage::initMethod),
    reinterpret_cast<ExitContainerF>(&HDR2Stage::exitMethod),
    reinterpret_cast<InitalInsertDescFunc>(
        reinterpret_cast<void *>(&HDR2Stage::classDescInserter)),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "    name=\"HDR2Stage\"\n"
    "    parent=\"Stage\"\n"
    "    library=\"EffectGroups\"\n"
    "    pointerfieldtypes=\"both\"\n"
    "    structure=\"concrete\"\n"
    "    systemcomponent=\"true\"\n"
    "    parentsystemcomponent=\"true\"\n"
    "    decoratable=\"false\"\n"
    "    useLocalIncludes=\"false\"\n"
    "    isNodeCore=\"true\"\n"
    "    isBundle=\"false\"\n"
    "    docGroupBase=\"GrpEffectsGroupsHDR\"\n"
    "    >\n"
    "    This HDR stage performs the complete post processing task from rendering into a HDR render buffer, calculating the\n"
    "    average luminance of the scene, time adapting of the average luminance, tone mapping and blooming. Especially, it\n"
    "    implements various tone mapping operators allowing to get comfortable with the different techniques available.\n"
    "\n"
    "    Currently, only global average (geometric mean) of the luminace is implemented. Future version might implement\n"
    "    local averaging methods (histogram).\n"
    "\n"
    "    <Field\n"
    "        name=\"activate\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If the stage is deactivated it does not perform any action on its own but act as a simple Group core.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"applyGamma\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If set gamma correction is performed just before writing to the final\n"
    "        draw buffer at the end of the pipeline.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"accurateGamma\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If set correct gamma calculation is performed, i.e. respect linear near black.\n"
    "        This parameter is only in use if parameter applyGamma is set to true.\n"
    "        See http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html \n"
    "        https://en.wikipedia.org/wiki/Gamma_correction\n"
    "        http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/\n"
    "        for reference.\n"
    "    </Field>\n"
    "    \n"
    "    <Field\n"
    "        name=\"gamma\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"2.2f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The gamma value used for the GAMMA correction calculation.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"adjustLuminance\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Enable or disable time dependent luminance adaptation.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"tau\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.25f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Adjusted luminance adaptation time parameter.\n"
    "        Reasonable values are in the interval [0.f, 4.f].\n"
    "        See http://www.cs.ucf.edu/~sumant/publications/sig00.pdf,\n"
    "        http://www.cs.bris.ac.uk/Publications/Papers/2000126.pdf,\n"
    "        and http://www.gamedev.net/topic/659990-adapting-luminance-map-no-adaptation-according-to-my-eye/\n"
    "        for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"performBloom\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If true a bloom / blur pass is performed, which can have a performance impact.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"bloomThreshold\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"2.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The bloom threshold used in the brightness filter pass. Reasonable values are in the interval\n"
    "        [0.f, 10.f].\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"bloomBackground\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If set to true the background, i.e. fragments with depth value 1.0 are also bloomed. If render\n"
    "        background is a solid background it might be preferable to exclude it from the blooming in order\n"
    "        to avoid background color bleeding into the rendered geometry.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"bloomMagnitude\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This value determines how much of the blooming is mixed into the final image. Reasonable values\n"
    "        are in the interval [0.f, 2.f].\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"numTaps\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"4\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Number if tap iterations used in the Bloom Blur shader. Reasonable values are in the interval [2, 10].\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"blurGaussSigma\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.8f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The standard deviation of the gaussian normal distribution used in the blur pass. Reasonable values\n"
    "        are in the interval [0.5f, 1.5f].\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"toneMappingMode\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"4\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Tonemapping technique to use. Valid values are \n"
    "        NO_TONE_MAPPING, LOGARITHMIC_TONE_MAPPING, EXPONENTIAL_TONE_MAPPING, DRAGO_LOGARITHMIC_TONE_MAPPING, \n"
    "        REINHARD_TONE_MAPPING, REINHARD_MODIFIED_TONE_MAPPING, FILMIC_HABLE_TONE_MAPPING, FILMIC_UNCHARTED2_TONE_MAPPING,\n"
    "        FILMIC_ACES_TONE_MAPPING, FILMIC_HEJ2015_TONE_MAPPING\n"
    "\n"
    "        For details about the different tone mapping techniques lookup the following references:\n"
    "        Adaptive Logarithmic Mapping for Displaying High Contrast Scenes\n"
    "        F. Drago, K. Myszkowski, T. Annen, and N. Chiba\n"
    "        In Eurographics 2003 \n"
    "        http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf\n"
    "\n"
    "        Photographic Tone Reproduction for Digital Images\n"
    "        Erik Reinhard, Michael Stark, Peter Shirley, James Ferwerda\n"
    "        http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\n"
    "\n"
    "        http://filmicgames.com/archives/75\n"
    "        http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
    "\n"
    "        High Dynamic Range Imaging\n"
    "        Aquisition, Display, and Image-Based Lighing\n"
    "        Erik Reinhard et al.\n"
    "        Second Edition 2010\n"
    "        ISBN 978-0-12-374914-7\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"forceBackground\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If a normal color background is used it might be desirable to let the background not be paritcipating\n"
    "        in the tone mapping procedure.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"use_ITU_R_BT_709\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Calculate linear Y luminance from ITU-BT-709 to CIE XYZ if set to true. Otherwise calculate  linearY luminance\n"
    "        according to the American NTSC coding system.\n"
    "        See  http://www.poynton.com/ColorFAQ.html and http://www.poynton.com/PDFs/coloureq.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"autoExposureMode\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"2\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Three exposure working modes are allowed: MANUAL, KEY_VALUE, AUTOMATIC, SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED\n"
    "\n"
    "        If set to manual mode the Exposure parameter is used directly. If key value mode is set the KeyValue is\n"
    "        used for calculation of the used exposure value. If mode is set to automatic, then the KeyValue is also\n"
    "        automatically calculated from the average luminance of the scene. The key value is a scalar that controls \n"
    "        how brightly or darkly the algorithm will expose your scene. The remaining modes are based on\n"
    "        the article \n"
    "        https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "        and calculate the exposure value from ApertureFNumber, ShutterSpeedValue and ISO film value.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"exposure\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Exposure mimics the camera shutter time. You're controlling how much light hits the film by modifying \n"
    "        how long the shutter stays open. This parameter is only valid if the auto exposure mode is set to MANUAL.\n"
    "        Otherwise it is calculated either by the keyValue parameter or directly by the luminance of the scene.\n"
    "        Reasonable values are in the interval [-10.f, 10.f]. \n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"keyValue\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.18f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This parameter is mimics the mood of the scene. It is meant to be chosen based on whether the \n"
    "        scene is high-key (bright, low contrast) or low-key (dark, high contrast). This value is used\n"
    "        for calculating a proper exposure value given that the auto exposure mode is set to KEY_VALUE.\n"
    "        Reasonable values are in the interval [0.f, 1.f]. \n"
    "        See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"apertureFNumber\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"16.0f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The f-number of an optical system such as a camera lens is the ratio of the system's focal length to \n"
    "        the diameter of the entrance pupil. N = f/D, with focal length of the lens f and diameter of the pupil\n"
    "        (effective aperture) D. This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED.\n"
    "\n"
    "        See also: https://en.wikipedia.org/wiki/F-number\n"
    "                  https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"shutterSpeed\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.01f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        A measure of the film exposure time given in reciprocal seconds.\n"
    "        This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED.\n"
    "\n"
    "        See also: https://en.wikipedia.org/wiki/F-number\n"
    "                  https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"ISO\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"100.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Film speed is the measure of a photographic film's sensitivity to light.\n"
    "        This value is used only for the autoExposureMode modes SATURATION_BASED and\n"
    "        STANDARD_OUTPUT_BASED.\n"
    "\n"
    "        See also: https://en.wikipedia.org/wiki/Film_speed\n"
    "                  https://placeholderart.wordpress.com/2014/11/21/implementing-a-physically-based-camera-manual-exposure/\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"whiteLevel\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"5.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This parameter is the smallest luminance that will be mapped to pure white. It is used in the\n"
    "        following tone mapping techiques: logarithmic, exponential, drago_logarithmic and reinhard_modified.\n"
    "        Reasonable values are in the interval [0.f, 25.f]. \n"
    "        See http://www.cis.rit.edu/jaf/publications/sig02_paper.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"saturation\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This parameter allows to control the satuarion of the tone mapped scene. It allows color\n"
    "        correction applied after tone mapping.\n"
    "        Reasonable values are in the interval [0.f, 4.f]. \n"
    "        See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"useLinChromCorrection\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Use a linear chromatic correction function. This works with parameter 'saturation'.\n"
    "        See https://www.cs.ubc.ca/~heidrich/Papers/EG.09_1.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"filterColor\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"Color3f(1.f,1.f,1.f)\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The filter color is multiplied to the scene after exposure correction but before to the\n"
    "        tone mapping operation.\n"
    "        See http://filmicworlds.com/blog/minimal-color-grading-tools/\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"contrast\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The standard contrast operation simply pushes colors away from grey. The operation is\n"
    "        performed before tone mapping in sRGB space.\n"
    "        See http://filmicworlds.com/blog/minimal-color-grading-tools/\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"ShadowLiftColor\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"Color3f(0.5f,0.5f,0.5f)\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This color allows the adjustment of dark scene colors.\n"
    "        The lift color is calculated from this color and the corresponding\n"
    "        offset value.\n"
    "        See http://filmicworlds.com/blog/minimal-color-grading-tools/\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"MidToneGammaColor\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"Color3f(0.5f,0.5f,0.5f)\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This color allows the adjustment of the mid tone scene colors.\n"
    "        The mid tone color is calculated from this color and the corresponding\n"
    "        offset value.\n"
    "        See http://filmicworlds.com/blog/minimal-color-grading-tools/\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"HighlightGainColor\"\n"
    "        type=\"Color3f\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"Color3f(0.5f,0.5f,0.5f)\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This color allows the adjustment of highlight scene colors.\n"
    "        The gain color is calculated from this color and the corresponding\n"
    "        offset value.\n"
    "        See http://filmicworlds.com/blog/minimal-color-grading-tools/\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"filmicCurveParameters\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"multi\"\n"
    "        visibility=\"external\"\n"
    "        access=\"protected\"\n"
    "        >\n"
    "        This multi real field does contain special parameters for the filmic curve\n"
    "        introduced by John Hable which are based on the Kodak film curve. \n"
    "        These parameters are used for the FILMIC_UNCHARTED2_TONE_MAPPING\n"
    "        mode. Please do get not to be confused with the FILMIC_HABLE_TONE_MAPPING\n"
    "        mode that does not have any external parameters in this implementation.\n"
    "\n"
    "        See:\n"
    "            http://filmicgames.com/archives/75\n"
    "            http://de.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting slide 53ff\n"
    "\n"
    "        It is expected that this multi real field does contain the following Real32 entries\n"
    "        in the given order with the given default values and reasonable intervals:\n"
    "            filmicShoulderStrenght       0.15f  [0.f, 2.f]\n"
    "            filmicLinearStrength         0.5f   [0.f, 5.f]\n"
    "            filmicLinearAngle            0.1f   [0.f, 1.f]\n"
    "            filmicToeStrength            0.2f   [0.f, 2.f]\n"
    "            filmicToeNumerator           0.02f  [0.f, 0.5f]\n"
    "            filmicToeDenominator         0.3f   [0.f, 2.f]\n"
    "            filmicLinearWhite           11.2f   [0.f, 20.f]\n"
    "\n"
    "        If the multi field is only partial filled the default values are taken for the remaing\n"
    "        parameters. The implementation does provide interfaces to set the parameters separately.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"dragoBias\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"0.85f\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The bias function is a power function defined over the unit interval, \n"
    "        an intuitive parameter dragoBias remaps an input value to a higher or lower value.\n"
    "        This parameter is only used by the drago_logarithmic tone mapping technique.\n"
    "        Reasonable values are in the interval [0.f, 1.f]. \n"
    "        See http://resources.mpi-inf.mpg.de/tmo/logmap/logmap.pdf for reference.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"target\"\n"
    "        type=\"UInt32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"6\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        This convenience parameter allows to redirect the intermediate texture image results\n"
    "        to the final screen instead of the default COMPOSITE_TEXTURE which represents the\n"
    "        final rendering result of this stage. This is useful for debugging purpose.\n"
    "        Reasonable values are SCENE_TEXTURE, BACKGROUND_TEXTURE, INITIAL_LUMINANCE_TEXTURE,\n"
    "        ADAPTED_LUMINANCE_TEXTURE, BLOOM_TEXTURE, BLURRED_TEXTURE, COMPOSITE_TEXTURE, \n"
    "        EXPOSURE_TEXTURE, DEPTH_TEXTURE, LINEARIZED_DEPTH_TEXTURE\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"performDithering\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"false\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If true the final color will be dithered.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"carryDepth\"\n"
    "        type=\"bool\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"true\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        If set the scene depth values are carried to the final render target. Useful if post rendering operations are necessary.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"colorBufferInternalFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_RGBA16F\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Internal format used for hdr color buffer. Defaults to GL_RGBA16F.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"colorBufferPixelFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_RGBA\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Pixel format used for hdr color buffer. Defaults to GL_RGBA.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"colorBufferType\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_FLOAT\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Type used for hdr color buffer. Defaults to GL_FLOAT.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"depthBufferInternalFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_DEPTH24_STENCIL8\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Internal format used for depth buffer. Defaults to GL_DEPTH24_STENCIL8.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"depthBufferPixelFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_DEPTH_STENCIL\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Pixel format used for hdr depth buffer. Defaults to GL_DEPTH_STENCIL.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"depthBufferType\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_UNSIGNED_INT_24_8\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Type used for hdr depth buffer. Defaults to GL_UNSIGNED_INT_24_8.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lumBufferInternalFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_R32F\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Internal format used for luminance calculation. Defaults to GL_R32F.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lumBufferPixelFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_RED\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Pixel format used for hdr lum buffer. Defaults to GL_RED.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"lumBufferType\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_FLOAT\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Type used for hdr lum buffer. Defaults to GL_FLOAT.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"imageBufferInternalFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_RGB16F\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Internal format used for hdr image color buffer. Defaults to GL_RGBA16F.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"imageBufferPixelFormat\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_RGB\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Pixel format used for hdr image color buffer. Defaults to GL_RGB.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"imageBufferType\"\n"
    "        type=\"GLenum\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"GL_FLOAT\"\n"
    "        defaultHeader=\"&quot;OSGGLEXT.h&quot;\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Type used for hdr image color buffer. Defaults to GL_FLOAT.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"numSamples\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"4\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        Number of multi samples to use. If 0 no multisampling is performed. which does save the resolve pass.\n"
    "    </Field>\n"
    "\n"
    "    <Field\n"
    "        name=\"mipmapLevel\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "        >\n"
    "        The mipmap Level to use for accessing the average luminance map. Normally, this value is set to -1 which\n"
    "        means that the highest mipmap level is used. This corresponds to the 1 pixel mipmap texture lookup. Other\n"
    "        values are meant for testing purposes only.\n"
    "    </Field>\n"
    "\n"
    "</FieldContainer>\n",
    "This HDR stage performs the complete post processing task from rendering into a HDR render buffer, calculating the\n"
    "average luminance of the scene, time adapting of the average luminance, tone mapping and blooming. Especially, it\n"
    "implements various tone mapping operators allowing to get comfortable with the different techniques available.\n"
    "\n"
    "Currently, only global average (geometric mean) of the luminace is implemented. Future version might implement\n"
    "local averaging methods (histogram).\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &HDR2StageBase::getType(void)
{
    return _type;
}

const FieldContainerType &HDR2StageBase::getType(void) const
{
    return _type;
}

UInt32 HDR2StageBase::getContainerSize(void) const
{
    return sizeof(HDR2Stage);
}

/*------------------------- decorator get ------------------------------*/


SFBool *HDR2StageBase::editSFActivate(void)
{
    editSField(ActivateFieldMask);

    return &_sfActivate;
}

const SFBool *HDR2StageBase::getSFActivate(void) const
{
    return &_sfActivate;
}


SFBool *HDR2StageBase::editSFApplyGamma(void)
{
    editSField(ApplyGammaFieldMask);

    return &_sfApplyGamma;
}

const SFBool *HDR2StageBase::getSFApplyGamma(void) const
{
    return &_sfApplyGamma;
}


SFBool *HDR2StageBase::editSFAccurateGamma(void)
{
    editSField(AccurateGammaFieldMask);

    return &_sfAccurateGamma;
}

const SFBool *HDR2StageBase::getSFAccurateGamma(void) const
{
    return &_sfAccurateGamma;
}


SFReal32 *HDR2StageBase::editSFGamma(void)
{
    editSField(GammaFieldMask);

    return &_sfGamma;
}

const SFReal32 *HDR2StageBase::getSFGamma(void) const
{
    return &_sfGamma;
}


SFBool *HDR2StageBase::editSFAdjustLuminance(void)
{
    editSField(AdjustLuminanceFieldMask);

    return &_sfAdjustLuminance;
}

const SFBool *HDR2StageBase::getSFAdjustLuminance(void) const
{
    return &_sfAdjustLuminance;
}


SFReal32 *HDR2StageBase::editSFTau(void)
{
    editSField(TauFieldMask);

    return &_sfTau;
}

const SFReal32 *HDR2StageBase::getSFTau(void) const
{
    return &_sfTau;
}


SFBool *HDR2StageBase::editSFPerformBloom(void)
{
    editSField(PerformBloomFieldMask);

    return &_sfPerformBloom;
}

const SFBool *HDR2StageBase::getSFPerformBloom(void) const
{
    return &_sfPerformBloom;
}


SFReal32 *HDR2StageBase::editSFBloomThreshold(void)
{
    editSField(BloomThresholdFieldMask);

    return &_sfBloomThreshold;
}

const SFReal32 *HDR2StageBase::getSFBloomThreshold(void) const
{
    return &_sfBloomThreshold;
}


SFBool *HDR2StageBase::editSFBloomBackground(void)
{
    editSField(BloomBackgroundFieldMask);

    return &_sfBloomBackground;
}

const SFBool *HDR2StageBase::getSFBloomBackground(void) const
{
    return &_sfBloomBackground;
}


SFReal32 *HDR2StageBase::editSFBloomMagnitude(void)
{
    editSField(BloomMagnitudeFieldMask);

    return &_sfBloomMagnitude;
}

const SFReal32 *HDR2StageBase::getSFBloomMagnitude(void) const
{
    return &_sfBloomMagnitude;
}


SFInt32 *HDR2StageBase::editSFNumTaps(void)
{
    editSField(NumTapsFieldMask);

    return &_sfNumTaps;
}

const SFInt32 *HDR2StageBase::getSFNumTaps(void) const
{
    return &_sfNumTaps;
}


SFReal32 *HDR2StageBase::editSFBlurGaussSigma(void)
{
    editSField(BlurGaussSigmaFieldMask);

    return &_sfBlurGaussSigma;
}

const SFReal32 *HDR2StageBase::getSFBlurGaussSigma(void) const
{
    return &_sfBlurGaussSigma;
}


SFUInt32 *HDR2StageBase::editSFToneMappingMode(void)
{
    editSField(ToneMappingModeFieldMask);

    return &_sfToneMappingMode;
}

const SFUInt32 *HDR2StageBase::getSFToneMappingMode(void) const
{
    return &_sfToneMappingMode;
}


SFBool *HDR2StageBase::editSFForceBackground(void)
{
    editSField(ForceBackgroundFieldMask);

    return &_sfForceBackground;
}

const SFBool *HDR2StageBase::getSFForceBackground(void) const
{
    return &_sfForceBackground;
}


SFBool *HDR2StageBase::editSFUse_ITU_R_BT_709(void)
{
    editSField(Use_ITU_R_BT_709FieldMask);

    return &_sfUse_ITU_R_BT_709;
}

const SFBool *HDR2StageBase::getSFUse_ITU_R_BT_709(void) const
{
    return &_sfUse_ITU_R_BT_709;
}


SFUInt32 *HDR2StageBase::editSFAutoExposureMode(void)
{
    editSField(AutoExposureModeFieldMask);

    return &_sfAutoExposureMode;
}

const SFUInt32 *HDR2StageBase::getSFAutoExposureMode(void) const
{
    return &_sfAutoExposureMode;
}


SFReal32 *HDR2StageBase::editSFExposure(void)
{
    editSField(ExposureFieldMask);

    return &_sfExposure;
}

const SFReal32 *HDR2StageBase::getSFExposure(void) const
{
    return &_sfExposure;
}


SFReal32 *HDR2StageBase::editSFKeyValue(void)
{
    editSField(KeyValueFieldMask);

    return &_sfKeyValue;
}

const SFReal32 *HDR2StageBase::getSFKeyValue(void) const
{
    return &_sfKeyValue;
}


SFReal32 *HDR2StageBase::editSFApertureFNumber(void)
{
    editSField(ApertureFNumberFieldMask);

    return &_sfApertureFNumber;
}

const SFReal32 *HDR2StageBase::getSFApertureFNumber(void) const
{
    return &_sfApertureFNumber;
}


SFReal32 *HDR2StageBase::editSFShutterSpeed(void)
{
    editSField(ShutterSpeedFieldMask);

    return &_sfShutterSpeed;
}

const SFReal32 *HDR2StageBase::getSFShutterSpeed(void) const
{
    return &_sfShutterSpeed;
}


SFReal32 *HDR2StageBase::editSFISO(void)
{
    editSField(ISOFieldMask);

    return &_sfISO;
}

const SFReal32 *HDR2StageBase::getSFISO(void) const
{
    return &_sfISO;
}


SFReal32 *HDR2StageBase::editSFWhiteLevel(void)
{
    editSField(WhiteLevelFieldMask);

    return &_sfWhiteLevel;
}

const SFReal32 *HDR2StageBase::getSFWhiteLevel(void) const
{
    return &_sfWhiteLevel;
}


SFReal32 *HDR2StageBase::editSFSaturation(void)
{
    editSField(SaturationFieldMask);

    return &_sfSaturation;
}

const SFReal32 *HDR2StageBase::getSFSaturation(void) const
{
    return &_sfSaturation;
}


SFBool *HDR2StageBase::editSFUseLinChromCorrection(void)
{
    editSField(UseLinChromCorrectionFieldMask);

    return &_sfUseLinChromCorrection;
}

const SFBool *HDR2StageBase::getSFUseLinChromCorrection(void) const
{
    return &_sfUseLinChromCorrection;
}


SFColor3f *HDR2StageBase::editSFFilterColor(void)
{
    editSField(FilterColorFieldMask);

    return &_sfFilterColor;
}

const SFColor3f *HDR2StageBase::getSFFilterColor(void) const
{
    return &_sfFilterColor;
}


SFReal32 *HDR2StageBase::editSFContrast(void)
{
    editSField(ContrastFieldMask);

    return &_sfContrast;
}

const SFReal32 *HDR2StageBase::getSFContrast(void) const
{
    return &_sfContrast;
}


SFColor3f *HDR2StageBase::editSFShadowLiftColor(void)
{
    editSField(ShadowLiftColorFieldMask);

    return &_sfShadowLiftColor;
}

const SFColor3f *HDR2StageBase::getSFShadowLiftColor(void) const
{
    return &_sfShadowLiftColor;
}


SFColor3f *HDR2StageBase::editSFMidToneGammaColor(void)
{
    editSField(MidToneGammaColorFieldMask);

    return &_sfMidToneGammaColor;
}

const SFColor3f *HDR2StageBase::getSFMidToneGammaColor(void) const
{
    return &_sfMidToneGammaColor;
}


SFColor3f *HDR2StageBase::editSFHighlightGainColor(void)
{
    editSField(HighlightGainColorFieldMask);

    return &_sfHighlightGainColor;
}

const SFColor3f *HDR2StageBase::getSFHighlightGainColor(void) const
{
    return &_sfHighlightGainColor;
}


MFReal32 *HDR2StageBase::editMFFilmicCurveParameters(void)
{
    editMField(FilmicCurveParametersFieldMask, _mfFilmicCurveParameters);

    return &_mfFilmicCurveParameters;
}

const MFReal32 *HDR2StageBase::getMFFilmicCurveParameters(void) const
{
    return &_mfFilmicCurveParameters;
}


SFReal32 *HDR2StageBase::editSFDragoBias(void)
{
    editSField(DragoBiasFieldMask);

    return &_sfDragoBias;
}

const SFReal32 *HDR2StageBase::getSFDragoBias(void) const
{
    return &_sfDragoBias;
}


SFUInt32 *HDR2StageBase::editSFTarget(void)
{
    editSField(TargetFieldMask);

    return &_sfTarget;
}

const SFUInt32 *HDR2StageBase::getSFTarget(void) const
{
    return &_sfTarget;
}


SFBool *HDR2StageBase::editSFPerformDithering(void)
{
    editSField(PerformDitheringFieldMask);

    return &_sfPerformDithering;
}

const SFBool *HDR2StageBase::getSFPerformDithering(void) const
{
    return &_sfPerformDithering;
}


SFBool *HDR2StageBase::editSFCarryDepth(void)
{
    editSField(CarryDepthFieldMask);

    return &_sfCarryDepth;
}

const SFBool *HDR2StageBase::getSFCarryDepth(void) const
{
    return &_sfCarryDepth;
}


SFGLenum *HDR2StageBase::editSFColorBufferInternalFormat(void)
{
    editSField(ColorBufferInternalFormatFieldMask);

    return &_sfColorBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFColorBufferInternalFormat(void) const
{
    return &_sfColorBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFColorBufferPixelFormat(void)
{
    editSField(ColorBufferPixelFormatFieldMask);

    return &_sfColorBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFColorBufferPixelFormat(void) const
{
    return &_sfColorBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFColorBufferType(void)
{
    editSField(ColorBufferTypeFieldMask);

    return &_sfColorBufferType;
}

const SFGLenum *HDR2StageBase::getSFColorBufferType(void) const
{
    return &_sfColorBufferType;
}


SFGLenum *HDR2StageBase::editSFDepthBufferInternalFormat(void)
{
    editSField(DepthBufferInternalFormatFieldMask);

    return &_sfDepthBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFDepthBufferInternalFormat(void) const
{
    return &_sfDepthBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFDepthBufferPixelFormat(void)
{
    editSField(DepthBufferPixelFormatFieldMask);

    return &_sfDepthBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFDepthBufferPixelFormat(void) const
{
    return &_sfDepthBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFDepthBufferType(void)
{
    editSField(DepthBufferTypeFieldMask);

    return &_sfDepthBufferType;
}

const SFGLenum *HDR2StageBase::getSFDepthBufferType(void) const
{
    return &_sfDepthBufferType;
}


SFGLenum *HDR2StageBase::editSFLumBufferInternalFormat(void)
{
    editSField(LumBufferInternalFormatFieldMask);

    return &_sfLumBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFLumBufferInternalFormat(void) const
{
    return &_sfLumBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFLumBufferPixelFormat(void)
{
    editSField(LumBufferPixelFormatFieldMask);

    return &_sfLumBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFLumBufferPixelFormat(void) const
{
    return &_sfLumBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFLumBufferType(void)
{
    editSField(LumBufferTypeFieldMask);

    return &_sfLumBufferType;
}

const SFGLenum *HDR2StageBase::getSFLumBufferType(void) const
{
    return &_sfLumBufferType;
}


SFGLenum *HDR2StageBase::editSFImageBufferInternalFormat(void)
{
    editSField(ImageBufferInternalFormatFieldMask);

    return &_sfImageBufferInternalFormat;
}

const SFGLenum *HDR2StageBase::getSFImageBufferInternalFormat(void) const
{
    return &_sfImageBufferInternalFormat;
}


SFGLenum *HDR2StageBase::editSFImageBufferPixelFormat(void)
{
    editSField(ImageBufferPixelFormatFieldMask);

    return &_sfImageBufferPixelFormat;
}

const SFGLenum *HDR2StageBase::getSFImageBufferPixelFormat(void) const
{
    return &_sfImageBufferPixelFormat;
}


SFGLenum *HDR2StageBase::editSFImageBufferType(void)
{
    editSField(ImageBufferTypeFieldMask);

    return &_sfImageBufferType;
}

const SFGLenum *HDR2StageBase::getSFImageBufferType(void) const
{
    return &_sfImageBufferType;
}


SFInt32 *HDR2StageBase::editSFNumSamples(void)
{
    editSField(NumSamplesFieldMask);

    return &_sfNumSamples;
}

const SFInt32 *HDR2StageBase::getSFNumSamples(void) const
{
    return &_sfNumSamples;
}


SFInt32 *HDR2StageBase::editSFMipmapLevel(void)
{
    editSField(MipmapLevelFieldMask);

    return &_sfMipmapLevel;
}

const SFInt32 *HDR2StageBase::getSFMipmapLevel(void) const
{
    return &_sfMipmapLevel;
}






/*------------------------------ access -----------------------------------*/

SizeT HDR2StageBase::getBinSize(ConstFieldMaskArg whichField)
{
    SizeT returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ActivateFieldMask & whichField))
    {
        returnValue += _sfActivate.getBinSize();
    }
    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        returnValue += _sfApplyGamma.getBinSize();
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        returnValue += _sfAccurateGamma.getBinSize();
    }
    if(FieldBits::NoField != (GammaFieldMask & whichField))
    {
        returnValue += _sfGamma.getBinSize();
    }
    if(FieldBits::NoField != (AdjustLuminanceFieldMask & whichField))
    {
        returnValue += _sfAdjustLuminance.getBinSize();
    }
    if(FieldBits::NoField != (TauFieldMask & whichField))
    {
        returnValue += _sfTau.getBinSize();
    }
    if(FieldBits::NoField != (PerformBloomFieldMask & whichField))
    {
        returnValue += _sfPerformBloom.getBinSize();
    }
    if(FieldBits::NoField != (BloomThresholdFieldMask & whichField))
    {
        returnValue += _sfBloomThreshold.getBinSize();
    }
    if(FieldBits::NoField != (BloomBackgroundFieldMask & whichField))
    {
        returnValue += _sfBloomBackground.getBinSize();
    }
    if(FieldBits::NoField != (BloomMagnitudeFieldMask & whichField))
    {
        returnValue += _sfBloomMagnitude.getBinSize();
    }
    if(FieldBits::NoField != (NumTapsFieldMask & whichField))
    {
        returnValue += _sfNumTaps.getBinSize();
    }
    if(FieldBits::NoField != (BlurGaussSigmaFieldMask & whichField))
    {
        returnValue += _sfBlurGaussSigma.getBinSize();
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        returnValue += _sfToneMappingMode.getBinSize();
    }
    if(FieldBits::NoField != (ForceBackgroundFieldMask & whichField))
    {
        returnValue += _sfForceBackground.getBinSize();
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        returnValue += _sfUse_ITU_R_BT_709.getBinSize();
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        returnValue += _sfAutoExposureMode.getBinSize();
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        returnValue += _sfExposure.getBinSize();
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        returnValue += _sfKeyValue.getBinSize();
    }
    if(FieldBits::NoField != (ApertureFNumberFieldMask & whichField))
    {
        returnValue += _sfApertureFNumber.getBinSize();
    }
    if(FieldBits::NoField != (ShutterSpeedFieldMask & whichField))
    {
        returnValue += _sfShutterSpeed.getBinSize();
    }
    if(FieldBits::NoField != (ISOFieldMask & whichField))
    {
        returnValue += _sfISO.getBinSize();
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        returnValue += _sfWhiteLevel.getBinSize();
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        returnValue += _sfSaturation.getBinSize();
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        returnValue += _sfUseLinChromCorrection.getBinSize();
    }
    if(FieldBits::NoField != (FilterColorFieldMask & whichField))
    {
        returnValue += _sfFilterColor.getBinSize();
    }
    if(FieldBits::NoField != (ContrastFieldMask & whichField))
    {
        returnValue += _sfContrast.getBinSize();
    }
    if(FieldBits::NoField != (ShadowLiftColorFieldMask & whichField))
    {
        returnValue += _sfShadowLiftColor.getBinSize();
    }
    if(FieldBits::NoField != (MidToneGammaColorFieldMask & whichField))
    {
        returnValue += _sfMidToneGammaColor.getBinSize();
    }
    if(FieldBits::NoField != (HighlightGainColorFieldMask & whichField))
    {
        returnValue += _sfHighlightGainColor.getBinSize();
    }
    if(FieldBits::NoField != (FilmicCurveParametersFieldMask & whichField))
    {
        returnValue += _mfFilmicCurveParameters.getBinSize();
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        returnValue += _sfDragoBias.getBinSize();
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        returnValue += _sfTarget.getBinSize();
    }
    if(FieldBits::NoField != (PerformDitheringFieldMask & whichField))
    {
        returnValue += _sfPerformDithering.getBinSize();
    }
    if(FieldBits::NoField != (CarryDepthFieldMask & whichField))
    {
        returnValue += _sfCarryDepth.getBinSize();
    }
    if(FieldBits::NoField != (ColorBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfColorBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ColorBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfColorBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (ColorBufferTypeFieldMask & whichField))
    {
        returnValue += _sfColorBufferType.getBinSize();
    }
    if(FieldBits::NoField != (DepthBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfDepthBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (DepthBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfDepthBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (DepthBufferTypeFieldMask & whichField))
    {
        returnValue += _sfDepthBufferType.getBinSize();
    }
    if(FieldBits::NoField != (LumBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfLumBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (LumBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfLumBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (LumBufferTypeFieldMask & whichField))
    {
        returnValue += _sfLumBufferType.getBinSize();
    }
    if(FieldBits::NoField != (ImageBufferInternalFormatFieldMask & whichField))
    {
        returnValue += _sfImageBufferInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ImageBufferPixelFormatFieldMask & whichField))
    {
        returnValue += _sfImageBufferPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (ImageBufferTypeFieldMask & whichField))
    {
        returnValue += _sfImageBufferType.getBinSize();
    }
    if(FieldBits::NoField != (NumSamplesFieldMask & whichField))
    {
        returnValue += _sfNumSamples.getBinSize();
    }
    if(FieldBits::NoField != (MipmapLevelFieldMask & whichField))
    {
        returnValue += _sfMipmapLevel.getBinSize();
    }

    return returnValue;
}

void HDR2StageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ActivateFieldMask & whichField))
    {
        _sfActivate.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        _sfApplyGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        _sfAccurateGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GammaFieldMask & whichField))
    {
        _sfGamma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AdjustLuminanceFieldMask & whichField))
    {
        _sfAdjustLuminance.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TauFieldMask & whichField))
    {
        _sfTau.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PerformBloomFieldMask & whichField))
    {
        _sfPerformBloom.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BloomThresholdFieldMask & whichField))
    {
        _sfBloomThreshold.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BloomBackgroundFieldMask & whichField))
    {
        _sfBloomBackground.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BloomMagnitudeFieldMask & whichField))
    {
        _sfBloomMagnitude.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumTapsFieldMask & whichField))
    {
        _sfNumTaps.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BlurGaussSigmaFieldMask & whichField))
    {
        _sfBlurGaussSigma.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        _sfToneMappingMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceBackgroundFieldMask & whichField))
    {
        _sfForceBackground.copyToBin(pMem);
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        _sfUse_ITU_R_BT_709.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        _sfAutoExposureMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        _sfExposure.copyToBin(pMem);
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        _sfKeyValue.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ApertureFNumberFieldMask & whichField))
    {
        _sfApertureFNumber.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShutterSpeedFieldMask & whichField))
    {
        _sfShutterSpeed.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ISOFieldMask & whichField))
    {
        _sfISO.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        _sfWhiteLevel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        _sfSaturation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        _sfUseLinChromCorrection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilterColorFieldMask & whichField))
    {
        _sfFilterColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ContrastFieldMask & whichField))
    {
        _sfContrast.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowLiftColorFieldMask & whichField))
    {
        _sfShadowLiftColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MidToneGammaColorFieldMask & whichField))
    {
        _sfMidToneGammaColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HighlightGainColorFieldMask & whichField))
    {
        _sfHighlightGainColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FilmicCurveParametersFieldMask & whichField))
    {
        _mfFilmicCurveParameters.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        _sfDragoBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        _sfTarget.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PerformDitheringFieldMask & whichField))
    {
        _sfPerformDithering.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CarryDepthFieldMask & whichField))
    {
        _sfCarryDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferInternalFormatFieldMask & whichField))
    {
        _sfColorBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferPixelFormatFieldMask & whichField))
    {
        _sfColorBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferTypeFieldMask & whichField))
    {
        _sfColorBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferInternalFormatFieldMask & whichField))
    {
        _sfDepthBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferPixelFormatFieldMask & whichField))
    {
        _sfDepthBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferTypeFieldMask & whichField))
    {
        _sfDepthBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferInternalFormatFieldMask & whichField))
    {
        _sfLumBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferPixelFormatFieldMask & whichField))
    {
        _sfLumBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferTypeFieldMask & whichField))
    {
        _sfLumBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferInternalFormatFieldMask & whichField))
    {
        _sfImageBufferInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferPixelFormatFieldMask & whichField))
    {
        _sfImageBufferPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferTypeFieldMask & whichField))
    {
        _sfImageBufferType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumSamplesFieldMask & whichField))
    {
        _sfNumSamples.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MipmapLevelFieldMask & whichField))
    {
        _sfMipmapLevel.copyToBin(pMem);
    }
}

void HDR2StageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ActivateFieldMask & whichField))
    {
        editSField(ActivateFieldMask);
        _sfActivate.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ApplyGammaFieldMask & whichField))
    {
        editSField(ApplyGammaFieldMask);
        _sfApplyGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AccurateGammaFieldMask & whichField))
    {
        editSField(AccurateGammaFieldMask);
        _sfAccurateGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GammaFieldMask & whichField))
    {
        editSField(GammaFieldMask);
        _sfGamma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AdjustLuminanceFieldMask & whichField))
    {
        editSField(AdjustLuminanceFieldMask);
        _sfAdjustLuminance.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TauFieldMask & whichField))
    {
        editSField(TauFieldMask);
        _sfTau.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PerformBloomFieldMask & whichField))
    {
        editSField(PerformBloomFieldMask);
        _sfPerformBloom.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BloomThresholdFieldMask & whichField))
    {
        editSField(BloomThresholdFieldMask);
        _sfBloomThreshold.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BloomBackgroundFieldMask & whichField))
    {
        editSField(BloomBackgroundFieldMask);
        _sfBloomBackground.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BloomMagnitudeFieldMask & whichField))
    {
        editSField(BloomMagnitudeFieldMask);
        _sfBloomMagnitude.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumTapsFieldMask & whichField))
    {
        editSField(NumTapsFieldMask);
        _sfNumTaps.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BlurGaussSigmaFieldMask & whichField))
    {
        editSField(BlurGaussSigmaFieldMask);
        _sfBlurGaussSigma.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ToneMappingModeFieldMask & whichField))
    {
        editSField(ToneMappingModeFieldMask);
        _sfToneMappingMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceBackgroundFieldMask & whichField))
    {
        editSField(ForceBackgroundFieldMask);
        _sfForceBackground.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (Use_ITU_R_BT_709FieldMask & whichField))
    {
        editSField(Use_ITU_R_BT_709FieldMask);
        _sfUse_ITU_R_BT_709.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoExposureModeFieldMask & whichField))
    {
        editSField(AutoExposureModeFieldMask);
        _sfAutoExposureMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExposureFieldMask & whichField))
    {
        editSField(ExposureFieldMask);
        _sfExposure.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (KeyValueFieldMask & whichField))
    {
        editSField(KeyValueFieldMask);
        _sfKeyValue.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ApertureFNumberFieldMask & whichField))
    {
        editSField(ApertureFNumberFieldMask);
        _sfApertureFNumber.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShutterSpeedFieldMask & whichField))
    {
        editSField(ShutterSpeedFieldMask);
        _sfShutterSpeed.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ISOFieldMask & whichField))
    {
        editSField(ISOFieldMask);
        _sfISO.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WhiteLevelFieldMask & whichField))
    {
        editSField(WhiteLevelFieldMask);
        _sfWhiteLevel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SaturationFieldMask & whichField))
    {
        editSField(SaturationFieldMask);
        _sfSaturation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (UseLinChromCorrectionFieldMask & whichField))
    {
        editSField(UseLinChromCorrectionFieldMask);
        _sfUseLinChromCorrection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilterColorFieldMask & whichField))
    {
        editSField(FilterColorFieldMask);
        _sfFilterColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ContrastFieldMask & whichField))
    {
        editSField(ContrastFieldMask);
        _sfContrast.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowLiftColorFieldMask & whichField))
    {
        editSField(ShadowLiftColorFieldMask);
        _sfShadowLiftColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MidToneGammaColorFieldMask & whichField))
    {
        editSField(MidToneGammaColorFieldMask);
        _sfMidToneGammaColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HighlightGainColorFieldMask & whichField))
    {
        editSField(HighlightGainColorFieldMask);
        _sfHighlightGainColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FilmicCurveParametersFieldMask & whichField))
    {
        editMField(FilmicCurveParametersFieldMask, _mfFilmicCurveParameters);
        _mfFilmicCurveParameters.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DragoBiasFieldMask & whichField))
    {
        editSField(DragoBiasFieldMask);
        _sfDragoBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        editSField(TargetFieldMask);
        _sfTarget.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PerformDitheringFieldMask & whichField))
    {
        editSField(PerformDitheringFieldMask);
        _sfPerformDithering.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CarryDepthFieldMask & whichField))
    {
        editSField(CarryDepthFieldMask);
        _sfCarryDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferInternalFormatFieldMask & whichField))
    {
        editSField(ColorBufferInternalFormatFieldMask);
        _sfColorBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferPixelFormatFieldMask & whichField))
    {
        editSField(ColorBufferPixelFormatFieldMask);
        _sfColorBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorBufferTypeFieldMask & whichField))
    {
        editSField(ColorBufferTypeFieldMask);
        _sfColorBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferInternalFormatFieldMask & whichField))
    {
        editSField(DepthBufferInternalFormatFieldMask);
        _sfDepthBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferPixelFormatFieldMask & whichField))
    {
        editSField(DepthBufferPixelFormatFieldMask);
        _sfDepthBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthBufferTypeFieldMask & whichField))
    {
        editSField(DepthBufferTypeFieldMask);
        _sfDepthBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferInternalFormatFieldMask & whichField))
    {
        editSField(LumBufferInternalFormatFieldMask);
        _sfLumBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferPixelFormatFieldMask & whichField))
    {
        editSField(LumBufferPixelFormatFieldMask);
        _sfLumBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LumBufferTypeFieldMask & whichField))
    {
        editSField(LumBufferTypeFieldMask);
        _sfLumBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferInternalFormatFieldMask & whichField))
    {
        editSField(ImageBufferInternalFormatFieldMask);
        _sfImageBufferInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferPixelFormatFieldMask & whichField))
    {
        editSField(ImageBufferPixelFormatFieldMask);
        _sfImageBufferPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ImageBufferTypeFieldMask & whichField))
    {
        editSField(ImageBufferTypeFieldMask);
        _sfImageBufferType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumSamplesFieldMask & whichField))
    {
        editSField(NumSamplesFieldMask);
        _sfNumSamples.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MipmapLevelFieldMask & whichField))
    {
        editSField(MipmapLevelFieldMask);
        _sfMipmapLevel.copyFromBin(pMem);
    }
}

//! create a new instance of the class
HDR2StageTransitPtr HDR2StageBase::createLocal(BitVector bFlags)
{
    HDR2StageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<HDR2Stage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
HDR2StageTransitPtr HDR2StageBase::createDependent(BitVector bFlags)
{
    HDR2StageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<HDR2Stage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
HDR2StageTransitPtr HDR2StageBase::create(void)
{
    HDR2StageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<HDR2Stage>(tmpPtr);
    }

    return fc;
}

HDR2Stage *HDR2StageBase::createEmptyLocal(BitVector bFlags)
{
    HDR2Stage *returnValue;

    newPtr<HDR2Stage>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
HDR2Stage *HDR2StageBase::createEmpty(void)
{
    HDR2Stage *returnValue;

    newPtr<HDR2Stage>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr HDR2StageBase::shallowCopyLocal(
    BitVector bFlags) const
{
    HDR2Stage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const HDR2Stage *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr HDR2StageBase::shallowCopyDependent(
    BitVector bFlags) const
{
    HDR2Stage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const HDR2Stage *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr HDR2StageBase::shallowCopy(void) const
{
    HDR2Stage *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const HDR2Stage *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

HDR2StageBase::HDR2StageBase(void) :
    Inherited(),
    _sfActivate               (bool(true)),
    _sfApplyGamma             (bool(true)),
    _sfAccurateGamma          (bool(true)),
    _sfGamma                  (Real32(2.2f)),
    _sfAdjustLuminance        (bool(true)),
    _sfTau                    (Real32(1.25f)),
    _sfPerformBloom           (bool(true)),
    _sfBloomThreshold         (Real32(2.f)),
    _sfBloomBackground        (bool(true)),
    _sfBloomMagnitude         (Real32(0.f)),
    _sfNumTaps                (Int32(4)),
    _sfBlurGaussSigma         (Real32(0.8f)),
    _sfToneMappingMode        (UInt32(4)),
    _sfForceBackground        (bool(false)),
    _sfUse_ITU_R_BT_709       (bool(true)),
    _sfAutoExposureMode       (UInt32(2)),
    _sfExposure               (Real32(0.f)),
    _sfKeyValue               (Real32(0.18f)),
    _sfApertureFNumber        (Real32(16.0f)),
    _sfShutterSpeed           (Real32(0.01f)),
    _sfISO                    (Real32(100.f)),
    _sfWhiteLevel             (Real32(5.f)),
    _sfSaturation             (Real32(1.f)),
    _sfUseLinChromCorrection  (bool(true)),
    _sfFilterColor            (Color3f(Color3f(1.f,1.f,1.f))),
    _sfContrast               (Real32(1.f)),
    _sfShadowLiftColor        (Color3f(Color3f(0.5f,0.5f,0.5f))),
    _sfMidToneGammaColor      (Color3f(Color3f(0.5f,0.5f,0.5f))),
    _sfHighlightGainColor     (Color3f(Color3f(0.5f,0.5f,0.5f))),
    _mfFilmicCurveParameters  (),
    _sfDragoBias              (Real32(0.85f)),
    _sfTarget                 (UInt32(6)),
    _sfPerformDithering       (bool(false)),
    _sfCarryDepth             (bool(true)),
    _sfColorBufferInternalFormat(GLenum(GL_RGBA16F)),
    _sfColorBufferPixelFormat (GLenum(GL_RGBA)),
    _sfColorBufferType        (GLenum(GL_FLOAT)),
    _sfDepthBufferInternalFormat(GLenum(GL_DEPTH24_STENCIL8)),
    _sfDepthBufferPixelFormat (GLenum(GL_DEPTH_STENCIL)),
    _sfDepthBufferType        (GLenum(GL_UNSIGNED_INT_24_8)),
    _sfLumBufferInternalFormat(GLenum(GL_R32F)),
    _sfLumBufferPixelFormat   (GLenum(GL_RED)),
    _sfLumBufferType          (GLenum(GL_FLOAT)),
    _sfImageBufferInternalFormat(GLenum(GL_RGB16F)),
    _sfImageBufferPixelFormat (GLenum(GL_RGB)),
    _sfImageBufferType        (GLenum(GL_FLOAT)),
    _sfNumSamples             (Int32(4)),
    _sfMipmapLevel            (Int32(-1))
{
}

HDR2StageBase::HDR2StageBase(const HDR2StageBase &source) :
    Inherited(source),
    _sfActivate               (source._sfActivate               ),
    _sfApplyGamma             (source._sfApplyGamma             ),
    _sfAccurateGamma          (source._sfAccurateGamma          ),
    _sfGamma                  (source._sfGamma                  ),
    _sfAdjustLuminance        (source._sfAdjustLuminance        ),
    _sfTau                    (source._sfTau                    ),
    _sfPerformBloom           (source._sfPerformBloom           ),
    _sfBloomThreshold         (source._sfBloomThreshold         ),
    _sfBloomBackground        (source._sfBloomBackground        ),
    _sfBloomMagnitude         (source._sfBloomMagnitude         ),
    _sfNumTaps                (source._sfNumTaps                ),
    _sfBlurGaussSigma         (source._sfBlurGaussSigma         ),
    _sfToneMappingMode        (source._sfToneMappingMode        ),
    _sfForceBackground        (source._sfForceBackground        ),
    _sfUse_ITU_R_BT_709       (source._sfUse_ITU_R_BT_709       ),
    _sfAutoExposureMode       (source._sfAutoExposureMode       ),
    _sfExposure               (source._sfExposure               ),
    _sfKeyValue               (source._sfKeyValue               ),
    _sfApertureFNumber        (source._sfApertureFNumber        ),
    _sfShutterSpeed           (source._sfShutterSpeed           ),
    _sfISO                    (source._sfISO                    ),
    _sfWhiteLevel             (source._sfWhiteLevel             ),
    _sfSaturation             (source._sfSaturation             ),
    _sfUseLinChromCorrection  (source._sfUseLinChromCorrection  ),
    _sfFilterColor            (source._sfFilterColor            ),
    _sfContrast               (source._sfContrast               ),
    _sfShadowLiftColor        (source._sfShadowLiftColor        ),
    _sfMidToneGammaColor      (source._sfMidToneGammaColor      ),
    _sfHighlightGainColor     (source._sfHighlightGainColor     ),
    _mfFilmicCurveParameters  (source._mfFilmicCurveParameters  ),
    _sfDragoBias              (source._sfDragoBias              ),
    _sfTarget                 (source._sfTarget                 ),
    _sfPerformDithering       (source._sfPerformDithering       ),
    _sfCarryDepth             (source._sfCarryDepth             ),
    _sfColorBufferInternalFormat(source._sfColorBufferInternalFormat),
    _sfColorBufferPixelFormat (source._sfColorBufferPixelFormat ),
    _sfColorBufferType        (source._sfColorBufferType        ),
    _sfDepthBufferInternalFormat(source._sfDepthBufferInternalFormat),
    _sfDepthBufferPixelFormat (source._sfDepthBufferPixelFormat ),
    _sfDepthBufferType        (source._sfDepthBufferType        ),
    _sfLumBufferInternalFormat(source._sfLumBufferInternalFormat),
    _sfLumBufferPixelFormat   (source._sfLumBufferPixelFormat   ),
    _sfLumBufferType          (source._sfLumBufferType          ),
    _sfImageBufferInternalFormat(source._sfImageBufferInternalFormat),
    _sfImageBufferPixelFormat (source._sfImageBufferPixelFormat ),
    _sfImageBufferType        (source._sfImageBufferType        ),
    _sfNumSamples             (source._sfNumSamples             ),
    _sfMipmapLevel            (source._sfMipmapLevel            )
{
}


/*-------------------------- destructors ----------------------------------*/

HDR2StageBase::~HDR2StageBase(void)
{
}


GetFieldHandlePtr HDR2StageBase::getHandleActivate        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfActivate,
             this->getType().getFieldDesc(ActivateFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleActivate       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfActivate,
             this->getType().getFieldDesc(ActivateFieldId),
             this));


    editSField(ActivateFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleApplyGamma      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfApplyGamma,
             this->getType().getFieldDesc(ApplyGammaFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleApplyGamma     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfApplyGamma,
             this->getType().getFieldDesc(ApplyGammaFieldId),
             this));


    editSField(ApplyGammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleAccurateGamma   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAccurateGamma,
             this->getType().getFieldDesc(AccurateGammaFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleAccurateGamma  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAccurateGamma,
             this->getType().getFieldDesc(AccurateGammaFieldId),
             this));


    editSField(AccurateGammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleGamma           (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfGamma,
             this->getType().getFieldDesc(GammaFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleGamma          (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfGamma,
             this->getType().getFieldDesc(GammaFieldId),
             this));


    editSField(GammaFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleAdjustLuminance (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAdjustLuminance,
             this->getType().getFieldDesc(AdjustLuminanceFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleAdjustLuminance(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAdjustLuminance,
             this->getType().getFieldDesc(AdjustLuminanceFieldId),
             this));


    editSField(AdjustLuminanceFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleTau             (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfTau,
             this->getType().getFieldDesc(TauFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleTau            (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfTau,
             this->getType().getFieldDesc(TauFieldId),
             this));


    editSField(TauFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandlePerformBloom    (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfPerformBloom,
             this->getType().getFieldDesc(PerformBloomFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandlePerformBloom   (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfPerformBloom,
             this->getType().getFieldDesc(PerformBloomFieldId),
             this));


    editSField(PerformBloomFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBloomThreshold  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBloomThreshold,
             this->getType().getFieldDesc(BloomThresholdFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBloomThreshold (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBloomThreshold,
             this->getType().getFieldDesc(BloomThresholdFieldId),
             this));


    editSField(BloomThresholdFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBloomBackground (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfBloomBackground,
             this->getType().getFieldDesc(BloomBackgroundFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBloomBackground(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfBloomBackground,
             this->getType().getFieldDesc(BloomBackgroundFieldId),
             this));


    editSField(BloomBackgroundFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBloomMagnitude  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBloomMagnitude,
             this->getType().getFieldDesc(BloomMagnitudeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBloomMagnitude (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBloomMagnitude,
             this->getType().getFieldDesc(BloomMagnitudeFieldId),
             this));


    editSField(BloomMagnitudeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleNumTaps         (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfNumTaps,
             this->getType().getFieldDesc(NumTapsFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleNumTaps        (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfNumTaps,
             this->getType().getFieldDesc(NumTapsFieldId),
             this));


    editSField(NumTapsFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleBlurGaussSigma  (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfBlurGaussSigma,
             this->getType().getFieldDesc(BlurGaussSigmaFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleBlurGaussSigma (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfBlurGaussSigma,
             this->getType().getFieldDesc(BlurGaussSigmaFieldId),
             this));


    editSField(BlurGaussSigmaFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleToneMappingMode (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfToneMappingMode,
             this->getType().getFieldDesc(ToneMappingModeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleToneMappingMode(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfToneMappingMode,
             this->getType().getFieldDesc(ToneMappingModeFieldId),
             this));


    editSField(ToneMappingModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleForceBackground (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfForceBackground,
             this->getType().getFieldDesc(ForceBackgroundFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleForceBackground(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfForceBackground,
             this->getType().getFieldDesc(ForceBackgroundFieldId),
             this));


    editSField(ForceBackgroundFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleUse_ITU_R_BT_709 (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUse_ITU_R_BT_709,
             this->getType().getFieldDesc(Use_ITU_R_BT_709FieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleUse_ITU_R_BT_709(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUse_ITU_R_BT_709,
             this->getType().getFieldDesc(Use_ITU_R_BT_709FieldId),
             this));


    editSField(Use_ITU_R_BT_709FieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleAutoExposureMode (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfAutoExposureMode,
             this->getType().getFieldDesc(AutoExposureModeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleAutoExposureMode(void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfAutoExposureMode,
             this->getType().getFieldDesc(AutoExposureModeFieldId),
             this));


    editSField(AutoExposureModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleExposure        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfExposure,
             this->getType().getFieldDesc(ExposureFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleExposure       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfExposure,
             this->getType().getFieldDesc(ExposureFieldId),
             this));


    editSField(ExposureFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleKeyValue        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfKeyValue,
             this->getType().getFieldDesc(KeyValueFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleKeyValue       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfKeyValue,
             this->getType().getFieldDesc(KeyValueFieldId),
             this));


    editSField(KeyValueFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleApertureFNumber (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfApertureFNumber,
             this->getType().getFieldDesc(ApertureFNumberFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleApertureFNumber(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfApertureFNumber,
             this->getType().getFieldDesc(ApertureFNumberFieldId),
             this));


    editSField(ApertureFNumberFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleShutterSpeed    (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfShutterSpeed,
             this->getType().getFieldDesc(ShutterSpeedFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleShutterSpeed   (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfShutterSpeed,
             this->getType().getFieldDesc(ShutterSpeedFieldId),
             this));


    editSField(ShutterSpeedFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleISO             (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfISO,
             this->getType().getFieldDesc(ISOFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleISO            (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfISO,
             this->getType().getFieldDesc(ISOFieldId),
             this));


    editSField(ISOFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleWhiteLevel      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfWhiteLevel,
             this->getType().getFieldDesc(WhiteLevelFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleWhiteLevel     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfWhiteLevel,
             this->getType().getFieldDesc(WhiteLevelFieldId),
             this));


    editSField(WhiteLevelFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleSaturation      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfSaturation,
             this->getType().getFieldDesc(SaturationFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleSaturation     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfSaturation,
             this->getType().getFieldDesc(SaturationFieldId),
             this));


    editSField(SaturationFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleUseLinChromCorrection (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfUseLinChromCorrection,
             this->getType().getFieldDesc(UseLinChromCorrectionFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleUseLinChromCorrection(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfUseLinChromCorrection,
             this->getType().getFieldDesc(UseLinChromCorrectionFieldId),
             this));


    editSField(UseLinChromCorrectionFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilterColor     (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfFilterColor,
             this->getType().getFieldDesc(FilterColorFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilterColor    (void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfFilterColor,
             this->getType().getFieldDesc(FilterColorFieldId),
             this));


    editSField(FilterColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleContrast        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfContrast,
             this->getType().getFieldDesc(ContrastFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleContrast       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfContrast,
             this->getType().getFieldDesc(ContrastFieldId),
             this));


    editSField(ContrastFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleShadowLiftColor (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfShadowLiftColor,
             this->getType().getFieldDesc(ShadowLiftColorFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleShadowLiftColor(void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfShadowLiftColor,
             this->getType().getFieldDesc(ShadowLiftColorFieldId),
             this));


    editSField(ShadowLiftColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleMidToneGammaColor (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfMidToneGammaColor,
             this->getType().getFieldDesc(MidToneGammaColorFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleMidToneGammaColor(void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfMidToneGammaColor,
             this->getType().getFieldDesc(MidToneGammaColorFieldId),
             this));


    editSField(MidToneGammaColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleHighlightGainColor (void) const
{
    SFColor3f::GetHandlePtr returnValue(
        new  SFColor3f::GetHandle(
             &_sfHighlightGainColor,
             this->getType().getFieldDesc(HighlightGainColorFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleHighlightGainColor(void)
{
    SFColor3f::EditHandlePtr returnValue(
        new  SFColor3f::EditHandle(
             &_sfHighlightGainColor,
             this->getType().getFieldDesc(HighlightGainColorFieldId),
             this));


    editSField(HighlightGainColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleFilmicCurveParameters (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfFilmicCurveParameters,
             this->getType().getFieldDesc(FilmicCurveParametersFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleFilmicCurveParameters(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfFilmicCurveParameters,
             this->getType().getFieldDesc(FilmicCurveParametersFieldId),
             this));


    editMField(FilmicCurveParametersFieldMask, _mfFilmicCurveParameters);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDragoBias       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfDragoBias,
             this->getType().getFieldDesc(DragoBiasFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDragoBias      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfDragoBias,
             this->getType().getFieldDesc(DragoBiasFieldId),
             this));


    editSField(DragoBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleTarget          (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfTarget,
             this->getType().getFieldDesc(TargetFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleTarget         (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfTarget,
             this->getType().getFieldDesc(TargetFieldId),
             this));


    editSField(TargetFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandlePerformDithering (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfPerformDithering,
             this->getType().getFieldDesc(PerformDitheringFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandlePerformDithering(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfPerformDithering,
             this->getType().getFieldDesc(PerformDitheringFieldId),
             this));


    editSField(PerformDitheringFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleCarryDepth      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfCarryDepth,
             this->getType().getFieldDesc(CarryDepthFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleCarryDepth     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfCarryDepth,
             this->getType().getFieldDesc(CarryDepthFieldId),
             this));


    editSField(CarryDepthFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleColorBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfColorBufferInternalFormat,
             this->getType().getFieldDesc(ColorBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleColorBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfColorBufferInternalFormat,
             this->getType().getFieldDesc(ColorBufferInternalFormatFieldId),
             this));


    editSField(ColorBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleColorBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfColorBufferPixelFormat,
             this->getType().getFieldDesc(ColorBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleColorBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfColorBufferPixelFormat,
             this->getType().getFieldDesc(ColorBufferPixelFormatFieldId),
             this));


    editSField(ColorBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleColorBufferType (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfColorBufferType,
             this->getType().getFieldDesc(ColorBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleColorBufferType(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfColorBufferType,
             this->getType().getFieldDesc(ColorBufferTypeFieldId),
             this));


    editSField(ColorBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDepthBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfDepthBufferInternalFormat,
             this->getType().getFieldDesc(DepthBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDepthBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfDepthBufferInternalFormat,
             this->getType().getFieldDesc(DepthBufferInternalFormatFieldId),
             this));


    editSField(DepthBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDepthBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfDepthBufferPixelFormat,
             this->getType().getFieldDesc(DepthBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDepthBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfDepthBufferPixelFormat,
             this->getType().getFieldDesc(DepthBufferPixelFormatFieldId),
             this));


    editSField(DepthBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleDepthBufferType (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfDepthBufferType,
             this->getType().getFieldDesc(DepthBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleDepthBufferType(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfDepthBufferType,
             this->getType().getFieldDesc(DepthBufferTypeFieldId),
             this));


    editSField(DepthBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleLumBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfLumBufferInternalFormat,
             this->getType().getFieldDesc(LumBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleLumBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfLumBufferInternalFormat,
             this->getType().getFieldDesc(LumBufferInternalFormatFieldId),
             this));


    editSField(LumBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleLumBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfLumBufferPixelFormat,
             this->getType().getFieldDesc(LumBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleLumBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfLumBufferPixelFormat,
             this->getType().getFieldDesc(LumBufferPixelFormatFieldId),
             this));


    editSField(LumBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleLumBufferType   (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfLumBufferType,
             this->getType().getFieldDesc(LumBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleLumBufferType  (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfLumBufferType,
             this->getType().getFieldDesc(LumBufferTypeFieldId),
             this));


    editSField(LumBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleImageBufferInternalFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfImageBufferInternalFormat,
             this->getType().getFieldDesc(ImageBufferInternalFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleImageBufferInternalFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfImageBufferInternalFormat,
             this->getType().getFieldDesc(ImageBufferInternalFormatFieldId),
             this));


    editSField(ImageBufferInternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleImageBufferPixelFormat (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfImageBufferPixelFormat,
             this->getType().getFieldDesc(ImageBufferPixelFormatFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleImageBufferPixelFormat(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfImageBufferPixelFormat,
             this->getType().getFieldDesc(ImageBufferPixelFormatFieldId),
             this));


    editSField(ImageBufferPixelFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleImageBufferType (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfImageBufferType,
             this->getType().getFieldDesc(ImageBufferTypeFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleImageBufferType(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfImageBufferType,
             this->getType().getFieldDesc(ImageBufferTypeFieldId),
             this));


    editSField(ImageBufferTypeFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleNumSamples      (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfNumSamples,
             this->getType().getFieldDesc(NumSamplesFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleNumSamples     (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfNumSamples,
             this->getType().getFieldDesc(NumSamplesFieldId),
             this));


    editSField(NumSamplesFieldMask);

    return returnValue;
}

GetFieldHandlePtr HDR2StageBase::getHandleMipmapLevel     (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfMipmapLevel,
             this->getType().getFieldDesc(MipmapLevelFieldId),
             const_cast<HDR2StageBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr HDR2StageBase::editHandleMipmapLevel    (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfMipmapLevel,
             this->getType().getFieldDesc(MipmapLevelFieldId),
             this));


    editSField(MipmapLevelFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void HDR2StageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    HDR2Stage *pThis = static_cast<HDR2Stage *>(this);

    pThis->execSync(static_cast<HDR2Stage *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *HDR2StageBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    HDR2Stage *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const HDR2Stage *>(pRefAspect),
                  dynamic_cast<const HDR2Stage *>(this));

    return returnValue;
}
#endif

void HDR2StageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfFilmicCurveParameters.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
